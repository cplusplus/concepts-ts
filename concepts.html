<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concepts-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-NOTE");document.createElement("CXX-GRAMMARTERM");document.createElement("BNF-GRAMMAR");document.createElement("BNF-RULE");document.createElement("BNF-ALT");document.createElement("CXX-GRAMMARTER");document.createElement("CXX-EXAMPLE");document.createElement("CXX-CODEBLOCK");document.createElement("BNF-TERMINAL");document.createElement("BNF-OPT");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

@media print {
cxx-titlepage {
	height: 8.8in;
}


}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  
  <style>
del.local {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}
del.local > * {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}

ins.local {
  color: Black;
  text-decoration: underline;
  background-color: LightSteelBlue; 
}
ins.local > * {
  color: Black;
  text-decoration: under;
  background-color: LightSteelBlue; 
}

.quoted {
  margin-left: .25in;
  margin-right: .35in;
}
</style>
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 9pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 9pt; }
    @bottom-left { content: string(current-section, last); font-size: 9pt; }
    @bottom-right { content: counter(page); font-size: 9pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 9pt; text-align: justify; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {
        height: 100%;
        text-align: justify; 
    }
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>C++ Extensions for Concepts, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>N4205</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-10-10</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4040.pdf">N4040</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Andrew Sutton<br>
    University of Akron<br>
    <cxx-email><a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, C++ Extensions for Concepts</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#intro">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#intro.refs">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#intro.compliance">Implementation compliance</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#intro.ack">Acknowledgments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#lex">Lexical conventions</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#lex.key">Keywords</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#expr">Expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#expr.prim">Primary expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.2</span><a href="#expr.prim.lambda">Lambda expressions</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#expr.prim.req">Requires expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.3.1</span><a href="#expr.prim.req.simple">Simple requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.2</span><a href="#expr.prim.req.type">Type requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.3</span><a href="#expr.prim.req.compound">Compound requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.4</span><a href="#expr.prim.req.nested">Nested requirements</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#dcl.dcl">Declarations</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#dcl.spec">Specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6</span><a href="#dcl.type">Type specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6.2</span><a href="#dcl.type.simple">Simple type specifiers</a>
        
      </li>
            
              <li><span class="marker">7.1.6.4</span><a href="#dcl.spec.auto">auto specifier</a>
        
      </li>
            
              <li><span class="marker">7.1.6.5</span><a href="#dcl.spec.constr">Constrained type specifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.1.7</span><a href="#dcl.spec.concept">concept specifier</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#dcl.decl">Declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3</span><a href="#dcl.meaning">Meaning of declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3.5</span><a href="#dcl.fct">Functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.4</span><a href="#dcl.fct.def">Function definitions</a>
        
          <ol>
            
              <li><span class="marker">8.4.1</span><a href="#dcl.fct.def.general">In general</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9</span><a href="#class">Classes</a>
        
          <ol>
            
              <li><span class="marker">9.2</span><a href="#class.mem">Class members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">10</span><a href="#class.derived">Derived classes</a>
        
          <ol>
            
              <li><span class="marker">10.3</span><a href="#class.virtual">Virtual functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13</span><a href="#over">Overloading</a>
        
          <ol>
            
              <li><span class="marker">13.2</span><a href="#over.dcl">Declaration matching</a>
        
      </li>
            
              <li><span class="marker">13.3</span><a href="#over.match">Overload resolution</a>
        
          <ol>
            
              <li><span class="marker">13.3.1</span><a href="#over.match.viable">Viable functions</a>
        
      </li>
            
              <li><span class="marker">13.3.2</span><a href="#over.match.best">Best viable function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13.4</span><a href="#over.over">Address of overloaded function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#temp">Templates</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#temp.param">Template parameters</a>
        
      </li>
            
              <li><span class="marker">14.2</span><a href="#temp.intro">Introduction of template parameters</a>
        
      </li>
            
              <li><span class="marker">14.3</span><a href="#temp.names">Names of template specializations</a>
        
      </li>
            
              <li><span class="marker">14.4</span><a href="#temp.arg">Template arguments</a>
        
          <ol>
            
              <li><span class="marker">14.4.1</span><a href="#temp.arg.template">Template template arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5</span><a href="#temp.decls">Template declarations</a>
        
          <ol>
            
              <li><span class="marker">14.5.1</span><a href="#temp.class">Class templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.1.1</span><a href="#temp.mem.func">Member functions of class templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.2</span><a href="#temp.mem">Member templates</a>
        
      </li>
            
              <li><span class="marker">14.5.4</span><a href="#temp.friend">Friends</a>
        
      </li>
            
              <li><span class="marker">14.5.5</span><a href="#temp.class.spec">Class template partial specialization</a>
        
          <ol>
            
              <li><span class="marker">14.5.5.1</span><a href="#temp.class.spec.match">Matching of class template partial specializations</a>
        
      </li>
            
              <li><span class="marker">14.5.5.2</span><a href="#temp.class.order">Partial ordering of class template specializations</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.6</span><a href="#temp.fct">Function templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.6.1</span><a href="#temp.over.link">Function template overloading</a>
        
      </li>
            
              <li><span class="marker">14.5.6.2</span><a href="#temp.func.order">Partial ordering of function templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.7</span><a href="#temp.spec">Template instantiation and specialization</a>
        
          <ol>
            
              <li><span class="marker">14.7.1</span><a href="#temp.inst">Implicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.2</span><a href="#temp.explicit">Explicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.3</span><a href="#temp.expl.spec">Explicit specialization</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.8</span><a href="#temp.fct.spec">Function template specializations</a>
        
          <ol>
            
              <li><span class="marker">14.8.2</span><a href="#temp.deduct">Template argument deduction</a>
        
          <ol>
            
              <li><span class="marker">14.8.2.6</span><a href="#temp.deduct.decl">Deducing template arguments from a function declaration</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9</span><a href="#temp.constr">Template constraints</a>
        
          <ol>
            
              <li><span class="marker">14.9.1</span><a href="#temp.constr.op">Logical operators</a>
        
          <ol>
            
              <li><span class="marker">14.9.1.1</span><a href="#temp.constr.op.conj">Conjunction</a>
        
      </li>
            
              <li><span class="marker">14.9.1.2</span><a href="#temp.constr.op.disj">Disjunction</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9.2</span><a href="#temp.constr.atom">Atomic constraints</a>
        
          <ol>
            
              <li><span class="marker">14.9.2.1</span><a href="#temp.constr.atom.pred">Predicate constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.2</span><a href="#temp.constr.atom.expr">Expression constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.3</span><a href="#temp.constr.atom.type">Type constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.4</span><a href="#temp.constr.atom.conv">Implicit conversion constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.5</span><a href="#temp.constr.atom.deduct">Argument deduction constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.6</span><a href="#temp.constr.atom.constexpr">Constant expression constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.7</span><a href="#temp.constr.atom.noexcept">Exception constraints</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9.3</span><a href="#temp.constr.order">Partial ordering by constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.4</span><a href="#temp.constr.expr">Constraint expressions</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="intro">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#intro">[intro]</a></span></header>
      
  

  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++ 
    Programming Language (<cxx-ref to="intro.refs"><a title="intro.refs" href="#intro.refs">1.2</a></cxx-ref>) that
    enable the specification and checking of constraints on template 
    arguments, and the ability to overload functions and specialize
    class templates based on those constraints. These extensions include 
    new syntactic forms and modifications to existing language semantics.</p>

    <p para_num="2" id="general.scope.2">International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document as 
    written as a set of changes against that specification. Instructions
    to modify or add paragraphs are written as explicit instructions. 
    Modifications made directly to existing text from the International
    Standard use <ins>underlining</ins> to represent added text and
    <del>strikethrough</del> to represent deleted text.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.refs">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#intro.refs">[intro.refs]</a></span></header>
      
    

    <p para_num="1" id="intro.refs.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC 14882:2014, <cite>Programming Languages - C++</cite>
      </li>
    </ul>

    <p para_num="2" id="intro.refs.2">ISO/IEC 14882:2014 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++
    §3.2".</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.compliance">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Implementation compliance">Implementation compliance</h1> <span style="float:right"><a href="#intro.compliance">[intro.compliance]</a></span></header>
      
    
    <p para_num="1" id="intro.compliance.1">Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance">C++ <span title="intro.compliance">§1.4</span></cxx-ref>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Conformance is defined in terms of the behavior of
    programs.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.ack">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Acknowledgments">Acknowledgments</h1> <span style="float:right"><a href="#intro.ack">[intro.ack]</a></span></header>
      
    
  
    <p para_num="1" id="intro.ack.1">The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ standard library, known 
    as ``The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p para_num="2" id="intro.ack.2">This work was funded by NSF grant ACI-1148461.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>


<cxx-clause id="lex">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Lexical conventions">Lexical conventions</h1> <span style="float:right"><a href="#lex">[lex]</a></span></header>
      
  

  <cxx-section id="lex.key" <="" cxx-section="">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Keywords">Keywords</h1> <span style="float:right"><a href="#lex.key">[lex.key]</a></span></header>
      
    

    In <cxx-ref in="cxx" to="lex.key">C++ <span title="lex.key">§2.12</span></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.

  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="expr" number="5">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Expressions">Expressions</h1> <span style="float:right"><a href="#expr">[expr]</a></span></header>
      
  

  <!-- ===================
       Primary expressions
       =================== -->

  <cxx-section id="expr.prim">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Primary expressions">Primary expressions</h1> <span style="float:right"><a href="#expr.prim">[expr.prim]</a></span></header>
      
    

    In this section, add the 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> to the rule for 
    <cxx-grammarterm><i>primary-expression</i></cxx-grammarterm>.
    
    <bnf-grammar>
    
    
      <bnf-rule>
    
    primary-expression:
  </bnf-rule>
        <ins><bnf-alt>
    
    requires-expression
  </bnf-alt></ins>
    
  </bnf-grammar>


  <!-- ==================
       Lambda expressions
       ================== -->

    <cxx-section id="expr.prim.lambda" number="2">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Lambda expressions">Lambda expressions</h1> <span style="float:right"><a href="#expr.prim.lambda">[expr.prim.lambda]</a></span></header>
      
      

      Insert the following paragraph after paragraph 4 to define the
      term "generic lambda". 

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      A <dfn>generic lambda</dfn> is a 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> where either the
      <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      or a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>)
      appears in a parameter type of the
      <cxx-grammarterm><i>lambda-declarator</i></cxx-grammarterm>.
      </p>

      Modify paragraph 5 so that the meaning of a generic lambda is defined 
      in terms of its abbreviated member function call operator.

      <p para_num="6" id="expr.prim.lambda.6" number="6" class="quoted">
      The closure type for a non-generic
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call">C++ <span title="over.call">§13.5.4</span></cxx-ref>)
      whose parameters and return type are described by the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>, respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"><a title="temp.mem" href="#temp.mem">14.5.2</a></cxx-ref>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarter>template-parameter</cxx-grammarter> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration declares</i></cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      For a generic lambda, the function call operator is an abbreviated
      member function, whose parameters and return type are derived according
      to the rules in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>.
      </ins>
      </p>

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5. Note that
      the existing examples in the original document are omitted in this
      document.

      <ins>
      <p number="5" class="quoted">
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

auto gl = [](C&amp; a, C* b) { a = *b }; // <i>OK: denotes a generic lambda</i>

struct Fun {
    auto operator()(C&amp; a, C* b) const { a = *b; }
} fun;</code></pre>
  
      <code>C</code> is a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda <code>gl</code>
      and the function object <code>fun</code> have equivalent behavior when 
      called with the same arguments.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
      </ins>

    
    </section>
  </cxx-section> <!-- expr.prim.lambda -->


  <!-- ====================
       Requires expressions
       ==================== -->

  <cxx-section id="expr.prim.req">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Requires expressions">Requires expressions</h1> <span style="float:right"><a href="#expr.prim.req">[expr.prim.req]</a></span></header>
      
    

    <p para_num="1" id="expr.prim.req.1">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    
    A syntactic requirement is one that can be checked by name lookup 
    (<cxx-ref in="cxx" to="basic.lookup">C++ <span title="basic.lookup">§3.4</span></cxx-ref>) or by checking
    properties of types and expressions. 

    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> defines
    a conjunction of constraints (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>),
    which are introduced by its 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s.

    <bnf-grammar>
    
    
      <bnf-rule>
    
    requires-expression:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> 
          requirement-parameter-list requirement-body
  </bnf-alt>

    <bnf-rule>
    
    requirement-parameter-list:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>(</code></bnf-terminal> 
        <bnf-opt>parameter-declaration-clause<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>)</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-body:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>{</code></bnf-terminal> 
        requirement-list 
        <bnf-terminal><code>}</code></bnf-terminal> 
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-list:
  </bnf-rule>
      <bnf-alt>
    
    requirement <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    requirement-list requirement
  </bnf-alt>

    <bnf-rule>
    
    requirement:
  </bnf-rule>
      <bnf-alt>
    
    simple-requirement
  </bnf-alt>
      <bnf-alt>
    
    type-requirement
  </bnf-alt>
      <bnf-alt>
    
    compound-requirement
  </bnf-alt>
      <bnf-alt>
    
    nested-requirement
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    <p para_num="2" id="expr.prim.req.2"> A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> has type
    <code>bool</code>.</p>

    <p para_num="3" id="expr.prim.req.3"> A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> evaluates
    to <code>true</code> when all of its introduced constraints are
    satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>), and <code>false</code> 
    otherwise. </p>

    <p para_num="4" id="expr.prim.req.4">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> shall appear
    only within a concept definition (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) 
    or a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
    <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>),
    <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
    (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
    <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
    (<cxx-ref to="dcl.fct.def"><a title="dcl.fct.def" href="#dcl.fct.def">8.4</a></cxx-ref>), or
    <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
    (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    The most common use of 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s is to define
    syntactic requirements in concepts  
    such as the one below:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -&gt; const A&lt;T&gt;&amp;;
    };
  }</code></pre>
  
    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> can also be
    used in a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
The first <code>requires</code> introduces the 
<cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, and the second
introduces the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="5" id="expr.prim.req.5">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> may introduce
    local parameters using a 
    <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 
  
    Each name introduced by a local parameter is in scope from the point
    of its declaration until the closing brace of the
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm>.

    These parameters have no linkage, storage, or lifetime; they are only used
    as notation for the purpose of defining 
    <cxx-grammarterm><i>requirements</i></cxx-grammarterm>. 
    </p>

    <p para_num="6" id="expr.prim.req.6">A local parameter shall not have a default argument.</p>

    <p para_num="7" id="expr.prim.req.7">The <cxx-grammarterm><i>requirement-parameter-list</i></cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p para_num="8" id="expr.prim.req.8">The <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> defines a
    block scope, and is comprised of a sequence of 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s.

    These <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s may refer to local 
    parameters, template parameters, and any other declarations visible from the 
    enclosing context. 

    Each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> 
    appends one or more atomic constraints 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) to the conjunction of constraints
    defined by the <cxx-grammarterm><i>requires-expressions</i></cxx-grammarterm>.
    </p>


  <!-- ====================
       Simple requirements
       ==================== -->

    <cxx-section id="expr.prim.req.simple">
    

    <section>
      <header><span class="section-number">5.1.3.1</span> <h1 data-bookmark-label="5.1.3.1 Simple requirements">Simple requirements</h1> <span style="float:right"><a href="#expr.prim.req.simple">[expr.prim.req.simple]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    simple-requirement:
  </bnf-rule>
          <bnf-alt>
    
    expression
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.simple.1">A <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> introduces 
      an expression constraint (<cxx-ref to="temp.constr.atom.expr"><a title="temp.constr.atom.expr" href="#temp.constr.atom.expr">14.9.2.2</a></cxx-ref>) 
      for its <cxx-grammarterm><i>expression</i></cxx-grammarterm>.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C =
  requires (T a, T b) {
    a + b;  // <i>a simple requirement</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.prim.req.simple.2"> The substitution of template arguments into the
      <cxx-grammarterm><i>expression</i></cxx-grammarterm> of a 
      <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> may result
      in an ill-formed expression. However, the resulting program is not 
      ill-formed. </p>

      <p para_num="3" id="expr.prim.req.simple.3"> If the expression would always result in a substitution failure, 
      the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typenamne T&gt; concept bool C =
  requires () {
    new T[-1];  // <i>error: the expression will never be well-formed</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.simple -->


  <!-- =================
       Type requirements
       ================= -->

    <cxx-section id="expr.prim.req.type">
    

    <section>
      <header><span class="section-number">5.1.3.2</span> <h1 data-bookmark-label="5.1.3.2 Type requirements">Type requirements</h1> <span style="float:right"><a href="#expr.prim.req.type">[expr.prim.req.type]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    type-requirement:
  </bnf-rule>
          <bnf-alt>
    
    
            typename-specifier
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.type.1">A <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> introduces 
      type constraint (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) for 
      the type named by its 
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm>.
      
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A type requirement asserts the validity of an associated
      type, either as a member type, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm><i>type-specifiers</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; struct S { };
template&lt;typename T&gt; using Ref = T&amp;;

template&lt;typename T&gt; concept bool C =
  requires () {
    typename T::inner; // <i>required nested type name</i>
    template S&lt;T&gt;;   // <i>required class template specialization</i>
    typename Ref&lt;T&gt;; // <i>required alias template substitution</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.prim.req.type.2"> The substitution of template arguments into the
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> may result
      in an ill-formed type. However, the resulting program is not 
      ill-formed. </p>

      <p para_num="3" id="expr.prim.req.type.3"> If the required type would always result in a substitution failure,
      then the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C =
  requires () {
    typename int::X;  // <i>error: int does not have class type</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.type -->



    <!-- =====================
         Compound requirements
         ===================== -->

    <cxx-section id="expr.prim.req.compound">
    

    <section>
      <header><span class="section-number">5.1.3.3</span> <h1 data-bookmark-label="5.1.3.3 Compound requirements">Compound requirements</h1> <span style="float:right"><a href="#expr.prim.req.compound">[expr.prim.req.compound]</a></span></header>
      
      
      
      <bnf-grammar>
    
    
        <bnf-rule>
    
    compound-requirement:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt><bnf-terminal><code>constexpr</code></bnf-terminal><sub>opt</sub></bnf-opt>
            <bnf-terminal><code>{</code></bnf-terminal> expression <bnf-terminal><code>}</code></bnf-terminal>
            <bnf-opt><bnf-terminal><code>noexcept</code></bnf-terminal><sub>opt</sub></bnf-opt>
            <bnf-opt>trailing-return-type<sub>opt</sub></bnf-opt>
            <bnf-terminal><code>;</code></bnf-terminal>
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.compound.1">A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces 
      a conjunction of one or more atomic constraints related to its
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>.

      A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> appends
      an expression constraint (<cxx-ref to="temp.constr.atom.expr"><a title="temp.constr.atom.expr" href="#temp.constr.atom.expr">14.9.2.2</a></cxx-ref>)
      for its <cxx-grammarterm><i>expression</i></cxx-grammarterm>,
      <code>E</code>.

      The <code>constexpr</code> specifier, if present, appends a constant 
      expression constraint (<cxx-ref to="temp.constr.atom.constexpr"><a title="temp.constr.atom.constexpr" href="#temp.constr.atom.constexpr">14.9.2.6</a></cxx-ref>) 
      for <code>E</code>.

      The <code>noexcept</code> specifier, if present, appends an exception 
      constraint (<cxx-ref to="temp.constr.atom.noexcept"><a title="temp.constr.atom.noexcept" href="#temp.constr.atom.noexcept">14.9.2.7</a></cxx-ref>) for 
      <code>E</code>.

      If the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> is
      given, and its type (call it <code>T</code>), contains no placeholders
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>, <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),
      the requirement appends two constraints to the conjunction of 
      constraints: 
      
      a type constraint on the formation of <code>T</code>
      (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) and

      an implicit conversion constraint from <code>E</code> to <code>T</code>
      (<cxx-ref to="temp.constr.atom.conv"><a title="temp.constr.atom.conv" href="#temp.constr.atom.conv">14.9.2.4</a></cxx-ref>).

      Otherwise, if <code>T</code> contains placeholders, an argument deduction 
      constraint (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>)
      of <code>E</code> against the type <code>T</code>
      is appended to the conjunction of constraints. 

      In this constraint, deduction is performed against an invented function
      template whose declaration is formed according to the rules for
      abbreviated functions in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref> where 
      <code>T</code> is the type of the invented function's only parameter.

      <!-- FIXME: This is hard to read. Consider braking them up. -->
      </p><p para_num="2" id="expr.prim.req.compound.2">
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename I&gt; concept bool C() { return true; }

template&lt;typename D&gt; concept bool D = s
  requires(T x) {
    {x++};                     // <i>#1</i>
    {*x} -&gt; typename T::inner; // <i>#2</i>
    {f(x)} -&gt; const C&amp;;        // <i>#3</i>
    {g(x)} noexcept;           // <i>#4</i>
    constexpr {T::value};      // <i>#5</i>
  };</code></pre>
  
      Each of these requirements introduces a valid expression constraint
      on the expression in its enclosing braces.

      Requirement #1 only an expression constraint on <code>x++</code>. It is 
      equivalent to a <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> 
      with the same <cxx-grammarterm><i>expression</i></cxx-grammarterm>.
      
      Requirement #2 <code>*x</code> introduces three constraints: an 
      expression constraint for <code>*x</code>, a type constraint
      for <code>typename T::inner</code>, and a conversion constraint
      requiring <code>*x</code> to be implicitly convertible to 
      <code>typename T::inner</code>.

      Requirement #3 also introduces two constraints: an
      expression constraint for <code>f(x)</code>, and a deduction
      constraint requiring that overload resolution succeeds for the
      call <code>i(f(x))</code> where <code>g</code> is the following
      invented function template.
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; requires C&lt;T&gt;() void i(const T&amp;);</code></pre>
  </cxx-codeblock>

      Requirement #4 introduces two constraints: an expression constraint
      for <code>g(x)</code> and an exception constraint on
      <code>g(x)</code>.

      Requirement #5 also introduces two constraints: An expression constraint
      on <code>T::value</code> and a constant expression constraint that
      <code>T::value</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>

      <p para_num="3" id="expr.prim.req.compound.3"> The substitution of template arguments into the
      <cxx-grammarterm><i>expression</i></cxx-grammarterm> of a 
      <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> may result
      in an ill-formed expression. However, the resulting program is not 
      ill-formed. </p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.compound -->


    <cxx-section id="expr.prim.req.nested">
    

    <section>
      <header><span class="section-number">5.1.3.4</span> <h1 data-bookmark-label="5.1.3.4 Nested requirements">Nested requirements</h1> <span style="float:right"><a href="#expr.prim.req.nested">[expr.prim.req.nested]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    nested-requirement:
  </bnf-rule>
          <bnf-alt>
    
    requires-clause <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
        
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.nested.1"> A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> can be used
      to specify additional constraints on a type declared by a
      <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> 
      (<cxx-ref to="expr.prim.req.type"><a title="expr.prim.req.type" href="#expr.prim.req.type">5.1.3.2</a></cxx-ref>).

      It appends a normalization of the 
      <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      of its <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> to the
      conjunction of constraints (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
     
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return sizeof(T) == 1; }

template&lt;typename T&gt; concept bool D =
  requires () {
    typename X&lt;T&gt;;
    requires C&lt;X&lt;T&gt;&gt;();
  };</code></pre>
  
      The <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> appends
      the predicate constraint <code>sizeof(T) == 1</code>
      (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>).
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
     <!-- expr.prim.req.nested -->
 
   <!-- expr.prim.req -->

 <!-- expr -->
<p></p>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-clause>

<cxx-clause id="dcl.dcl" number="7">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Declarations">Declarations</h1> <span style="float:right"><a href="#dcl.dcl">[dcl.dcl]</a></span></header>
      
  

  <!-- ==========
       Specifiers
       ========== -->

  <cxx-section id="dcl.spec">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Specifiers">Specifiers</h1> <span style="float:right"><a href="#dcl.spec">[dcl.spec]</a></span></header>
      
    

    Extend the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p para_num="1" id="dcl.spec.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    decl-specifier:
  </bnf-rule>
        <ins><bnf-alt>
    
    <bnf-terminal><code>concept</code></bnf-terminal>
  </bnf-alt></ins>
    
  </bnf-grammar>
    </p>


    <!-- ===============
         Type specifiers
         =============== -->

    <cxx-section id="dcl.type" number="6">
    

    <section>
      <header><span class="section-number">7.1.6</span> <h1 data-bookmark-label="7.1.6 Type specifiers">Type specifiers</h1> <span style="float:right"><a href="#dcl.type">[dcl.type]</a></span></header>
      
      


      <!-- ======================
           Simple type specifiers
           ====================== -->

      <cxx-section id="dcl.type.simple" number="2">
    

    <section>
      <header><span class="section-number">7.1.6.2</span> <h1 data-bookmark-label="7.1.6.2 Simple type specifiers">Simple type specifiers</h1> <span style="float:right"><a href="#dcl.type.simple">[dcl.type.simple]</a></span></header>
      
        
        
        Add <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        to the grammar for <cxx-grammarterm><i>simple-type-specifier</i></cxx-grammarterm>s.

        <p para_num="1" id="dcl.type.simple.1" class="quoted">
        <bnf-grammar>
    
    
          <bnf-rule>
    
    simple-type-specifier:
  </bnf-rule>
            <ins><bnf-alt>
    
    constrained-type-specifier
  </bnf-alt></ins>
        
  </bnf-grammar>
        </p>
      
    </section>
  </cxx-section> <!-- dcl.type.simple -->


      <!-- ==============
           auto specifier
           ============== -->

      <cxx-section id="dcl.spec.auto" number="4">
    

    <section>
      <header><span class="section-number">7.1.6.4</span> <h1 data-bookmark-label="7.1.6.4 auto specifier"><code>auto</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.auto">[dcl.spec.auto]</a></span></header>
      
        

        Modify paragraph 1 to extend the use of <code>auto</code> to
        designate abbreviated functions.

        <p para_num="1" id="dcl.spec.auto.1" number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The use of the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> in a non-deduced 
        context (<cxx-ref in="cxx" to="temp.deduct.type">C++ <span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>) will cause the 
        deduction of a value for that placeholder type to fail, resulting
        in an ill-formed program.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <ins class"local"="">
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>struct N {
  template&lt;typename T&gt; struct Wrap;
  template&lt;typename T&gt; static Wrap<t> make_wrap(T);
};
template&lt;typename T, typename U&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

template&lt;int N&gt; struct Size { void f(int) { }  };
Size&lt;0&gt; s;
bool g(char, double);

void (auto::*)(auto) p = &amp;Size&lt;0&gt;::f;   // <i>OK</i>
N::Wrap&lt;auto&gt; a = N::make_wrap(0.0);    // <i>OK</i>
Pair&lt;auto, auto&gt; p = make_pair(0, 'a'); // <i>OK</i>
auto::Wrap&lt;int&gt; x = N::make_wrap(0);    // <i>error: failed to deduce value for</i> auto
Size&lt;sizeof(auto)&gt; y = s;               // <i>error: failed to deduce value for</i> auto
        </t></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        Modfify paragraph 2, allowing multiple occurrences of <code>auto</code>
        in those contexts where it is valid.

        <p para_num="2" id="dcl.spec.auto.2" number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, 
        <cxx-grammarterm><i>type-specifier-seq</i></cxx-grammarterm>,
        <cxx-grammarterm><i>conversion-function-id</i></cxx-grammarterm>, or
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
        in any context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify paragraph 3 to allow the use of <code>auto</code> within the 
        parameter type of a lambda or function.

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
        <ins>in a parameter type</ins> 
        of a
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>, the lambda is
        a generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears in a parameter type of a function declarator, that is an 
        abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>void f(const auto&amp;, int); // <i>OK: an abbreviated function</i></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        <p></p>

        Add the following after paragraph 3 to allow the use of 
        <code>auto</code> in the 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>.

        <p para_num="4" id="dcl.spec.auto.4" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in
        a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
        (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>), that
        return type introduces an argument deduction constraint
        (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>).
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -&gt; const auto&amp;; // <i>OK: introduces an argument deduction constraint</i>
  };
}</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        Modify paragraph 4 to allow multiple uses of <code>auto</code> within
        certain declarations. Note that the examples in the original text are 
        unchanged and therefore omitted.

        <!-- FIXE: This probably doesn't allow things like int '(*)(auto)', 
             but it should. -->

        <p para_num="4" id="dcl.spec.auto.4" number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block">C++ <span title="stmt.block">§6.3</span></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace">C++ <span title="basic.scope.namespace">§3.3.6</span></cxx-ref>), and 
        in a <cxx-grammarterm><i>for-init-statement</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for">C++ <span title="stmt.for">§6.5.3</span></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
    
    </cxx-codeblock></p><pre><code>( <i>expression-list</i> )</code></pre>
  
        the <cxx-grammarterm><i>expression-list</i></cxx-grammarterm> shall be a 
        single <cxx-grammarterm><i>assignment-expression</i></cxx-grammarterm>.
        <p></p>

        Update the rules in paragraph 7 to allow deduction of multiple
        occurrences of <code>auto</code> in a declaration.

        <p para_num="5" id="dcl.spec.auto.5" class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list">C++ <span title="dcl.init.list">§8.5.4</span></cxx-ref>), the program is 
        ill-formed. 

        <del>
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing the 
        occurrences of <code>auto</code> with either a new invented type 
        template parameter <code>U</code> or, if the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>, with 
        <code>std::initializer_list&lt;U&gt;</code>.
        </del>

        <ins>
        Otherwise, obtain <code>P</code> from <code>T</code> as follows:
        </ins></p><div class="quoted">
        <ul>
        <li> replace each occurrence of <code>auto</code> in the variable type 
        with a new invented type template parameter, or </li>

        <li> when the initializer is a <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>
        and <code>auto</code> is a <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>
        of the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        the variable declaration, replace that occurrence of <code>auto</code> 
        with <code>std::initializer_list&lt;U&gt;</code>
        where <code>U</code> is an invented template type parameter.</li>
        </ul>
        

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call">C++ <span title="temp.deduct.call">§14.8.2.1</span></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code><ins>template&lt;typename T&gt; struct Vec { };
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;) { return Vec&lt;T&gt;{}; } </ins>

auto x1 = { 1, 2 };                 // <ins><i>OK:</i></ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = *x1.begin();             // <i>OK:</i> decltype(x3) <i>is</i> int&amp;
const auto* p = &amp;x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltype(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3};           // <i>error: cannot deduce element type</i></ins></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>const auto<ins>&amp;</ins><del> &amp;</del>i = expr;</code></pre>
  </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
    
    <pre><code>template &lt;class U&gt; void f(const U&amp; u);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
    
    <pre><code>template&lt;typename F, typename S&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

struct S { void mfn(bool); } s;
int fn(char, double);

Pair&lt;auto (*)(auto, auto), auto (auto::*)(auto)&gt; p = make_pair(fn, &amp;S::mfn);</code></pre>
  </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(make_pair(fn, &amp;S::mfn))</code> of the following invented function 
template:
        <cxx-codeblock>
    
    <pre><code>template&lt;class T1, class T2, class T2, class T3, class T4, class T5, class T6&gt; 
  void g(Pair&lt; T1(*)(T2, T3), T4 (T5::*)(T6)&gt;);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </div>

      
    </section>
  </cxx-section> <!-- dcl.spec.auto -->


      <!-- ===========================
           Constrained type specifiers
           =========================== -->

      <cxx-section id="dcl.spec.constr">
    

    <section>
      <header><span class="section-number">7.1.6.5</span> <h1 data-bookmark-label="7.1.6.5 Constrained type specifiers">Constrained type specifiers</h1> <span style="float:right"><a href="#dcl.spec.constr">[dcl.spec.constr]</a></span></header>
      
        

        Add this section to <cxx-ref in="cxx" to="dcl.type">C++ <span title="dcl.type">§7.1.6</span></cxx-ref>.

        <p para_num="1" id="dcl.spec.constr.1"> Like the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>),
        a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder that will be replaced later by deduction
        from the <cxx-grammarterm><i>expression</i></cxx-grammarterm> in a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> or a
        function argument. 

        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s have
        the form

        <bnf-grammar>
    
    
          <bnf-rule>
    
    constrained-type-specifier:
  </bnf-rule>
            <bnf-alt>
    
    
              <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> constrained-type-name
            
  </bnf-alt>

          <bnf-rule>
    
    constrained-type-name:
  </bnf-rule>
            <bnf-alt>
    
    concept-name
  </bnf-alt>
            <bnf-alt>
    
    partial-concept-id
  </bnf-alt>

          <bnf-rule>
    
    concept-name:
  </bnf-rule>
            <bnf-alt>
    
    identifier
  </bnf-alt>

          <bnf-rule>
    
    partial-concept-id:
  </bnf-rule>
            <bnf-alt>
    
    
              concept-name 
              <bnf-terminal><code>&lt;</code></bnf-terminal> 
              <bnf-opt>template-argument-list<sub>opt</sub></bnf-opt>
              <bnf-terminal><code>&gt;</code></bnf-terminal>
            
  </bnf-alt>
        
  </bnf-grammar>

        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        may also designate placeholders for deduced non-type and template 
        template arguments.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = false;
template&lt;int N&gt; concept bool C2 = false;
template&lt;template&lt;typename&gt; class X&gt; C3 = false;

template&lt;typename T, int N&gt; class Array { };
template&lt;typename T, template&lt;typename&gt; class A&gt; class Stack { };
template&lt;typename T&gt; class Alloc { };

void f1(C1 c);            // C1 <i>designates a placeholder type</i>
void f2(Array&lt;auto, C2&gt;); // C2 <i>designates a placeholder for an integer value</i>
void f3(Stack&lt;auto, C3&gt;); // C3 <i>designates a placeholder for a class template</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="2" id="dcl.spec.constr.2">
        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        can appear in many of the same places as the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, is subject
        to the same rules, and has equivalent meaning in those contexts. 
        In particular, a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
        can appear in the following contexts with the given meaning:
        </p><ul>
        <li> a parameter type of a function declaration, signifying an 
             abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>);</li>
        <li> a parameter of a lambda, signifying a generic lambda 
             (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>);</li>
        <li> the parameter type of a template parameter, signifying a
             constrained template parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>);</li>
        <li> the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of
             a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>
             (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>),
             signifying an argument deduction constraint 
             (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>). </li>
        </ul>
        A program that includes a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in any other contexts is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T, int N&gt; concept bool C2 = true;
template&lt;bool (*)(int)&gt; concept bool C3 = true;

template&lt;typename T&gt; class Vec;

struct N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;
template&lt;bool (*)(int)&gt; struct Pred;

auto gl = [](C1&amp; a, C1* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C1&gt;&amp; x);              // <i>OK: an abbreviated function</i>

void f1(N::Wrap&lt;C1&gt;);     // <i>OK</i>
void f2(Pair&lt;C1, C2&lt;0&gt;&gt;); // <i>OK</i>
void f3(Pred&lt;C3&gt;);        // <i>OK</i>
void f4(C1::Wrap&lt;C2&lt;1&gt;&gt;); // <i>OK: but deduction of</i> C1 <i>will always fail</i>

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -&gt; const C1&amp;; // <i>OK: an argument deduction constraint</i>
  };
}</code></pre>
  </cxx-codeblock>
The declaration of <code>f4</code> is valid, but a value can never be deduced 
for the placeholder designated by <code>C1</code> since it appears in a
non-deduced context (<cxx-ref in="cxx" to="temp.deduct.type">C++ <span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>).
However, a value may be explicitly given as a template argument in a
<cxx-grammarterm><i>template-id</i></cxx-grammarterm>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <!-- </p> -->

        <p para_num="3" id="dcl.spec.constr.3">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Unlike <code>auto</code>, a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> cannot 
        be used in the type of a variable declaration or the return type of
        a function.
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

const C* x = 0;  // <i>error:</i> C <i>used in a variable type</i>
D&lt;0&gt; fn(int x);  // <i>error:</i> D&lt;0&gt; <i>used as a return type</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        
    <span class="nowrap">— <em>end note</em> ]</span>
  
        <p></p>

        <p para_num="4" id="dcl.spec.constr.4">
        A <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> refers to a
        set of concept definitions (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        If that set is empty, the program is ill-formed.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member of this set when a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        refers to a variable concept.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#3</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #3</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="5" id="dcl.spec.constr.5">
        A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="6" id="dcl.spec.constr.6">
        The concept designated by a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is resolved by determining the viability of each concept in the
        candidate concept set.

        For each candidate concept in that set, <code>TT</code> is a 
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> formed as follows:

        let <code>C</code> be the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        for the candidate concept set, and let <code>X</code> be a template 
        argument that matches
        the type and form (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.4</a></cxx-ref>) of the prototype 
        parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        of the candidate concept. 

        The template <code>X</code> is called the 
        <dfn>deduced concept argument</dfn>.

        If the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> in
        the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>TT</code> is
        formed as <code>C&lt;X&gt;</code>.

        Otherwise, the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> whose
        <cxx-grammarterm><i>template-argument-list</i></cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub></code>, and
        <code>TT</code> is formed as
        <code>C&lt;X, A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub>&gt;</code>.

        The candidate concept is a <dfn>viable candidate concept</dfn> when all
        <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> of <code>TT</code> 
        match the template parameters of that candidate 
        (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.4</a></cxx-ref>).

        If, after determining the viability of each concept, there is a
        single viable candidate concept, that is the concept designated by the
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="7" id="dcl.spec.constr.7">The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        associates a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the association is with
        the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        For an abbreviated function declaration, the association is with
        with that function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        When a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> it
        associates a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        with the invented function template of the introduced argument 
        deduction constraint (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>).

        When a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is used in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>,
        the constrained it associates a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the
        <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> in which the
        <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is declared.
        </p>

        <!-- FIXME: This is practically unreadable -->

        <p para_num="8" id="dcl.spec.constr.8"> The <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        associated by a
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is derived from the <cxx-grammarterm><i>template-id</i></cxx-grammarterm> 
        (called <code>TT</code> above) used to determine the viability of
        the designated concept (call it <code>D</code>).

        The constraint is formed by replacing the
        deduced concept argument <code>X</code> in <code>TT</code> with a 
        template argument, <code>A</code>. That template argument is
        defined as follows:
        </p><ul>
        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        of a function or lambda, 

        or when the when the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>,

        <code>A</code> is the name of the
        invented template parameter corresponding to the 
        placeholder in that (possibly invented) function template 
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>) ;</li>

        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
        declaration, <code>A</code> is the name of the declared
        parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>). </li>
        </ul>

        Let <code>TT2</code> be a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
        formed as follows. 

        If the template parameter <code>A</code> declares a template parameter 
        pack, and <code>D</code> is a variadic concept 
        (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>),
        <code>TT2</code> is formed by replacing the deduced concept
        argument <code>X</code> in 
        <code>TT</code> with the pack expansion <code>A...</code>.

        Otherwise <code>TT2</code> is formed by replacing <code>X</code>
        with <code>A</code>.

        Let <code>E</code> be the <cxx-grammarterm><i>id-expression</i></cxx-grammarterm>
        <code>TT2</code> when the <code>D</code> is a variable concept, and
        the function call <code>TT2()</code> when the <code>D</code> is a 
        function concept.

        If the template parameter <code>A</code> declares a template
        parameter pack, and <code>D</code> is not a variadic concept,
        then the associated constraint is the fold expression 
        <code>(E &amp;&amp; ...)</code>
        (<cxx-ref in="cxx" to="expr.prim.fold">C++ <span title="expr.prim.fold">§5.1.4</span></cxx-ref>).
        
        Otherwise, the associated constraint is the expression <code>E</code>.
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }
template&lt;int N&gt; concept bool Num = true;

template&lt;int&gt; struct X { };

void f(C&amp;);              // <i>associates</i> C&lt;T1&gt; <i>with</i> f
void g(D&lt;int&gt;);          // <i>associates</i> D&lt;T2, int&gt;() <i>with</i> g
void h(X&lt;Num&gt;);          // <i>associates</i> Num&lt;M&gt; <i>with</i> h
template&lt;C T&gt; struct s1; // <i>associates</i> C&lt;T&gt; <i>with</i> s1</code></pre>
  </cxx-codeblock>
        Here, <code>T1</code> and <code>T2</code> are invented type template 
        parameters corresponding to the
        prototype parameter of their respective designated concepts.
        Likewise, <code>M</code> is an invented non-type template parameter
        corresponding to the prototype parameter of <code>Num</code>.
        <p></p>

        <p>Two <cxx-grammarterm><i>constrained-type-specifiers</i></cxx-grammarterm>
        are said to be equivalent if their associated
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s are
        equivalent according to the rules in 
        <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>.</p>

      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    </section>
  </cxx-section> <!-- dcl.spec.constr -->

    
    </section>
  </cxx-section> <!-- dcl.type -->


    <!-- =================
         concept specifier
         ================= --> 

    <cxx-section id="dcl.spec.concept">
    

    <section>
      <header><span class="section-number">7.1.7</span> <h1 data-bookmark-label="7.1.7 concept specifier"><code>concept</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.concept">[dcl.spec.concept]</a></span></header>
      
      

      <p para_num="1" id="dcl.spec.concept.1"> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template, declared
      in namespace scope (<cxx-ref in="cxx" to="basic.scope.namespace">C++ <span title="basic.scope.namespace">§3.3.6</span></cxx-ref>).
      
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A function
      concept is a non-throwing function 
      (<cxx-ref in="cxx" to="except.spec">C++ <span title="except.spec">§15.4</span></cxx-ref>).
      
      A variable template definition having the <code>concept</code> 
      specifier is called a <dfn>variable concept</dfn>.

      A <dfn>concept definition</dfn> refers to either a function concept 
      and its definition or a variable concept and its initializer.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; 
  concept bool F1() { return true; } // <i>OK: declares a function concept</i>
template&lt;typename T&gt; 
  concept bool F2();                 // <i>error: function concept is not a definition</i>
template&lt;typename T&gt; 
  concept bool V1 = true;            // <i>OK: declares a variable concept</i>
template&lt;typename T&gt; 
  concept bool V2;                   // <i>error: variable concept with no initializer</i>
struct S {
  template&lt;typename T&gt; 
    static concept bool C = true;    // <i>error: concept declared in class scope</i>
};</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="dcl.spec.concept.2"> Every concept definition is implicitly defined to be a 
      <code>constexpr</code> declaration 
      (<cxx-ref in="cxx" to="dcl.constexpr">C++ <span title="dcl.constexpr">§7.1.5</span></cxx-ref>). </p>

      <p para_num="3" id="dcl.spec.concept.3"> No storage specifiers shall appear in a declaration with the 
      <code>concept</code> specifier. Additionally, a concept definition
      shall not include the <code>friend</code> or <code>constexpr</code>
      specifiers. </p>

      <p para_num="4" id="dcl.spec.concept.4">A concept definition shall be unconstrained.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A concept defines a total mapping from its template arguments to the 
      values <code>true</code> and <code>false</code>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

      <p para_num="5" id="dcl.spec.concept.5"> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p para_num="6" id="dcl.spec.concept.6">A function concept has the following restrictions:
      </p><ul>
        <li> No <cxx-grammarterm><i>function-specifier</i></cxx-grammarterm>s shall
             appear in its declaration (<cxx-ref to="dcl.fct.spec"><a title="dcl.fct.spec" href="#dcl.fct.spec"></a></cxx-ref>). </li>
        <li> The declared return type shall be the non-deduced type <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm><i>expression</i></cxx-grammarterm> shall be a
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
        (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).
        </li>
      </ul>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Return type deduction requires the instantiation of the function 
      definition, but concept definitions are not instantiated; they
      are normalized (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept int F1() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept auto F3(T) { return true; } // <i>error: return type is deduced</i>
template&lt;typename T&gt; 
  concept bool F2(T) { return true; } // <i>error: must have no parameters</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="7" id="dcl.spec.concept.7">A variable concept has the following restrictions:
      </p><ul>
        <li> The declared type shall be <code>bool</code>. </li>
        <li> The declaration shall have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept bool V2 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
template&lt;Integral T&gt; 
  concept bool V3 = true;  // <i>error: constrained template declared as a concept</i>
concept bool V4 = 0;       // <i>error: not a template</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="8" id="dcl.spec.concept.8">A program that declares an explicit instantiation
      (<cxx-ref to="temp.explicit"><a title="temp.explicit" href="#temp.explicit">14.7.2</a></cxx-ref>), an explicit specialization 
      (<cxx-ref to="temp.expl.spec"><a title="temp.expl.spec" href="#temp.expl.spec">14.7.3</a></cxx-ref>), or a partial specialization 
      of a concept definition is ill-formed.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

    
    </section>
  </cxx-section> <!-- dcl.concept -->

  
    </section>
  </cxx-section> <!-- dcl.spec -->

    </section>
  </cxx-clause> <!-- dcl.dcl -->


<cxx-clause id="dcl.decl" number="8">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Declarators">Declarators</h1> <span style="float:right"><a href="#dcl.decl">[dcl.decl]</a></span></header>
      
  

  Modify the definition of the <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  production in <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1 as follows:

  <p para_num="1" id="dcl.decl.1" class="quoted">
  A declarator declares a single variable, function, or type within a 
  declaration. The <cxx-grammarterm><i>init-declarator-list</i></cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which may
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    
    
    <bnf-rule>
    
    init-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        <bnf-opt>initializer<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
  
  </bnf-grammar>
  </p>

  Insert the following paragraphs.

  <p para_num="2" id="dcl.decl.2" class="quoted">
  A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm> shall only appear
  with a function declarator (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  If present, the <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> associates 
  its <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the declared
  function (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

void f1(int x) requires C&lt;int&gt;;       // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = 'a'; // <i>error: constrained variable declaration</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="3" id="dcl.decl.3" class="quoted">
  The names of parameters in a function declarator are visible in the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

void f(auto x) requires C&lt;decltype(x)&gt;;
void g(int n) requires sizeof(n) == 4;</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- ======================
       Meaning of declarators
       ====================== -->

  <cxx-section id="dcl.meaning" number="3">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Meaning of declarators">Meaning of declarators</h1> <span style="float:right"><a href="#dcl.meaning">[dcl.meaning]</a></span></header>
      
    


    <!-- =========
         Functions
         ========= -->

    <cxx-section id="dcl.fct" number="5">
    

    <section>
      <header><span class="section-number">8.3.5</span> <h1 data-bookmark-label="8.3.5 Functions">Functions</h1> <span style="float:right"><a href="#dcl.fct">[dcl.fct]</a></span></header>
      
      

      Refactor the grammar for 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>s in
      paragraph 3 in order to support the definition of
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s in
      Clause 14.

      <p para_num="3" id="dcl.fct.3" class="quoted" number="3">
      <bnf-grammar>
    
    
        <bnf-rule>
    
    parameter-declaration:
  </bnf-rule>
          <del>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq declarator
          
  </bnf-alt>
          
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq declarator 
            <bnf-terminal><code>=</code></bnf-terminal> 
            initializer-clause
          
  </bnf-alt>
          
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator<sub>opt</sub></bnf-opt>
          
  </bnf-alt>
          
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator<sub>opt</sub></bnf-opt> 
            <bnf-terminal><code>=</code></bnf-terminal> 
            initializer-clause
  </bnf-alt>
          </del>

          <ins>
          <bnf-alt>
    
    
            basic-parameter-declaration
          
  </bnf-alt>
          <bnf-alt>
    
    
            basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer
          
  </bnf-alt>
          </ins>

        <ins>
        <bnf-rule>
    
    basic-parameter-declaration:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            decl-specifier-seq 
            declarator
          
  </bnf-alt>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator<sub>opt</sub></bnf-opt>
          
  </bnf-alt>
        </ins>
      
  </bnf-grammar></p>

      Modify the second sentence of paragraph 5. The remainder of this
      paragraph has been omitted.

      <p para_num="5" id="dcl.fct.5" class="quoted" number="5">
      A single name can be used for several different functions in a single 
      scope; this is function overloading (<cxx-ref to="over"><a title="over" href="#over">13</a></cxx-ref>). 

      All declarations for a function shall agree exactly in <del>both</del> 
      the return type<ins>,</ins> <del>and</del> the parameter-type-list<ins>,
      and asssociated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
      </p>

      Modify paragraph 15. Note that the footnote reference has been
      omitted.

      <p para_num="15" id="dcl.fct.15" class="quoted" number="15">
      There is a syntactic ambiguity when an ellipsis occurs at the end of a 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> without
      a preceding comma. In this case, the ellipsis is parsed as part of the 
      <cxx-grammarterm><i>abstract-declarator</i></cxx-grammarterm> if the type of the
      parameter either names a template parameter pack that has not been 
      expanded or contains <ins>either</ins> <code>auto</code> <ins>or a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm></ins>; otherwise, 
      it is parsed as part of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>.
      </p>

      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct">C++ <span title="dcl.fct">§8.3.5</span></cxx-ref>/15.

      <p para_num="16" id="dcl.fct.16" class="quoted" number="16">
      An <dfn>abbreviated function</dfn> is a function whose
      parameter-type-list inclues one or more placeholders 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>,
      <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).

      An abbreviated function is equivalent to a function template 
      (<cxx-ref to="temp.fct"><a title="temp.fct" href="#temp.fct">14.5.6</a></cxx-ref>) whose
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      includes one invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
      for each occurrence of a placeholder in the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, 
      in order of appearance. 

      If the placeholder is designated by the <code>auto</code>
      <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, then the corresponding
      invented template parameter is a type 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      Otherwise, the placeholder is designated by a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>, and
      the corresponding invented parameter matches the type and form of
      the prototype parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) of 
      the concept designated by the 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

      The invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
      declares a function parameter pack and the type of the parameter 
      contains only one placeholder.

      <!-- TODO: This is up for discussion. Striking it should have
           no serious consequence. Note that there is a corresponding
           example in this section. Also, I need to modify the previous
           sentence to remove this restriction. -->
      If the type of the function parameter that declares a function
      parameter pack containing more than one placeholder, the program
      is ill-formed.

      The adjusted function parameters of an abbreviated function are derived 
      from the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> 
      by replacing each occurrence of a placeholder with the name of the 
      corresponding invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      If the replacement of a placeholder with the name of a template parameter
      results in an invalid parameter declaration, the program is ill-formed.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(const auto&amp;, auto);
void f2(Vec&lt;auto*&gt;...);
void f3(auto (auto::*)(auto));

template&lt;typename T, typename U&gt; 
  void f1(const T&amp;, U);        // <i>redeclaration of</i> f1(const auto&amp;, auto)
template&lt;typename... T&gt; 
  void f2(Vec&lt;T*&gt;...);         // <i>redeclaration of</i> f2(Vec&lt;auto*&gt;...)
template&lt;typename T, typename U, typename V&gt;
  void f3(T (U::*)(V));        // <i>redeclaration of</i> f3(auto (auto::*)(auto))

void foo(Pair&lt;auto, auto&gt;...); // <i>error: multiple placeholder types in a parameter pack</i>

template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;
template&lt;typename T, typename U&gt; concept bool D = true;

void g1(const C1*, C2&amp;);
void g2(Vec&lt;C1&gt;&amp;);
void g3(C1&amp;...);
void g4(Vec&lt;D&lt;int&gt;&gt;);

template&lt;C1 T, C2 U&gt; void g1(const T*, U&amp;); // <i>redeclaration of</i> g1(const C1*, C2&amp;)
template&lt;C1 T&gt; void g2(Vec&lt;T&gt;&amp;);            // <i>redeclaration of</i> g2(Vec&lt;C1&gt;&amp;)
template&lt;C1... Ts&gt; void g3(Ts&amp;...);         // <i>redeclaration of</i> g3(C1&amp;...)
template&lt;D&lt;int&gt; T&gt; void g4(Vec&lt;T&gt;);         // <i>redeclaration of</i> g4(Vec&lt;D&lt;int&gt;&gt;)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; concept bool Num = true;

void h(Num*); // <i>error: invalid type in parameter declaration</i></code></pre>
  </cxx-codeblock>
The equivalent and erroneous declaration would have this form:
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; void h(N*); // <i>error: invalid type</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p></p>

      <p para_num="17" id="dcl.fct.17"> All placeholders introduced
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      that are equivalent according to the definition in
      <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref> have the
      same invented template parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>namespace N {
  template&lt;typename T&gt; concept bool C = true;
}
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int&gt; concept bool D = true;
template&lt;typename, int = 0&gt; concept bool E = true;

void f0(C a, C b);</code></pre>
  
      The types of <code>a</code> and <code>b</code> are the same invented template
      type parameter.

      <cxx-codeblock>
    
    <pre><code>void f1(C&amp; a, C* b);</code></pre>
  </cxx-codeblock>
      The type of <code>a</code> is a reference to an invented template type parameter 
      (call it <code>T</code>), and the type of <code>b</code> is a pointer to 
      <code>T</code>.

      <cxx-codeblock>
    
    <pre><code>void f2(N::C a, C b);
void f3(D&lt;0&gt; a, D&lt;1&gt; b);</code></pre>
  </cxx-codeblock>
      In both functions, the parameters <code>a</code> and
      <code>b</code> have different invented template type parameters.

      <cxx-codeblock>
    
    <pre><code>void f4(E a, E&lt;&gt; b, E&lt;0&gt; c);</code></pre>
  </cxx-codeblock>
      The types of <code>a</code>, <code>b</code>, and <code>c</code> are
      the same since <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
      <code>E</code>, <code>E&lt;&gt;</code>, and <code>E&lt;0&gt;</code>
      all associate the <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>,
      <code>E&lt;T, 0&gt;</code>, where <code>T</code> is an invented
      template type parameter.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>

      <!-- TODO: Move into temp.fct? -->
      <p para_num="18" id="dcl.fct.18"> A function template can be an abbreviated function. The
      invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s are
      added to the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: equivalent to f(Array&lt;auto, N&gt;*)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- dcl.fct -->
  
  
    </section>
  </cxx-section> <!-- dcl.meaning -->


  <!-- ====================
       Function definitions
       ==================== -->

  <cxx-section id="dcl.fct.def">
    

    <section>
      <header><span class="section-number">8.4</span> <h1 data-bookmark-label="8.4 Function definitions">Function definitions</h1> <span style="float:right"><a href="#dcl.fct.def">[dcl.fct.def]</a></span></header>
      
    


    <!-- ==========
         In general
         ========== -->

    <cxx-section id="dcl.fct.def.general">
    

    <section>
      <header><span class="section-number">8.4.1</span> <h1 data-bookmark-label="8.4.1 In general">In general</h1> <span style="float:right"><a href="#dcl.fct.def.general">[dcl.fct.def.general]</a></span></header>
      
      
    
      Modify the <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>
      to include a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.

      <p para_num="1" id="dcl.fct.def.general.1" class="quoted">
      <bnf-grammar>
    
    
        <bnf-rule>
    
    function-definition:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            <bnf-opt>decl-specifier-seq<sub>opt</sub></bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
            <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
            function-body
          
  </bnf-alt>
      
  </bnf-grammar>
      </p>

      Add the following paragraph.

      <p para_num="9" id="dcl.fct.def.general.9" number="9" class="quoted">
      <ins> If present, the <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
      associates its <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      with the function (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      </ins></p>

    
    </section>
  </cxx-section> <!-- dcl.fct.def.general -->
  
    </section>
  </cxx-section> <!-- dcl.fct.def -->

    </section>
  </cxx-clause> <!-- dcl.decl -->


<cxx-clause id="class" number="9">
    

    <section>
      <header><span class="section-number">9</span> <h1 data-bookmark-label="9 Classes">Classes</h1> <span style="float:right"><a href="#class">[class]</a></span></header>
      
  

  <!-- =============
       Class members
       ============= -->

  <cxx-section id="class.mem" number="2">
    

    <section>
      <header><span class="section-number">9.2</span> <h1 data-bookmark-label="9.2 Class members">Class members</h1> <span style="float:right"><a href="#class.mem">[class.mem]</a></span></header>
      
    

    Modify the grammar in 9.2 to allow a 
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> for member declarations.

    <p para_num="1" id="class.mem.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    member-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator 
        <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        <bnf-opt>pure-specifier-seq<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    Insert the following after paragraph 8, explaining where a
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> can appear
    and that its <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
    can refer to parameters.

    <p para_num="9" id="class.mem.9" class="quoted" number="9">
    A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> shall only appear
    in a <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm> if its
    <cxx-grammarterm><i>declarator</i></cxx-grammarterm> is a function declarator.

    The <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> associates its 
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the 
    member function.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct A {
    A(int*) requires true;  // <i>OK: constrained constructor</i>
    ~A() requires true;     // <i>OK: constrained destructor</i>
    void f() requires true; // <i>OK: constrained member function</i>
    int x requires true;    // <i>error: constrained member variable</i>
  };</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="10" id="class.mem.10" class="quoted">
    The names of parameters in a function declarator are visible in the
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>. </p>
  
    </section>
  </cxx-section> <!-- class.mem -->


    </section>
  </cxx-clause>


<cxx-clause id="class.derived" number="10">
    

    <section>
      <header><span class="section-number">10</span> <h1 data-bookmark-label="10 Derived classes">Derived classes</h1> <span style="float:right"><a href="#class.derived">[class.derived]</a></span></header>
      
  

  <cxx-section id="class.virtual" number="3">
    

    <section>
      <header><span class="section-number">10.3</span> <h1 data-bookmark-label="10.3 Virtual functions">Virtual functions</h1> <span style="float:right"><a href="#class.virtual">[class.virtual]</a></span></header>
      
    

    Insert the following paragraph after paragraph 5 in order to
    prohibit the declaration of constrained virtual functions and
    the overriding of a virtual function by a constrained member
    function.

    <p para_num="6" id="class.virtual.6" class="quoted" number="6">
    If a virtual function has associated constraints 
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), the program is ill-formed. If
    a constrained member function overrides a virtual function in any
    base class, the program is ill-formed.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct A {
  virtual void f() requires true; // <i>error: constrained virtual function</i>
};

struct B {
  virtual void f();
};

struct D : B {
  void f() requires true; // <i>error: constrained override</i>
}</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    
    </section>
  </cxx-section> <!-- class.virtual -->


    </section>
  </cxx-clause> <!-- class.derived -->


<cxx-clause id="over" number="13">
    

    <section>
      <header><span class="section-number">13</span> <h1 data-bookmark-label="13 Overloading">Overloading</h1> <span style="float:right"><a href="#over">[over]</a></span></header>
      
  

  Modify paragraph 1 to allow overloading based on constraints.

  <p para_num="1" id="over.1" class="quoted">
  When two or more different declarations are specified for a single name 
  in the same scope, that name is said to be overloaded. By extension, two 
  declarations in the same scope that declare the same name but with
  different types 
  <ins>or different associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
  are called <dfn>overloaded declarations</dfn>. Only function and function 
  template declarations can be overloaded; variable and type declarations 
  cannot be overloaded.
  </p>

  Update paragraph 3 to mention a function's overloaded constraints. 
  Note that the itemized list in the original text is omitted in this
  document.

  <p para_num="3" id="over.3" number="3" class="quoted">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  As specified in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>, function declarations 
  that have equivalent parameter declarations 
  <ins>and associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>,
  declare the same function and therefore cannot be overloaded: ...
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>


  <cxx-section id="over.dcl" number="2">
    

    <section>
      <header><span class="section-number">13.2</span> <h1 data-bookmark-label="13.2 Declaration matching">Declaration matching</h1> <span style="float:right"><a href="#over.dcl">[over.dcl]</a></span></header>
      
    

    Modify paragraph 1 to extend the notion of declaration matching to
    also include a function's associated constrains. Note that the
    example in the original text is omitted in this document.

    <p para_num="1" id="over.dcl.1" class="quoted">
    Two function declarations of the same name refer to the same function if 
    they are in the same scope and have equivalent parameter declarations 
    (<cxx-ref in="cxx" to="over.load">C++ <span title="over.load">§13.1</span></cxx-ref>)
    <ins>and equivalent associated constraints, 
    if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
    </p>
  
    </section>
  </cxx-section> <!-- over.dcl -->

  <cxx-section id="over.match">
    

    <section>
      <header><span class="section-number">13.3</span> <h1 data-bookmark-label="13.3 Overload resolution">Overload resolution</h1> <span style="float:right"><a href="#over.match">[over.match]</a></span></header>
      
    

    <cxx-section id="over.match.viable">
    

    <section>
      <header><span class="section-number">13.3.1</span> <h1 data-bookmark-label="13.3.1 Viable functions">Viable functions</h1> <span style="float:right"><a href="#over.match.viable">[over.match.viable]</a></span></header>
      
      

      Update paragraph 1 to require the checking of a candidate's associated
      constraints when determining if that candidate is viable.

      <p para_num="1" id="over.match.viable.1" class="quoted">
      From the set of candidate functions constructed for a given context 
      (<cxx-ref in="cxx" to="over.match.funcs">C++ <span title="over.match.funcs">§13.3.1</span></cxx-ref>), a set of viable 
      functions is chosen, from which the best function will be selected by 
      comparing argument conversion sequences and associated constraints
      for the best fit (<cxx-ref to="over.match.best"><a title="over.match.best" href="#over.match.best">13.3.2</a></cxx-ref>).

      The selection of viable functions considers 
      <ins>their associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), and</ins>
      their relationships between arguments and function parameters other 
      than the ranking of conversion sequences.
      </p>

      Insert the following paragraph after paragraph 1; this introduces
      new a criterion for determining if a candidate is viable. Also, update
      the beginning of the subsequent paragraphs to account for the
      insertion.

      <p para_num="2" id="over.match.viable.2" class="quoted" number="2">
      First, for <code>F</code> to be a viable function, if <code>F</code> has 
      associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), those 
      constraints shall be satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      </p>

      <p para_num="3" id="over.match.viable.3" class="quoted" number="3">
      <del>First</del><ins>Second</ins>, to be a viable function ...
      </p>

      <p para_num="4" id="over.match.viable.4" class="quoted" number="4">
      <del>Second</del><ins>Third</ins>, for <code>F</code> to be a viable function ...
      </p>

    
    </section>
  </cxx-section> <!-- over.match.viable -->

    <cxx-section id="over.match.best">
    

    <section>
      <header><span class="section-number">13.3.2</span> <h1 data-bookmark-label="13.3.2 Best viable function">Best viable function</h1> <span style="float:right"><a href="#over.match.best">[over.match.best]</a></span></header>
      
      

      Modify the last item in the list in paragraph 1 and extend it with
      a final comparison based on the associated constraints of those
      functions. Note that the preceding (unmodified) items in the original 
      document are elided in this document.

      <p para_num="1" id="over.match.best.1" class="quoted">
      Define ICS<i>i</i>(<code>F</code>) as follows:
      </p><ul>
      <li> ... </li>
      <li> <code>F1</code> and <code>F2</code> are function template 
      specializations, and the function template for <code>F1</code> is more 
      specialized than the template for <code>F2</code> according to the 
      partial ordering rules described in 
      <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref><del>.</del><ins>, or, 
      if not that,</ins> </li>
      
      <li><ins>
      The parameter-type-lists of <code>F1</code> and <code>F2</code> are
      the same and <code>F1</code> is more constrained than <code>F2</code> 
      according to the partial ordering of constraints described in
      <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.
      </ins></li>
      </ul>
      <!-- </p> -->
    
    </section>
  </cxx-section> <!-- over.match.best -->
  
    </section>
  </cxx-section> <!-- over.match -->



  <cxx-section id="over.over">
    

    <section>
      <header><span class="section-number">13.4</span> <h1 data-bookmark-label="13.4 Address of overloaded function">Address of overloaded function</h1> <span style="float:right"><a href="#over.over">[over.over]</a></span></header>
      
    

    The introduction of constraints modifies the rules for determining
    which function is selected when taking the address of an overloaded
    function. Insert a new paragraph before paragraph 4.

    <p para_num="4" id="over.over.4" class="quoted" number="4">
    If a single constrained function is selected, and the constraints are
    not satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>), the program
    is ill-formed. 
    </p>

    Modify paragraph 4 (paragraph 5 in this document) to incorporate 
    constraints in the selection of an overloaded function when its address is 
    taken. Also add the following example after that in the original document 
    (not shown here).

    <p para_num="5" id="over.over.5" number="5" class="quoted">
    If more than one function is selected, any function template 
    specializations in the set are eliminated if the set also contains a 
    function that is not a function template 
    specialization<del>, and</del><ins>. 

    Any given non-template function
    <code>F0</code> is eliminated if the set contains a second non-template
    function that is more constrained than <code>F0</code> according to
    the partial ordering rules of 
    <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.</ins>
    
    <ins>Furthermore,</ins> any given function template specialization
    <code>F1</code> is eliminated if the set contains a second function 
    template specialization whose function template is more specialized than 
    the function template of <code>F1</code> according to the partial ordering 
    rules of <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>.

    After such eliminations, if any, there shall remain exactly one 
    selected function.

    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>void f() { }                // <i>#1</i>
void f() requires true { }; // <i>#2</i>
void g() requires false;

void (*pf)() = &amp;f;         // <i>selects #2</i>
void (*pg)() = &amp;g;         // <i>error: g() cannot be selected</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
    
    </section>
  </cxx-section> <!-- over.over -->


    </section>
  </cxx-clause>


<cxx-clause id="temp" number="14">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Templates">Templates</h1> <span style="float:right"><a href="#temp">[temp]</a></span></header>
      
  

  Modify the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p para_num="1" id="temp.1" number="1" class="quoted">
  <bnf-grammar>
    
    
    <bnf-rule>
    
    template-declaration:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>template</code></bnf-terminal>
        <bnf-terminal><code>&lt;</code></bnf-terminal>
        template-parameter-list
        <bnf-terminal><code>&gt;</code></bnf-terminal>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        declaration
      
  </bnf-alt>
      <ins>
      <bnf-alt>
    
    template-introduction declaration
  </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>
    
    requires-clause:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> constraint-expression
  </bnf-alt>
    </ins>
  
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after paragraph 6.

  <p para_num="7" id="temp.7" number="7" class="quoted"> 
  A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), or they are
  introduced by a <cxx-grammarterm><i>template-introduction</i></cxx-grammarterm>
  (<cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>).
  </p>


  <p para_num="8" id="temp.8" class="quoted">
  The <dfn>associated constraints</dfn> of a 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> are the 
  logical <code>&amp;&amp;</code> of all 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s introduced by:
  </p>
  
  <div class="quoted">
  <ul>
  <li> a concept introduction, and</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>, and</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>)
  in the declaration's <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,
  and </li>

  <li> any <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
  a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>), and</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> appearing after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> of an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).</li>
  </ul>

  Let <code>T1</code> be a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  with associated constraints. <code>T1</code> is equivalent to another
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T2</code>) 
  whose template parameters are declared explicitly as unconstrained template 
  parameters, and <code>T2</code> has a single
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> whose 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T1</code> 
  (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>). <code>T2</code> is said
  to be the <dfn>canonical declaration</dfn> of all declarations that are 
  equivalent to it according to the rules below.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);</code></pre>
  </cxx-codeblock>
  The last declaration is the canonical declaration of <code>g(T)</code>.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  
  </div>

  <p para_num="8" id="temp.8" class="quoted" number="8"> 
  When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is
  declared by a template introduction (<cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>), 
  its canonical declaration is a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> whose
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> is defined 
  according to the rules for introducing template parameters in
  <cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>, and the 
  equivalent declaration has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  formed as follows.

  Let <code>TT</code> be a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
  formed as 
  <code>C&lt;I<i>1</i>, I<i>2</i>, ..., I<i>n</i>, D<i>1</i>, D<i>2</i>, ..., D<i>n</i>&gt;</code>
  where <code>C</code> is the name of the designated concept,
  <code>I<i>1</i>, I<i>2</i>, ..., I<i>n</i></code> is the sequence
  of introduced template parameters, and
  <code>D<i>1</i>, D<i>2</i>, ..., D<i>n</i></code> is the (possibly empty)
  sequence of instantiated default template arguments needed to form the
  <cxx-grammarterm><i>template-id</i></cxx-grammarterm> that refers to <code>C</code>.

  If an introduced parameter declares a template parameter pack, the
  corresponding template argument in the <code>TT</code> is a pack
  expansion (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>).
  
  If <code>C</code> is a variable concept, then the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  the <cxx-grammarterm><i>id-expression</i></cxx-grammarterm> <code>TT</code>.
  
  If <code>C</code> is a function concept, then the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  the function call <code>TT()</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p para_num="9" id="temp.9" class="quoted">
  When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T1</code>) is
  explicitly declared with <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), 
  its canonical declaration is a 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T2</code>)
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).
  
  The declaration, <code>T2</code>, has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is the
  conjunction of the <cxx-grammarterm><i>constraint-expressoin</i></cxx-grammarterm>s 
  associated by the constrained template parameters in <code>T1</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration <code>T1</code> includes a 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, its
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>T2</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="10" id="temp.10" class="quoted"> 
  When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>. The associated constraints of the
  abbreviated function are evaluated in the order in which they appear.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="11" id="temp.11" class="quoted"> 
  An abbreviated function can also be declared as a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in the
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> and the
  following <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="12" id="temp.12" class="quoted"> 
  A <dfn>trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm></dfn> 
  is a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> that appears after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

  When a constrained function template or member function template is
  declared with a trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  it is equivalent to a declaration in which the 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)</code></pre>
  
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- FIXME: Does this need to go somewhere? Notes refer to it as 
       redundant. -->
  <!--  
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p> 
  -->


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Template parameters">Template parameters</h1> <span style="float:right"><a href="#temp.param">[temp.param]</a></span></header>
      
    

    Modify the <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/1 in order
    to allow constrained template parameters.

    <p para_num="1" id="temp.param.1" number="1" class="quoted">

    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-parameter:
  </bnf-rule>
        <del><bnf-alt>
    
    parameter-declaration
  </bnf-alt></del>
        <ins><bnf-alt>
    
    non-type-or-constrained-parameter
  </bnf-alt></ins>

      <ins>
      <bnf-rule>
    
    non-type-or-constrained-parameter:
  </bnf-rule>
        <bnf-alt>
    
    basic-parameter-declaration
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer
        
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> type-id
        
  </bnf-alt>

        <bnf-alt>
    
    
          basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> id-expression
        
  </bnf-alt>
      </ins>
    
  </bnf-grammar>
    </p>
    
    Update the wording in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/2 as 
    follows.

    <p para_num="2" id="temp.param.2" number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm><i>unqualified-id</i></cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm><i>qualified-id</i></cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm></ins>. 
    </p>

    Insert the following paragraphs after paragraph 3 in order to distinguish
    between a template parameter that declares a non-type parameter and a
    template-parameter that declares a constrained parameter, which may
    declare a type parameter. 

    <p para_num="3" id="temp.param.3" number="3" class="quoted">
    When a <cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm> has
    the following form:
    <bnf-grammar>
    
    
    <bnf-alt>
    
    
    constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt>
    
  </bnf-alt>
    
  </bnf-grammar>
    it declares a <dfn>constrained template parameter</dfn>.

    Otherwise the parameter is a non-type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.
    </p>

    <p para_num="4" id="temp.param.4" class="quoted">
    If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
    appears in the the parameter type of a
    <cxx-grammarterm><i>non-type-or-constrained-parameter</i></cxx-grammarterm>,
    the program is ill-formed. The program is also ill-formed if a
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> appears
    anywhere in the <cxx-grammarterm><i>basic-parameter-declaration</i></cxx-grammarterm> 
    and the form of that declaration does not match the form above.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S1;       // <i>OK:</i> T <i>is a constrained template parameter</i>
template&lt;int N&gt; struct S2;     // <i>OK:</i> N <i>is a non-type template parameter</i>
template&lt;auto X&gt; struct S2;    // <i>error: auto in template parameter</i>
template&lt;const D N&gt; void f1(); // <i>error:</i> D <i>is used with a const-qualifier</i>
template&lt;D* N&gt; void f2();      // <i>error:</i> N <i>declares a pointer-to-</i>D</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.

    <p para_num="9" id="temp.param.9" number="9" class="quoted">
    A constrained template parameter declares a template parameter whose
    type and form match that of the prototype parameter of the concept 
    designated by its <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
    The designated concept is found using the rules in
    <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>. 

    Let <code>I</code> be the <cxx-grammarterm><i>declarator-id</i></cxx-grammarterm>
    of the <cxx-grammarterm><i>basic-parameter-declaration</i></cxx-grammarterm>,
    and let <code>P</code> be the prototype parameter of the designated
    concept. The declared template parameter is determined by the type
    and form of <code>P</code> and the <cxx-grammarterm><i>identifier</i></cxx-grammarterm>
    and optional ellipsis in <code>I</code>.
    </p>
    
    <div class="quoted">
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> declared with
    the <code>class</code> or <code>typename</code>, the declared parameter is 
    a type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. </li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, the declared
    parameter is a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same type as <code>P</code>. </li>

    <li> If <code>P</code> is a template 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, the declared
    parameter is a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
    as <code>P</code>. </li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>I</code> shall include an ellipsis, and the declared parameter
    is a template parameter pack. </li>
    </ul>

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error:</i> Ts <i>must be preceded by an ellipsis</i>
template&lt;C5... Cs&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i></code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    </div>
  
    </section>
  </cxx-section> <!-- temp.param -->


  <!-- ===================================
       Introduction of template parameters
       =================================== -->

  <cxx-section id="temp.intro" number="2">
    

    <section>
      <header><span class="section-number">14.2</span> <h1 data-bookmark-label="14.2 Introduction of template parameters">Introduction of template parameters</h1> <span style="float:right"><a href="#temp.intro">[temp.intro]</a></span></header>
      
    

    Add this section after <cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>.

    <p para_num="1" id="temp.intro.1"> A <dfn>template introduction</dfn> provides a convenient way of declaring
    different templates that have the same template parameters and constraints.

    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-introduction:
  </bnf-rule>
        <bnf-alt>
    
    
          <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt>
          concept-name
          introduction-list
        
  </bnf-alt>

      <bnf-rule>
    
    introduction-list:
  </bnf-rule>
        <bnf-alt>
    
    introduced-parameter
  </bnf-alt>
        <bnf-alt>
    
    introduction-list<bnf-terminal><code>,</code></bnf-terminal> introduced-parameter
  </bnf-alt>

        <bnf-rule>
    
    introduced-parameter:
  </bnf-rule>
          <bnf-alt>
    
    <bnf-opt><bnf-terminal><code>...</code></bnf-terminal><sub>opt</sub></bnf-opt> identifier
  </bnf-alt>
      
    
  </bnf-grammar>

    A template introduction declares a sequence of 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s, which are derived 
    from a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
    and the sequence of <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s in 
    its <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.


    <!-- FIXME: This is grorss... -->
    </p><p para_num="2" id="temp.intro.2"> The concept designated by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
    (call it <code>C</code>) is determined by the 
    <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

    The <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> <code>C</code> 
    refers to a set of concept definitions. A concept <code>CC</code> in
    that set is viable if <code>CC</code> declares at least as many template 
    parameters as there are <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s in 
    the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>, and
    all template parameters in excess of the number of 
    <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s are declared with default 
    template arguments.

    If only one concept in that set is viable, that is the concept
    designated by <code>C</code>. Otherwise, the program is ill-formed.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    It is possible to overload function concepts in such a way that a
    <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> can designate multiple
    concepts.
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i></code></pre>
  
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of</i> C{X} <i>is ambiguous</i></code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="3" id="temp.intro.3">
    For each 
    <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> <code>I</code> in an
    <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>,
    and for its corresponding template parameter in the 
    <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
    of the designated concept (call it <code>P</code>), declare a new template 
    parameter using the rules for declaring a constrained parameter in
    <cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref> by using <code>I</code> as a
    <cxx-grammarterm><i>declarator-id</i></cxx-grammarterm> and <code>P</code>
    as the prototype parameter.

    However, if <code>I</code> contains an ellipsis, <code>P</code> shall
    declare a template parameter pack.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N, typename... Xs&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;

C1{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;    // B <i>is declared as</i> int B
               // C <i>is declared as</i> typename... C

C1{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

C2{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

C2{...X}      // <i>error: the corresponding parameter is not a</i> 
  void bar(); // <i>template parameter pack</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="4" id="temp.intro.4">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    A concept referred to by a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> 
    may have template parameters with default template arguments. An
    <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> may omit 
    <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s for a corresponding template
    parameter if it has a default argument. However, only the
    <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s are declared
    as template parameters. 
    
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename A, typename B = bool&gt; 
  concept bool C() { return true; }

C{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                // <i>a single template type parameter</i> T</code></pre>
  
  There is no <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> 
  that corresponds to the template parameter <code>B</code> in the
  <code>C</code> concept, so <code>f(T)</code> is declared with only
  one template parameter.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    
    <span class="nowrap">— <em>end note</em> ]</span>
  
    <p></p>


    <p para_num="5" id="temp.intro.5"> An introduced template parameter does not have a default template 
    argument, even if its corresponding template parameter does.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="6" id="temp.intro.6"> 
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    The introduction of a sequence of template parameters by a
    <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> associates a constraint 
    with the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
    according to the rules describe in <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

  
    </section>
  </cxx-section> <!-- temp.intro -->


  <!-- =================================
       Names of template specializations
       ================================= -->

  <cxx-section id="temp.names">
    

    <section>
      <header><span class="section-number">14.3</span> <h1 data-bookmark-label="14.3 Names of template specializations">Names of template specializations</h1> <span style="float:right"><a href="#temp.names">[temp.names]</a></span></header>
      
    


    Add the following paragraph to require the implicit instantiation
    of default template arguments for non-function templates.

    <p para_num="8" id="temp.names.8" number="8" class="quoted">
    When a <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> does 
    not name a function, a default 
    <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> is implicitly
    instantiated (<cxx-ref to="temp.inst"><a title="temp.inst" href="#temp.inst">14.7.1</a></cxx-ref>) in a context that 
    requires the value of that default argument.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U = int&gt; struct S { };

S&lt;bool&gt;* p; // <i>the type of</i> p <i>i</i>s S&lt;bool, int&gt;*</code></pre>
  
    The default argument for <code>U</code> is instantiated to form
    the type <code>S&lt;bool, int&gt;*</code>, but the definition of that
    class template specialization is not implicitly instantiated
    (<cxx-ref to="temp.inst"><a title="temp.inst" href="#temp.inst">14.7.1</a></cxx-ref>); it is not used in a 
    context that requires a complete type.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    Add this paragraph to require the satisfaction of associated constraints
    on the formation of the <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm>.

    <p para_num="9" id="temp.names.9" class="quoted">
    When a <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> names
    a constrained class template, variable template or alias template,
    and all <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s in the
    <cxx-grammarterm><i>template-id</i></cxx-grammarterm> are non-dependent,
    (<cxx-ref in="cxx" to="temp.nondep">C++ <span title="temp.nondep">§14.6.2</span></cxx-ref>), the associated constraints
    are checked against those
    <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>). If, as a result of checking,
    the associated constraints are not satisfied, the program is ill-formed.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename C&gt; = false;

template&lt;C T&gt; struct S { };
template&lt; T&gt; using Ptr = T*;

S&lt;int&gt;* p;  // <i>error: constraints not satisfied</i>
Ptr&lt;int&gt; p; // <i>error: constraints not satisfied</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>


  
    </section>
  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    

    <section>
      <header><span class="section-number">14.4</span> <h1 data-bookmark-label="14.4 Template arguments">Template arguments</h1> <span style="float:right"><a href="#temp.arg">[temp.arg]</a></span></header>
      
    

    <cxx-section id="temp.arg.template">
    

    <section>
      <header><span class="section-number">14.4.1</span> <h1 data-bookmark-label="14.4.1 Template template arguments">Template template arguments</h1> <span style="float:right"><a href="#temp.arg.template">[temp.arg.template]</a></span></header>
      
      

      Modify paragraph 3 to include rules for matching constrained template 
      <cxx-grammarterm><i>template parameter</i></cxx-grammarterm>s. Note that the 
      examples following this paragraph in
      the original document are omitted.

      <p para_num="3" id="temp.arg.template.3" number="3" class="quoted">
      A <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> matches 
      a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>P</code><ins>, and <code>P</code> is more constrained than
       <code>A</code> according to the rules in 
       <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref></ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>), and 
      for template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s matches, recursively. 

      When <code>P</code>’s <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <p para_num="3" id="temp.arg.template.3" number="3" class="quoted">
      </p><div class="quoted">
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </div>

    
    </section>
  </cxx-section> <!-- temp.arg.template -->
  
    </section>
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    

    <section>
      <header><span class="section-number">14.5</span> <h1 data-bookmark-label="14.5 Template declarations">Template declarations</h1> <span style="float:right"><a href="#temp.decls">[temp.decls]</a></span></header>
      
    


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
    

    <section>
      <header><span class="section-number">14.5.1</span> <h1 data-bookmark-label="14.5.1 Class templates">Class templates</h1> <span style="float:right"><a href="#temp.class">[temp.class]</a></span></header>
      
      

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. Note that the example
      in the original document is omitted. The example in this paragraph
      is to be added after the omitted example.

      <p para_num="3" id="temp.class.3" number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;C T&gt; void S&lt;T&gt;::f() { }        // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; 
  template&lt;D U&gt; struct S&lt;T&gt;::Inner { }; // <i>OK</i></code></pre>
  
      The declaration of <code>S&lt;T&gt;::g()</code> does not match because
      it does not have the associated constraints of <code>S</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
    

    <section>
      <header><span class="section-number">14.5.1.1</span> <h1 data-bookmark-label="14.5.1.1 Member functions of class templates">Member functions of class templates</h1> <span style="float:right"><a href="#temp.mem.func">[temp.mem.func]</a></span></header>
      
        

        Add the following example to the end of paragraph 1.

        <p para_num="1" id="temp.mem.func.1" number="1" class="quoted">
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g() { }               // <i>error: no matching function in</i> S&lt;T&gt;</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>
      
    </section>
  </cxx-section> <!-- temp.mem.func -->
    
    </section>
  </cxx-section> <!-- temp.class -->

    <!-- ================
         Member templates
         ================ -->

    <cxx-section id="temp.mem">
    

    <section>
      <header><span class="section-number">14.5.2</span> <h1 data-bookmark-label="14.5.2 Member templates">Member templates</h1> <span style="float:right"><a href="#temp.mem">[temp.mem]</a></span></header>
      
      

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. Add the example in this
      document after the example in the original document, which is omitted
      here.

      <p para_num="1" id="temp.mem.1" number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) &lt;= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;C2 U&gt; 
  void S&lt;T&gt;::f(U) { } // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U) { } // <i>error: no matching function in</i> S&lt;T&gt;</code></pre>
  
      The associated constraints in the definition of <code>g()</code> do not
      match those in of its declaration.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ -->

    <cxx-section id="temp.friend" number="4">
    

    <section>
      <header><span class="section-number">14.5.4</span> <h1 data-bookmark-label="14.5.4 Friends">Friends</h1> <span style="float:right"><a href="#temp.friend">[temp.friend]</a></span></header>
      
      


      Add the following paragraphs to explain the meaning of constrained
      friend declarations. 

      <p para_num="10" id="temp.friend.10" number="10" class="quoted">
      A friend function template may be constrained, except:
      </p>
      <div class="quoted">
      <ul>
      <li> if the friend declares, but does not define, a non-template
      function to be a friend of a class template, the associated constraints
      of that friend function declaration shall be non-dependent
      (<cxx-ref in="cxx" to="temp.nondep">C++ <span title="temp.nondep">§14.6.2</span></cxx-ref>); </li>

      <li> if the friend declares a function template specialization to
      be a friend of a class template, the declaration shall not have
      associated constraints, and the template arguments of that specialization
      shall satisfy the associated constraints of the template referred to
      by the friend declaration (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>). </li>
      </ul>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = false;

template&lt;C1 T&gt; g1(T);
template&lt;C2 T&gt; g2(T);

template&lt;typename T&gt;
  struct S {
    void f1() requires true;  // <i>OK</i>
    void f2() requires C1&lt;T&gt;; // <i>error: constraints refer to</i> T
    void g1&lt;T&gt;(T);            // <i>OK</i>
    void g2&lt;T&gt;(T);            // <i>error: constraints not satisfied</i>
  };</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </div>

      <p para_num="11" id="temp.friend.11">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Within a class template, a friend may define a non-template function
      whose constraints specify requirements on template arguments.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool Eq = requires (T t) { t == t; };

template&lt;typename T&gt;
  strut S {
    bool operator==(S a, S b) requires Eq&lt;T&gt; { return a == b; } // OK
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      In the instantiation of such a class template, the template
      arguments are substituted into the constraints but not evaluated.
      Constraints are checked (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) only when
      that function is considered as a viable candidate for overload resolution
      (<cxx-ref to="over.match.viable"><a title="over.match.viable" href="#over.match.viable">13.3.1</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.friend -->



    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
    

    <section>
      <header><span class="section-number">14.5.5</span> <h1 data-bookmark-label="14.5.5 Class template partial specialization">Class template partial specialization</h1> <span style="float:right"><a href="#temp.class.spec">[temp.class.spec]</a></span></header>
      
      

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p para_num="4" id="temp.class.spec.4" number="4" class="quoted">
      A class template partial specialization may be constrained
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool N = N &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      Modify the 3rd item in the list of paragraph 8 to allow 
      constrained class template partial specializations like #6.
      Note that all other items in that list are elided. 

      <p para_num="8" id="temp.class.spec.8" number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      </p><ul>
      <li>...</li>
      <li><ins>In an unconstrained class template partial specialization,</ins>
      <del>The</del><ins>the</ins> argument list of the specialization shall
      not be identical to the implicit argument list of the primary template.
      </li><li>...</li>
      </ul>


      <cxx-section id="temp.class.spec.match">
    

    <section>
      <header><span class="section-number">14.5.5.1</span> <h1 data-bookmark-label="14.5.5.1 Matching of class template partial specializations">Matching of class template partial specializations</h1> <span style="float:right"><a href="#temp.class.spec.match">[temp.class.spec.match]</a></span></header>
      
        

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. Add the example given here
        to the (omitted) example in the original document.

        <p para_num="2" id="temp.class.spec.match.2" number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>
      
    </section>
  </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
    

    <section>
      <header><span class="section-number">14.5.5.2</span> <h1 data-bookmark-label="14.5.5.2 Partial ordering of class template specializations">Partial ordering of class template specializations</h1> <span style="float:right"><a href="#temp.class.order">[temp.class.order]</a></span></header>
      
        

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. Add the
        example at the end of this paragraph to the (omitted) example
        in the original document.

        <p para_num="1" id="temp.class.order.1" number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>):
        </p>
        <div class="quoted">
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;l;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;l;typename T&gt; concept bool D = C&lt;l;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i></code></pre>
  </cxx-codeblock>
        The partial specialization #2 is be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </div>

      
    </section>
  </cxx-section> <!-- temp.class.order -->
    
    </section>
  </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
    

    <section>
      <header><span class="section-number">14.5.6</span> <h1 data-bookmark-label="14.5.6 Function templates">Function templates</h1> <span style="float:right"><a href="#temp.fct">[temp.fct]</a></span></header>
      
      

      <cxx-section id="temp.over.link">
    

    <section>
      <header><span class="section-number">14.5.6.1</span> <h1 data-bookmark-label="14.5.6.1 Function template overloading">Function template overloading</h1> <span style="float:right"><a href="#temp.over.link">[temp.over.link]</a></span></header>
      
        

        Modify paragraph 6 to account for constraints on function
        templates.

        <p para_num="6" id="temp.over.link.6" number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        </p>
        <div class="quoted">
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they are:
        <ul>
        <li> declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints that are equivalent using the rules 
             in <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref> to
             compare <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s.</li>
        </ul>
        </ins>
        </div>

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that <del>one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters</del>
        <ins>
        <ul> 
        <li>one or more expressions that involve template parameters in the 
        return types and parameter lists are functionally equivalent using 
        the rules described above to compare expressions involving template 
        parameters, or if not that, </li>

        <li> both function templates have associated constraints that are
        functionally equivalent but not equivalent, using the rules in 
        <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref> to compare 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s.</li>
        </ul>
        </ins>
        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      
    </section>
  </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
    

    <section>
      <header><span class="section-number">14.5.6.2</span> <h1 data-bookmark-label="14.5.6.2 Partial ordering of function templates">Partial ordering of function templates</h1> <span style="float:right"><a href="#temp.func.order">[temp.func.order]</a></span></header>
      
        

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p para_num="2" id="temp.func.order.2" number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by the rules in
        <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.</ins>
        </p>

      
    </section>
  </cxx-section> <!-- temp.func.order -->

    
    </section>
  </cxx-section> <!-- temp.fct -->

  
    </section>
  </cxx-section> <!-- temp.decls -->


  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    

    <section>
      <header><span class="section-number">14.7</span> <h1 data-bookmark-label="14.7 Template instantiation and specialization">Template instantiation and specialization</h1> <span style="float:right"><a href="#temp.spec">[temp.spec]</a></span></header>
      
    


    <cxx-section id="temp.inst">
    

    <section>
      <header><span class="section-number">14.7.1</span> <h1 data-bookmark-label="14.7.1 Implicit instantiation">Implicit instantiation</h1> <span style="float:right"><a href="#temp.inst">[temp.inst]</a></span></header>
      
      

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p para_num="2" id="temp.inst.2" number="2" class="quoted">
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The evaluation of constraints happens during lookup or overload
      resolution (<cxx-ref to="over"><a title="over" href="#over">13</a></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C<t> &amp;&amp; sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { } // <i>#1</i>
  S() requires D&lt;T&gt; { } // <i>#2</i>
};

S&lt;char&gt; s1;    // <i>error: no matching constructor</i>
S&lt;char[8]&gt; s2; // <i>OK: calls #2</i>

      </t></code></pre>
  
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors, 
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization. This also
      has the effect of suppressing the implicit generation of a default 
      constructor (<cxx-ref in="cxx" to="class.ctor">C++ <span title="class.ctor">§12.1</span></cxx-ref>).

      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; struct S2 {
    void f() requires T::value == 1;
  };

S2&lt;int&gt; s; // <i>error: substitution failure in definition of</i> S2&lt;int&gt;</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.inst -->


    <!-- ======================
         Explicit instantiation
         ====================== -->

    <cxx-section id="temp.explicit">
    

    <section>
      <header><span class="section-number">14.7.2</span> <h1 data-bookmark-label="14.7.2 Explicit instantiation">Explicit instantiation</h1> <span style="float:right"><a href="#temp.explicit">[temp.explicit]</a></span></header>
      
      

      Add the following paragraphs to this section. These require an explicit
      instantiation of a constrained template to satisfy the template's
      associated constraints.

      <p para_num="14" id="temp.explicit.14" number="14" class="quoted">
      If the explicit instantiation names a class template specialization
      or variable template specialization of a constrained template, then
      the <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> in the
      <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of the explicit
      instantiation shall satisfy the template's associated constraints
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template S&lt;char&gt;;    // <i>OK</i>
template S&lt;char[2]&gt;; // <i>error: constraints not satisfied</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <p></p><p para_num="15" id="temp.explicit.15" class="quoted">
      When an explicit instantiation refers to a specialization of a
      function template (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>), that 
      template's associated constraints shall be satisfied by the template 
      arguments of the explicit instantiation.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T) { } // <i>#1</i>
template&lt;typename T&gt; void g(T) { } // <i>#2</i>
template&lt;C T&gt;        void g(T) { } // <i>#3</i>

template void f(int);   // <i>OK: refers to #1</i>
template void f(void*); // <i>error: no matching template</i>
template void g(int);   // <i>OK: refers to #3</i>
template void g(void*); // <i>OK: refers to #2</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.explicit -->


    <!-- =======================
         Explicit specialization
         ======================= -->

    <cxx-section id="temp.expl.spec">
    

    <section>
      <header><span class="section-number">14.7.3</span> <h1 data-bookmark-label="14.7.3 Explicit specialization">Explicit specialization</h1> <span style="float:right"><a href="#temp.expl.spec">[temp.expl.spec]</a></span></header>
      
      

      Insert the following paragraphs after paragraph 12. These require
      an explicit specialization to satisfy the constraints of the primary
      template.

      <p para_num="12" id="temp.expl.spec.12" number="12" class="quoted">
      The <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> in the
      <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of an explicit 
      specialization of a constrained class template or
      constrained variable template shall satisfy the associated constraints
      of that template, if any (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template&lt;&gt; S&lt;char&gt; { };    // <i>OK</i>
template&lt;&gt; S&lt;char[2]&gt; { }; // <i>error: constraints not satisfied</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="13" id="temp.expl.spec.13" class="quoted">
      When determining the function template referred to by an explicit 
      specialization of a function template 
      (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>),
      the associated constraints of that template (if any) shall be satisfied 
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) by the
      template arguments of the explicit specialization.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt;        void f(T); // <i>#1</i>
template&lt;typename T&gt; void g(T); // <i>#2</i>
template&lt;C T&gt;        void g(T); // <i>#3</i>

template&lt;&gt; void f(int);   // <i>OK: refers to #1</i>
template&lt;&gt; void f(void*); // <i>error: no matching template</i>
template&lt;&gt; void g(int);   // <i>OK: refers to #3</i>
template&lt;&gt; void g(void*); // <i>OK: refers to #2</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.expl.spec -->
  
    </section>
  </cxx-section> <!-- temp.spec -->


  <!-- =================================
       Function template specializations
       ================================= -->

  <cxx-section id="temp.fct.spec" number="8">
    

    <section>
      <header><span class="section-number">14.8</span> <h1 data-bookmark-label="14.8 Function template specializations">Function template specializations</h1> <span style="float:right"><a href="#temp.fct.spec">[temp.fct.spec]</a></span></header>
      
    

    <cxx-section id="temp.deduct" number="2">
    

    <section>
      <header><span class="section-number">14.8.2</span> <h1 data-bookmark-label="14.8.2 Template argument deduction">Template argument deduction</h1> <span style="float:right"><a href="#temp.deduct">[temp.deduct]</a></span></header>
      
      

      Add the following sentences to the end of paragraph 5. This defines
      the substitution of template arguments into a function template's
      associated constraints. Note that the last part of paragraph 5
      has been duplicated in order to provide context for the addition.

      <p para_num="5" id="temp.deduct.5" number="5" class="quoted">
      When all template arguments have been deduced or obtained from default 
      template arguments, all uses of template parameters in the template 
      parameter list of the template and the function type are replaced with
      the corresponding deduced or default argument values. 

      If the substitution results in an invalid type, as described above, type 
      deduction fails.

      <ins>
      If the function template has associated constraints
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>),
      the template arguments are substituted into the constraints without 
      evaluating the resulting expression. If this substitution results in an 
      invalid type, then the resulting expression is defined to be 
      <code>false</code>.

      The resulting constraints are associated with the function template
      specialization.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The constraints associated with the function template specialization
      are checked (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) in order to determine 
      if the specialization is a viable candidate 
      (<cxx-ref to="over.match.viable"><a title="over.match.viable" href="#over.match.viable">13.3.1</a></cxx-ref>), and not at the point
      of substitution.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </ins>
      </p>

      <cxx-section id="temp.deduct.decl" number="6">
    

    <section>
      <header><span class="section-number">14.8.2.6</span> <h1 data-bookmark-label="14.8.2.6 Deducing template arguments from a function declaration">Deducing template arguments from a function declaration</h1> <span style="float:right"><a href="#temp.deduct.decl">[temp.deduct.decl]</a></span></header>
      
        

        Add the following after paragraph 1 in order to require the
        satisfaction of constraints when matching a specialization to a
        template.

        <p para_num="2" id="temp.deduct.decl.2" number="2" class="quoted">
        Remove, from the set of function templates considered, all those
        whose associated constraints (if any) are not satisfied by the deduced
        template arguments (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
        </p>

        Update paragraph 2 (now paragraph 3) to accommodate the new
        wording.

        <p para_num="3" id="temp.deduct.decl.3" class="quoted">
        If, 
        <del>for the set of function templates so considered</del>
        <ins>for the remaining function templates</ins>,
        there is either no match or more than one match after partial ordering 
        has been considered (<cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>), deduction fails 
        and, in the declaration cases, the program is ill-formed.
        </p>
      
    </section>
  </cxx-section> <!-- temp.deduct.decl -->

    
    </section>
  </cxx-section> <!-- temp.deduct -->

  
    </section>
  </cxx-section> <!-- temp.fct.spec -->


  <!-- ====================
       Template constraints
       ==================== -->

  <cxx-section id="temp.constr">
    

    <section>
      <header><span class="section-number">14.9</span> <h1 data-bookmark-label="14.9 Template constraints">Template constraints</h1> <span style="float:right"><a href="#temp.constr">[temp.constr]</a></span></header>
      
    

    Add this section after 14.8.

    <p para_num="1" id="temp.constr.1">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    The defines the meaning of constraints on template arguments, including
    the translation of <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s
    into constraints by normalization (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>),
    and the abstract syntax, satisfaction, and subsumption of those constraints
    (<cxx-ref to="temp.constr.op"><a title="temp.constr.op" href="#temp.constr.op">14.9.1</a></cxx-ref>, <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="2" id="temp.constr.2"> A <dfn>constraint</dfn> is a sequence of logical operators and 
    operands that specifies requirements on template arguments. </p>

    <p para_num="3" id="temp.constr.3">
    <dfn>Constraint checking</dfn> is the processing of substituting 
    non-dependent template arguments (<cxx-ref in="cxx" to="temp.nondep">C++ <span title="temp.nondep">§14.6.2</span></cxx-ref>) 
    into a constraint for the purpose of determining if the constraint
    is satisfied.

    After substitution, a constraint is <dfn>satisfied</dfn> if and only if 
    all of its sub-constraints are satisfied according to the evaluation 
    rules described in
    <cxx-ref to="temp.constr.op"><a title="temp.constr.op" href="#temp.constr.op">14.9.1</a></cxx-ref> and
    <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>.

    If the substitution of template arguments into a constraint fails, 
    that constraint is not satisfied.

    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Substitution into a constraint may yield a well-formed constraint that
    contains ill-formed expressions or types. This may happen, for
    example, in the implicit instantiation of a class template
    specialization (<cxx-ref to="temp.inst"><a title="temp.inst" href="#temp.inst">14.7.1</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="4" id="temp.constr.4"> A constraint <code>P</code> is said to <dfn>subsume</dfn> another
    constraint <code>Q</code> if, informally, it can be determine that
    <code>P</code> implies <code>Q</code>, up to the equivalence of
    expressions and types in <code>P</code> and <code>Q</code>.
    
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Subsumption does not determine, for example, if the predicate 
    constraint (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>) 
    <code>N % 2 == 1</code> subsumes <code>N &amp; 1</code> for 
    some integral template argument, <code>N</code>. 
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    The rules defining the subsumption relation are given for each kind
    of constraint in
    <cxx-ref to="temp.constr.op"><a title="temp.constr.op" href="#temp.constr.op">14.9.1</a></cxx-ref> and
    <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>.
    </p>

    <cxx-section id="temp.constr.op">
    

    <section>
      <header><span class="section-number">14.9.1</span> <h1 data-bookmark-label="14.9.1 Logical operators">Logical operators</h1> <span style="float:right"><a href="#temp.constr.op">[temp.constr.op]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.op.1"> There are two logical operators on constraints: conjunction
      and disjunction. </p>


        <!-- ===========
             Conjunction
             =========== -->

        <cxx-section id="temp.constr.op.conj">
    

    <section>
      <header><span class="section-number">14.9.1.1</span> <h1 data-bookmark-label="14.9.1.1 Conjunction">Conjunction</h1> <span style="float:right"><a href="#temp.constr.op.conj">[temp.constr.op.conj]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.op.conj.1"> A <dfn>conjunction</dfn> is a logical operator taking two 
          operands. A conjunction of constraints is satisfied if and only 
          if both operands are satisfied. </p>

          <p para_num="2" id="temp.constr.op.conj.2"> A conjunction of the constraints <code>P</code> 
          and <code>Q</code> subsumes another constraint <code>R</code>
          if and only if <code>P</code> subsumes <code>R</code>,
          <code>Q</code> subsumes <code>R</code>, or both subsume
          <code>R</code>.
          </p>
        
    </section>
  </cxx-section> <!-- temp.constr.op.conj -->


        <!-- ===========
             Disjunction
             =========== -->

        <cxx-section id="temp.constr.op.disj">
    

    <section>
      <header><span class="section-number">14.9.1.2</span> <h1 data-bookmark-label="14.9.1.2 Disjunction">Disjunction</h1> <span style="float:right"><a href="#temp.constr.op.disj">[temp.constr.op.disj]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.op.disj.1"> A <dfn>disjunction</dfn> is a logical operator taking two 
          operands. A disjunction of constraints is satisfied if and only 
          if either operand is satisfied or both operands are satisfied. </p>

          <p para_num="2" id="temp.constr.op.disj.2"> A disjunction of the constraints <code>P</code> and <code>Q</code>
          subsumes another constraint <code>R</code> if and only if
          <code>P</code> subsumes <code>R</code> and <code>Q</code> subsumes
          <code>R</code>.
          </p>
        
    </section>
  </cxx-section> <!-- temp.constr.op.disj -->

      
    </section>
  </cxx-section> <!-- temp.constr.op -->

      <!-- =================
          Atomic constraints
          ================== -->

      <cxx-section id="temp.constr.atom">
    

    <section>
      <header><span class="section-number">14.9.2</span> <h1 data-bookmark-label="14.9.2 Atomic constraints">Atomic constraints</h1> <span style="float:right"><a href="#temp.constr.atom">[temp.constr.atom]</a></span></header>
      
        

        <p para_num="1" id="temp.constr.atom.1"> Any constraint that is not a conjunction or disjunction is an
        <dfn>atomic constraint</dfn>. </p>

        <p para_num="2" id="temp.constr.atom.2"> An atomic constraint <code>P</code> subsumes a disjunction
        of the constraints <code>Q</code> and <code>R</code> if and only
        if <code>P</code> subsumes <code>Q</code>, <code>P</code>
        subsumes <code>R</code>, or both. </p>

        <p para_num="3" id="temp.constr.atom.3"> An atomic constraint <code>P</code> subsumes a conjunction
        of the constraints <code>Q</code> and <code>R</code> if and only
        if <code>P</code> subsumes <code>Q</code> and <code>P</code>
        subsumes <code>R</code>.</p>

        <!-- =====================
             Predicate constraints
             ===================== -->

        <cxx-section id="temp.constr.atom.pred">
    

    <section>
      <header><span class="section-number">14.9.2.1</span> <h1 data-bookmark-label="14.9.2.1 Predicate constraints">Predicate constraints</h1> <span style="float:right"><a href="#temp.constr.atom.pred">[temp.constr.atom.pred]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.pred.1"> A <dfn>predicate constraint</dfn> is an atomic constraint
          that evaluates a prvalue constant expression of type <code>bool</code>
          (<cxx-ref in="cxx" to="expr.const">C++ <span title="expr.const">§5.19</span></cxx-ref>).
          The constraint is satisfied if and only if the expression 
          evaluates to <code>true</code>.
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Predicate constraints allow the definition of template requirements
          in terms of constant expressions. This enables constraints on non-type
          arguments, template template arguments, and also the definition of
          constraints as metaprograms on template arguments.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 4 &amp;&amp; !true;</code></pre>
  
          Here, <code>sizeof(T) == 4</code> and <code>!true</code> are 
          predicate constraints required by the concept, <code>C</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.pred.2">A predicate constraint <code>P</code> subsumes another
          predicate constraint <code>Q</code> if and only if
          <code>P</code> and <code>Q</code> are equivalent
          <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s
          (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The predicate <code>M &gt;= 0</code> does not subsume the predicate
          <code>M &gt; 0</code> because they are not equivalent
          <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
          </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.pred -->


        <!-- ======================
             Expression constraints
             ====================== -->

        <cxx-section id="temp.constr.atom.expr">
    

    <section>
      <header><span class="section-number">14.9.2.2</span> <h1 data-bookmark-label="14.9.2.2 Expression constraints">Expression constraints</h1> <span style="float:right"><a href="#temp.constr.atom.expr">[temp.constr.atom.expr]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.expr.1"> An <dfn>expression constraint</dfn> is an atomic constraint
          that specifies a requirement on the formation of an
          <cxx-grammarterm><i>expression</i></cxx-grammarterm> (call it <code>E</code>)
          through substitution of template arguments.

          An expression constraint is satisfied if <code>E</code> is non-dependent, 
          meaning that the substitution yielding <code>E</code> did not fail. 
          Within an expression constraint, <code>E</code> is an unevaluated 
          operand (<cxx-ref to="expr"><a title="expr" href="#expr">5</a></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          An expression constraint is introduced by the 
          <cxx-grammarterm><i>expression</i></cxx-grammarterm> in either a
          <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> 
          (<cxx-ref to="expr.prim.req.simple"><a title="expr.prim.req.simple" href="#expr.prim.req.simple">5.1.3.1</a></cxx-ref>)
          or
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>)
          of a
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The concept <code>C</code> introduces an expression constraint for 
          the expression <code>++t</code>.
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };</code></pre>
  
          The type argument <code>int</code> satisfies this constraint because the
          the expression <code>++t</code> is valid after substituting <code>int</code>
          for <code>T</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.expr.2"> An expression constraint <code>P</code> subsumes another
          expression constraint <code>Q</code> if and only if
          the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.expr -->


        <!-- ================
             Type constraints
             ================ -->

        <cxx-section id="temp.constr.atom.type">
    

    <section>
      <header><span class="section-number">14.9.2.3</span> <h1 data-bookmark-label="14.9.2.3 Type constraints">Type constraints</h1> <span style="float:right"><a href="#temp.constr.atom.type">[temp.constr.atom.type]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.type.1"> A <dfn>type constraint</dfn> is an atomic constraint that
          specifies a requirement on the formation 
          of a type (call it <code>T</code>) through the substitution of
          template arguments

          A type constraint is satisfied if and only 
          <code>T</code> is non-dependent, meaning that the substitution 
          yielding <code>T</code> did not fail.

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          A type constraint is introduced by the 
          <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> of a
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.type"><a title="expr.prim.req.type" href="#expr.prim.req.type">5.1.3.2</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example example="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The concept <code>C</code> introduces a type constraint for the 
          type name <code>T::type</code>.
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = 
requires (T t) { 
  typename T::type;
};</code></pre>
  
          The type <code>int</code> does not satisfies this constraint 
          because substitution of that type into the constraint results in a
          substitution failure; <code>int::type</code> is ill-formed.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.type.2"> A type requirement that names a class template specialization 
          does not require that type to be complete 
          (<cxx-ref in="cxx" to="basic.types">C++ <span title="basic.types">§3.9</span></cxx-ref>). </p>

          <p para_num="3" id="temp.constr.atom.type.3"> A type requirement <code>P</code> subsumes another type
          requirement <code>Q</code> if and only if the types in <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref in="cxx" to="temp.type">C++ <span title="temp.type">§14.4</span></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.type -->


        <!-- ===============================
             Implicit conversion constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.conv">
    

    <section>
      <header><span class="section-number">14.9.2.4</span> <h1 data-bookmark-label="14.9.2.4 Implicit conversion constraints">Implicit conversion constraints</h1> <span style="float:right"><a href="#temp.constr.atom.conv">[temp.constr.atom.conv]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.conv.1"> A <dfn>implicit conversion constraint</dfn> is an atomic
          constraint that specifies a requirement 
          on the implicit conversion of an 
          <cxx-grammarterm><i>expression</i></cxx-grammarterm>
          (call it <code>E</code>) to a 
          type (call it <code>T</code>). The constraint is satisfied if and 
          only if <code>E</code> is implicitly convertible to <code>T</code>
          (<cxx-ref in="cxx" to="conv">C++ <span title="conv">§4</span></cxx-ref>).
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          A conversion constraint is introduced by a
          <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> when
          its type contains no placeholders
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = 
requires (T a, T b) {
  { a == b } -&gt; bool;
};</code></pre>
  
          The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in the
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> of <code>C</code>
          introduces two atomic constraints: an expression constraint
          for <code>a == b</code> and the implicit conversion constraint that 
          the expression <code>a == b</code> is implicitly convertible to
          <code>bool</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          T1 is convertible to T2. -->

          <p para_num="2" id="temp.constr.atom.conv.2"> An implicit conversion constraint <code>P</code> subsumes 
          another implicit conversion constraint <code>Q</code> if and only if
          the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of 
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>) and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type">C++ <span title="temp.type">§14.4</span></cxx-ref>).</p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.conv -->


        <!-- ==============================
             Argument deduction constraints
             ============================== -->

        <cxx-section id="temp.constr.atom.deduct">
    

    <section>
      <header><span class="section-number">14.9.2.5</span> <h1 data-bookmark-label="14.9.2.5 Argument deduction constraints">Argument deduction constraints</h1> <span style="float:right"><a href="#temp.constr.atom.deduct">[temp.constr.atom.deduct]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.deduct.1"> An <dfn>argument deduction constraint</dfn> is an atomic
          constraint that specifies a requirement on 
          the usability of an <cxx-grammarterm><i>expression</i></cxx-grammarterm> 
          (call it <code>E</code>) as an argument to an invented 
          function template (call it <code>F</code>) that has a single 
          parameter whose type (call it <code>T</code>) is
          written in terms of <code>F</code>'s template parameters.

          The constraint is satisfied if and only if <code>F</code>
          is selected by overload resolution for the call <code>F(E)</code>
          (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Overload resolution selects <code>F</code> only when template 
          argument deduction succeeds and <code>F</code>'s associated 
          constraints are satisfied.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          An argument deduction constraint is introduced by a
          <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> when the
          <cxx-grammarterm><i>trailing-type-specifier-seq</i></cxx-grammarterm>
          contains at least one placeholder
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The concept <code>D</code> introduces an argument deduction 
          constraint for the expression <code>*t</code>.
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { ++t; }
template&lt;typename T&gt; concept bool D = requires (T t) { *t -&gt; const C&amp;; }</code></pre>
  
          When determining if <code>D</code> is satisfied, overload resolution
          is performed for the call <code>g(*t)</code> against the following 
          invented function:
          <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; requires C&lt;T&gt; void g(const T&amp;);</code></pre>
  </cxx-codeblock>
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          f(T1) is more specialized than f(T2) where f is the corresponding
          invented function template. -->

          <p para_num="2" id="temp.constr.atom.deduct.2"> An argument deduction constraint <code>P</code> subsumes
          another argument deduction constraint <code>Q</code> if and only
          if the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>), and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type">C++ <span title="temp.type">§14.4</span></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.deduct -->


        <!-- ===============================
             Constant expression constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.constexpr">
    

    <section>
      <header><span class="section-number">14.9.2.6</span> <h1 data-bookmark-label="14.9.2.6 Constant expression constraints">Constant expression constraints</h1> <span style="float:right"><a href="#temp.constr.atom.constexpr">[temp.constr.atom.constexpr]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.constexpr.1"> A <dfn>constant expression constraint</dfn> is an atomic
          constraint that specifies a requirement that
          an <cxx-grammarterm><i>expression</i></cxx-grammarterm> (call it <code>E</code>) 
          can be evaluated during translation. The constraint is satisfied if 
          and only if <code>E</code> is a prvalue constant expression 
          (<cxx-ref in="cxx" to="expr.const">C++ <span title="expr.const">§5.19</span></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          A constant expression constraint determines if an expression can be
          evaluated during translation for specific <code>constexpr</code>
          arguments. It cannot be used to determine if an expression is
          evaluated during translation for all possible arguments.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Constant expression constraints are introduced by a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> that
          includes the <code>constexpr</code> specifier
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; concept bool C = 
requires() {
  constexpr { T(N) }; // <i>determines if</i> T(N) <i>is a constant expression</i>
};</code></pre>
  
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.constexpr.2"> A constant expression constraint <code>P</code> subsumes
          another constant expression constraint <code>Q</code> if and
          only if the expressions of <code>P</code> and <code>Q</code>
          are equivalent (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>). </p>
        
        
    </section>
  </cxx-section> <!-- temp.constr.atom.constexpr -->


        <!-- ===============================
             Exception constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.noexcept">
    

    <section>
      <header><span class="section-number">14.9.2.7</span> <h1 data-bookmark-label="14.9.2.7 Exception constraints">Exception constraints</h1> <span style="float:right"><a href="#temp.constr.atom.noexcept">[temp.constr.atom.noexcept]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.noexcept.1"> An <dfn>exception constraint</dfn> is an atomic constraint
          that specifies a requirement that an
          <cxx-grammarterm><i>expression</i></cxx-grammarterm> 
          (call it <code>E</code>) does not throw an exception.
          It is satisfied if and only if the expression 
          <code>noexcept(E)</code>
          is <code>true</code>
          (<cxx-ref in="cxx" to="expr.unary.noexcept">C++ <span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>).
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Constant expression constraints are introduced by a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> that
          includes the <code>noexcept</code> specifier
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
          </p>

          <p para_num="2" id="temp.constr.atom.noexcept.2"> An exception constraint <code>P</code> subsumes another
          exception constraint <code>Q</code> if and only if the
          <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.noexcept -->

    
    </section>
  </cxx-section> <!-- temp.constr.atom -->


    <!-- ===============================
         Partial ordering of constraints
         =============================== -->

    <cxx-section id="temp.constr.order">
    

    <section>
      <header><span class="section-number">14.9.3</span> <h1 data-bookmark-label="14.9.3 Partial ordering by constraints">Partial ordering by constraints</h1> <span style="float:right"><a href="#temp.constr.order">[temp.constr.order]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.order.1">The subsumption relation defines a partial ordering on constraints. 
      This partial ordering is used to determine </p>

      <ul>
      <li> the best viable candidate of non-template functions
           (<cxx-ref to="over.match.best"><a title="over.match.best" href="#over.match.best">13.3.2</a></cxx-ref>), </li>
      <li> the address of a non-template function
           (<cxx-ref to="over.over"><a title="over.over" href="#over.over">13.4</a></cxx-ref>), </li>
      <li> the matching of template template arguments
           (<cxx-ref to="temp.arg.template"><a title="temp.arg.template" href="#temp.arg.template">14.4.1</a></cxx-ref>).</li>
      <li> the partial ordering of class template specializations
           (<cxx-ref to="temp.class.order"><a title="temp.class.order" href="#temp.class.order">14.5.5.2</a></cxx-ref>), </li>
      <li> the partial ordering of function templates
           (<cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>), and </li>
      </ul>

      <p para_num="2" id="temp.constr.order.2"> When two declarations <code>D1</code> and <code>D2</code> are
      partially ordered by their constraints, <code>D1</code> is more
      constrained than <code>D2</code> if

      </p><ul>
      <li> <code>D1</code> and <code>D2</code> are both constrained
      declarations and <code>D1</code>'s associated constraints subsume but 
      are not subsumed by those of <code>D2</code>, or if not that, </li>

      <li> <code>D1</code> is constrained and <code>D2</code> is
      unconstrained. </li>
      </ul>

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = requires(T t) { ++t; };
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt; &amp;&amp; requires(T t) { *t; };

template&lt;C1 T&gt; void f(T);       // <i>#1</i>
template&lt;C2 T&gt; void f(T);       // <i>#2</i>
template&lt;typename T&gt; void g(T); // <i>#3</i>
template&lt;C1 T&gt; void g();        // <i>#4</i>

f(0);       // <i>selects #1</i>
f((int*)0); // <i>selects #2</i>
g(true);    // <i>selects #3 because</i> C1&lt;bool&gt; <i>is not satisfied</i>
g(0);       // <i>selects #4</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

    
    </section>
  </cxx-section> <!-- temp.constr.order -->



    <!-- ======================
         Constraint expressions
         ====================== -->

    <cxx-section id="temp.constr.expr">
    

    <section>
      <header><span class="section-number">14.9.4</span> <h1 data-bookmark-label="14.9.4 Constraint expressions">Constraint expressions</h1> <span style="float:right"><a href="#temp.constr.expr">[temp.constr.expr]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.expr.1">Certain contexts require expressions that can be transformed
      into constraints through the process of normalization.
      <bnf-grammar>
    
    
        <bnf-rule>
    
    constraint-expression:
  </bnf-rule>
          <bnf-alt>
    
    logical-or-expression
  </bnf-alt>
      
  </bnf-grammar>
      </p>

      <p para_num="2" id="temp.constr.expr.2"> A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      <code>E</code> is <dfn>normalized</dfn> by forming a constraint 
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) from
      <code>E</code> and its subexpressions.
      
      That transformation is defined as follows:

      </p><ul>
      <li> The normalization of an expression of the form <code>(P)</code> is
      the normalization of <code>P</code>.</li>

      <li> The normalization of an expression of the form <code>P || Q</code> is
      the disjunction of the normalization of <code>P</code> and the
      normalization of <code>Q</code>. 

      If, in the expression <code>P || Q</code>, lookup of <code>operator||</code> 
      finds a user-defined function, the program is ill-formed.</li>

      <li> The normalization of an expression of the form <code>P &amp;&amp; Q</code> is
      the conjunction of the normalization of <code>P</code> and the
      normalization of <code>Q</code>. 

      If, in the expression <code>P &amp;&amp; Q</code>, lookup of
      <code>operator&amp;&amp;</code> finds a user-defined function, the 
      program is ill-formed.</li>

      <li> The normalization of a function call of the form
      <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;()</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a function
      concept (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) is defined as follows:

      Let <code>E</code> be the expression returned by the function concept 
      <code>C</code>, and let <code>S</code> be the result of substituting the
      template arguments into that expression. The resulting constraint is
      the normalization of <code>S</code>.</li>

      <li> The normalization of a <cxx-grammarterm><i>id-expression</i></cxx-grammarterm>
      of the form <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a variable
      concept (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) is defined as follows:

      Let <code>E</code> be the initializer of the variable concept
      <code>C</code>, and let <code>S</code> be the result of substituting the
      template arguments into that expression. The resulting constraint is
      the normalization of <code>S</code>.</li>

      <li> The normalization of a 
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> is 
      defined to be the conjunction of constraints introduced by
      the body of that expression (<cxx-ref to="expr.prim.req"><a title="expr.prim.req" href="#expr.prim.req">5.1.3</a></cxx-ref>).
      </li>

      <li> Otherwise, <code>E</code> shall be a prvalue constant
      expression of type <code>bool</code>, and it denotes a
      predicate constraint (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>).
      </li>
      </ul>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
      defines a subset of constant expressions over which certain 
      logical implications can be deduced during translation.

      The prohibition against user-defined logical operators in intended to
      prevent the subversion of the underlying logic necessary partially
      order constraints (<cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1() { return sizeof(T) == 1; }
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt;() &amp;&amp; 1 == 2; }
template&lt;typename T&gt; concept bool C3 = requires () { typename T::type; };

// <i>Expression</i>      // <i>Constraints</i>
C2&lt;char&gt;           sizeof(char) == 1 /* <i>and</i> */ 1 == 2
C3&lt;int&gt;            /* <i>type constraint for</i> int::type */
3 + 4              // <i>error: not a constraint</i>
(bool)(3 + 4)      (bool)(3 + 4)</code></pre>
  </cxx-codeblock>
      In the normalized constraints, the expressions <code>sizeof(char) == 1</code>, 
      <code>1 == 2</code>, and <code>(bool)(3 + 4)</code> are predicate 
      constraints (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>). 

      The concept <code>C4</code> is normalized to a single type constraint
      (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) for the (ill-formed) 
      type <code>int::type</code>.

      The expression <code>3 + 4</code> is not a 
      <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> because it does
      not satisfy the requirements for being normalized into a predicate 
      constraint.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>


      <!-- TODO: What about constraint expressions that refer to local
      parameters of the same type? It's okay to say no. -->

      <p para_num="3" id="temp.constr.expr.3"> Two <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s are 
      considered equivalent if two function definitions containing the 
      expressions would satisfy the one definition rule 
      (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>), except that
      the tokens used to name template parameters may differ as long as a 
      token used to name a template parameter in one expression is replaced by 
      another token that names the same template parameter in the other 
      expression, and the tokens used to name names of other entities may 
      differ only if those names refer to the same set of declarations.
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;typename T&gt; requires C&lt;T&gt; void f(); // <i>#1</i>
template&lt;typename U&gt; requires C&lt;U&gt; void f(); // <i>OK: redeclaration of #1</i>

namespace N1 { template&lt;typename T&gt; concept bool C1 = true; }
namespace N2 { template&lt;typename T&gt; concept bool C2 = true; }

template&lt;typename T&gt; requires N1::C1&lt;T&gt; void g(); // #2
template&lt;typename T&gt; requires N1::C1&lt;T&gt; void h(); // #3
using N1::C1;
template&lt;typename T&gt; requires C1&lt;T&gt; void g();     // <i>OK: redeclaration of #2</i>
using namespace N2;
template&lt;typename T&gt; requires C2&lt;T&gt; void h();     // <i>OK: redeclaration of #3</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      Two <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm> that are not 
      equivalent are functionally equivalent if, for any given set of template 
      arguments, the satisfaction of their normalized constraints yields the
      same result.

      A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> or
      subexpression thereof of the form <code>(E)</code> is not equivalent to
      <code>E</code>, but the two expressions are functionally equivalent. <p></p>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>void f() requires true || 1 == 2;   // <i>#1</i>
void f() requires true || (1 == 2); // <i>not equivalent but functionally equivalent</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    
    </section>
  </cxx-section> <!-- temp.constr.expr -->

  
    </section>
  </cxx-section> <!-- temp.constr -->


    </section>
  </cxx-clause> <!-- temp -->








</body></html>