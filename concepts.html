<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concepts-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-EDNOTE");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-NOTE");document.createElement("CXX-GRAMMARTERM");document.createElement("BNF-GRAMMAR");document.createElement("BNF-RULE");document.createElement("BNF-ALT");document.createElement("CXX-GRAMMARTER");document.createElement("CXX-EXAMPLE");document.createElement("CXX-CODEBLOCK");document.createElement("BNF-TERMINAL");document.createElement("BNF-OPT");document.createElement("CXX-GRAMARTERM");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

@media print {
cxx-titlepage {
	height: 8.8in;
}


}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  
  <style>
del.local {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}
del.local > * {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}

ins.local {
  color: Black;
  text-decoration: underline;
  background-color: LightSteelBlue; 
}
ins.local > * {
  color: Black;
  text-decoration: under;
  background-color: LightSteelBlue; 
}

p.quoted {
  margin-left: .25in;
}
</style>
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 10pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: string(current-section, last); font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {height: 100%}
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>C++ Extensions for Concepts, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>NXXX</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-07-15</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4040.pdf">N4040</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Andrew Sutton<br>
    University of Akron<br>
    <cxx-email><a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, C++ Extensions for Concepts</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#intro">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#intro.refs">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#intro.defns">Terms and definitions</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#intro.compliance">Implementation compliance</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#intro.ack">Acknowledgments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#lex">Lexical conventions</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#lex.key">Keywords</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#expr">Expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#expr.prim">Primary expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.2</span><a href="#expr.prim.lambda">Lambda expressions</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#expr.req">Requires expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.3.1</span><a href="#expr.req.simple">Simple requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.2</span><a href="#expr.req.type">Type requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.3</span><a href="#expr.req.nested">Nested requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.4</span><a href="#expr.req.compound">Compound requirements</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#dcl.dcl">Declarations</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#dcl.spec">Specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6</span><a href="#dcl.type">Type specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6.2</span><a href="#dcl.type.simple">Simple type specifiers</a>
        
      </li>
            
              <li><span class="marker">7.1.6.4</span><a href="#dcl.spec.auto">auto specifier</a>
        
      </li>
            
              <li><span class="marker">7.1.6.5</span><a href="#dcl.spec.constr">Constrained type specifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.1.7</span><a href="#dcl.spec.concept">concept specifier</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#dcl.decl">Declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3</span><a href="#dcl.meaning">Meaning of declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3.5</span><a href="#dcl.fct">Functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.4</span><a href="#dcl.fct.def">Function definitions</a>
        
          <ol>
            
              <li><span class="marker">8.4.1</span><a href="#dcl.fct.def.general">In general</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9</span><a href="#class">Classes</a>
        
          <ol>
            
              <li><span class="marker">9.2</span><a href="#class.mem">Class members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#temp">Templates</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#temp.param">Template parameters</a>
        
      </li>
            
              <li><span class="marker">14.2</span><a href="#temp.names">Template names</a>
        
      </li>
            
              <li><span class="marker">14.3</span><a href="#temp.arg">Template arguments</a>
        
          <ol>
            
              <li><span class="marker">14.3.1</span><a href="#temp.arg.template">Template template arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5</span><a href="#temp.decls">Template declarations</a>
        
          <ol>
            
              <li><span class="marker">14.5.1</span><a href="#temp.class">Class templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.1.1</span><a href="#temp.mem.func">Member functions of class templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.2</span><a href="#temp.mem">Member templates</a>
        
      </li>
            
              <li><span class="marker">14.5.4</span><a href="#temp.friend">Friends</a>
        
      </li>
            
              <li><span class="marker">14.5.5</span><a href="#temp.class.spec">Class template partial specialization</a>
        
          <ol>
            
              <li><span class="marker">14.5.5.1</span><a href="#temp.class.spec.match">Matching of class template partial specializations</a>
        
      </li>
            
              <li><span class="marker">14.5.5.2</span><a href="#temp.class.order">Partial ordering of class template specializations</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.6</span><a href="#temp.fct">Function templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.6.1</span><a href="#temp.over.link">Function template overloading</a>
        
      </li>
            
              <li><span class="marker">14.5.6.2</span><a href="#temp.func.order">Partial ordering of function templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.7</span><a href="#temp.spec">Template instantiation and specialization</a>
        
          <ol>
            
              <li><span class="marker">14.7.1</span><a href="#temp.inst">Implicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.2</span><a href="#temp.explicit">Explicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.3</span><a href="#temp.expl.spec">Explicit specialization</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.8</span><a href="#temp.fct.spec">Function template specialization</a>
        
          <ol>
            
              <li><span class="marker">14.8.2</span><a href="#temp.deduct">Template argument deduction</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9</span><a href="#temp.constr">Template constraints</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="intro">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#intro">[intro]</a></span></header>
      
  


  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++ 
    Programming language (<cxx-ref to="intro.refs"><a title="intro.refs" href="#intro.refs">1.2</a></cxx-ref>) that
    enable the specification and checking of constraints on template 
    arguments, and the ability to overload functions and specialize
    templates based on those constraints. These extensions include 
    new syntactic forms and modifications to existing language semantics.</p>

    <p para_num="2" id="general.scope.2">International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document as 
    written as a set of changes against that specification. Instructions
    to modify or add paragraphs are written as explicit instructions. 
    Modifications made directly to existing text from the International
    Standard use <ins>underlining</ins> to represent added text and
    <del>strikethrough</del> to represent deleted text.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.refs">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#intro.refs">[intro.refs]</a></span></header>
      
    

    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> The TS will formally refer to the ISO/IEC document
    defining the C++14 programming language. Until that document is
    published, the paper targets the current working draft
    NXXX</aside>
  </cxx-ednote>

    <p para_num="1" id="intro.refs.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC 1482:2014, <cite>Programming Languages - C++</cite>
      </li>
    </ul>

    <p para_num="2" id="intro.refs.2">ISO/IEC 1482:2014 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++
    §3.2".</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.defns">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Terms and definitions">Terms and definitions</h1> <span style="float:right"><a href="#intro.defns">[intro.defns]</a></span></header>
      
    

    <p para_num="1" id="intro.defns.1">For the purposes of this document, the terms and definitions
    given in the C++ Standard and the following apply.</p>

    <dl is="cxx-definition-section">
    

    
<!-- FIXME: Formatting for multiple definitions is broken. 

      <dt id="atomic.defns.atomic-constraint">atomic constraint</dt>
      <dd> A subexpression of a constraint that is not a 
      <cxx-grammarterm>logical-and-expression</cxx-grammarterm>,
      <cxx-grammarterm>logical-or-expression</cxx-grammarterm>,
      or a subexpression of an atomic constraint. </dd>

      <dt id="atomic.defns.associated-constraint">associated constraint</dt>
      <dd>A conjunction of all constraints on a constrained template 
        declaration that includes constraints on template parameters, 
        constraints on function parameters, and constraints specified 
        explicitly in a <cxx-grammarterm>requires-clause</cxx-grammarterm>.</dd>
 
      <dt id="atomic.defns.concept">concept</dt>
      <dd>A template declared with the <code>concept</code> declaration 
      specifier.</dd>

      <dt id="atomic.defns.concept-check">concept check</dt>
      <dd>A call to a function concept or a 
      <cxx-grammarterm>template-id</cxx-grammarterm> that names a variable 
      concept.</dd>

      <dt id="atomic.defns.constraint">constraint</dt>
      <dd>A constant expression with type <code>bool</code> that evaluates 
      properties of template arguments, determining whether or not they 
      can be substituted into a template.</dd>

      <dt id="atomic.defns.constrained-declaration">constrained-declaration</dt>
      <dd>A declaration with associated constraints.</dd>

      <dt id="atomic.defns.generic-function">generic function</dt>
      <dd>A constant expression that evaluates requirements of a template 
      argument.</dd>

      <dt id="atomic.defns.introdduced-parameters">introduced parameters</dt>
      <dd>A function declaration having <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name<cxx-grammarterm> in the type 
      specifier any of its parameters.</dd>
 -->
    
  </dl>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.compliance">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Implementation compliance">Implementation compliance</h1> <span style="float:right"><a href="#intro.compliance">[intro.compliance]</a></span></header>
      
    
    <p para_num="1" id="intro.compliance.1">Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance">C++ <span title="intro.compliance">§1.4</span></cxx-ref>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Conformance is defined in terms of the behavior of
    programs.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.ack">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Acknowledgments">Acknowledgments</h1> <span style="float:right"><a href="#intro.ack">[intro.ack]</a></span></header>
      
    
  
    <p para_num="1" id="intro.ack.1">The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ standard library, known 
    as ``The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p para_num="2" id="intro.ack.2">This work was funded by NSF grant ACI-1148461.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>


<cxx-clause id="lex">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Lexical conventions">Lexical conventions</h1> <span style="float:right"><a href="#lex">[lex]</a></span></header>
      
  

  <cxx-section id="lex.key" <="" cxx-section="">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Keywords">Keywords</h1> <span style="float:right"><a href="#lex.key">[lex.key]</a></span></header>
      
    

    <p para_num="1" id="lex.key.1">In <cxx-ref in="cxx" to="lex.key">C++ <span title="lex.key">§2.12</span></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.</p>

  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="expr" number="5">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Expressions">Expressions</h1> <span style="float:right"><a href="#expr">[expr]</a></span></header>
      
  

  <cxx-section id="expr.prim">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Primary expressions">Primary expressions</h1> <span style="float:right"><a href="#expr.prim">[expr.prim]</a></span></header>
      
    

    <p para_num="1" id="expr.prim.1">In <cxx-ref in="cxx" to="expr.prim.general">C++ <span title="expr.prim.general">§5.1.1</span></cxx-ref>, add
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> to the
    rule, <cxx-grammarterm><i>primary-expression</i></cxx-grammarterm>.</p>
    
    <bnf-grammar>
    
    
      <bnf-rule>
    
    primary-expression:
  </bnf-rule>
        <ins><bnf-alt>
    
    requires-expression
  </bnf-alt></ins>
    
  </bnf-grammar>

    <cxx-section id="expr.prim.lambda" number="2">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Lambda expressions">Lambda expressions</h1> <span style="float:right"><a href="#expr.prim.lambda">[expr.prim.lambda]</a></span></header>
      
      

      Modify <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5.

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      The closure type 
      <del>for a non-generic</del>
      <ins>for a</ins>
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call">C++ <span title="over.call">§13.5.4</span></cxx-ref>)
      whose parameters and return type are described by the lambda-expression’s 
      parameter-declaration-clause and trailing-return-type respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"><a title="temp.mem" href="#temp.mem">14.5.2</a></cxx-ref>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarter>template-parameter</cxx-grammarter> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration declares</i></cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      If the <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> is a
      generic lambda, the closure type's function call operator is an
      abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </ins>
      </p>

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5.

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      <ins>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      Consider the following:
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>template&lt;typename T&gt; concept bool C = true;

auto gl = [](C&amp; a, C* b) { a = *b } // <i>OK: denotes a generic lambda</i>

struct Fun {
    auto operator()(C&amp; a, C* b) const { a = *b; }
} fun;</code></pre>
  
      <code>C</code> is a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda, <code>gl</code>, 
      and the function object, <code>fun</code>, have equivalent behavior when 
      called with the same arguments.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      
      <p></p>

    
    </section>
  </cxx-section> <!-- expr.prim.lambda -->


  <cxx-section id="expr.req">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Requires expressions">Requires expressions</h1> <span style="float:right"><a href="#expr.req">[expr.req]</a></span></header>
      
    

    <p para_num="1" id="expr.req.1">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    requires-expression:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> 
          requirement-parameter-list requirement-body
  </bnf-alt>

    <bnf-rule>
    
    requirement-parameter-list:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>(</code></bnf-terminal> 
        <bnf-opt>parameter-declaration-clause<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>)</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-body:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>{</code></bnf-terminal> 
        requirement-list 
        <bnf-terminal><code>}</code></bnf-terminal> 
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-list:
  </bnf-rule>
      <bnf-alt>
    
    requirement
  </bnf-alt>
      <bnf-alt>
    
    requirement-list requirement
  </bnf-alt>

    <bnf-rule>
    
    requirement:
  </bnf-rule>
      <bnf-alt>
    
    simple-requirement
  </bnf-alt>
      <bnf-alt>
    
    compound-requirement
  </bnf-alt>
      <bnf-alt>
    
    type-requirement
  </bnf-alt>
      <bnf-alt>
    
    nested-requirement
  </bnf-alt>

    <bnf-rule>
    
    simple-requirement:
  </bnf-rule>
      <bnf-alt>
    
    expression <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>

    <bnf-rule>
    
    compound-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-opt><bnf-terminal><code>constexpr</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-terminal><code>{</code></bnf-terminal> expression <bnf-terminal><code>}</code></bnf-terminal>
        <bnf-opt><bnf-terminal><code>noexcept</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-opt>trailing-return-type<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    type-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        typename-specifier <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    nested-requirement:
  </bnf-rule>
      <bnf-alt>
    
    requires-clause <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    <p para_num="2" id="expr.req.2">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> has type
    <code>bool</code>. </p>

    <p para_num="3" id="expr.req.3">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> shall not appear
    outside of a concept definition (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref>) or a
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>. </p>

    <p para_num="4" id="expr.req.4">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    The most common use of 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s is to define
    syntactic requirements in concepts (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref>) 
    such as the one below:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -&gt; const A&lt;T&gt;&amp;;
    };
  }</code></pre>
  
    The concept is defined in terms of the syntactic and type requirements 
    within the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
    
    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> can also be
    used in a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="5" id="expr.req.5">The <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> may introduce
    local arguments via a <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>. 
    These parameters have no linkage, storage, or lifetime.
    They are used only to write constraints within the
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> and are not visible
    outside the closing <code>}</code> of the 
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm>. 
    The <cxx-grammarterm><i>requirement-parameter-list</i></cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p para_num="6" id="expr.req.6">The <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> is a sequence of
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s separated by semicolons.
     These <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s may refer to local 
    arguments, template parameters, and any other declarations visible from the 
    enclosing context. Each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> 
    introduces a conjunction of one or more atomic constraints 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>). The kinds of atomic constraints
    introduced by a <cxx-grammarterm><i>requirement</i></cxx-grammarterm> are:
    </p><ul>
    <li>A <dfn>valid expression constraint</dfn> is a predicate on an
    expression. The constraint is satisfied if and only if the substitution of 
    template arguments into that expression does not result in substitution 
    failure. The result of successfully substituting template arguments
    into the dependent expression produces a <dfn>valid expression</dfn>.</li>

    <li>A <dfn>valid type constraint</dfn> is a predicate on a type.
    The constraint is satisfied if and only if the substitution of template
    arguments into that type does not result in substitution failure. The
    result of successfully substituting template arguments into the dependent
    type produces an <dfn>associated type</dfn>.</li>

    <li>A <dfn>result type constraint</dfn> is a predicate on the result type
    of a valid expression. Let <code>E</code> be a valid expression and 
    <code>X</code> be a <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>.

    The constraint is satisfied if and only if <code>E</code> can be used as an 
    argument to an invented function <code>f</code>, which has a single function
    parameter of type <code>X</code> and returning <code>void</code>. That is,
    the function call <code>f(E)</code> must be a valid expression.
    
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Each template parameter referred to by <code>X</code> is a template
    parameter of the invented function <code>f</code>. If <code>X</code>
    contains a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
    or <code>auto</code> specifier, then <code>f</code> is a generic function
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </li>

    <li>A <dfn>constant expression constraint</dfn> is satisfied if and only
    if a valid expression <code>E</code> is a constant expression 
    (<cxx-ref in="cxx" to="expr.const">C++ <span title="expr.const">§5.19</span></cxx-ref>).
    </li>

    <li>An <dfn>exception constraint</dfn> is satisfied if and only if, for
    a valid expression <code>E</code>, the expression <code>noexcept(E)</code>
    evaluates to <code>true</code>
    (<cxx-ref in="cxx" to="expr.unary.noexcept">C++ <span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>).
    </li>
    </ul>
    <!-- </p> -->

    <p para_num="7" id="expr.req.7">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> evaluates to
    <code>true</code> if and only the atomic constraints introduced by
    each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> in the 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm> are satisfied
    and <code>false</code> otherwise. The semantics of each kind of 
    requirement are described in the following sections.</p>

    <cxx-section id="expr.req.simple">
    

    <section>
      <header><span class="section-number">5.1.3.1</span> <h1 data-bookmark-label="5.1.3.1 Simple requirements">Simple requirements</h1> <span style="float:right"><a href="#expr.req.simple">[expr.req.simple]</a></span></header>
      
      
      <p para_num="1" id="expr.req.simple.1">A <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> introduces a
      valid expression constraint for its 
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>. The expression is an
      unevaluated operand (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      The following is requirement evaluates to <code>true</code> for all 
      arithmetic types (<cxx-ref in="cxx" to="basic.fundamental">C++ <span title="basic.fundamental">§3.9.1</span></cxx-ref>),
      and <code>false</code> for pointer types 
      (<cxx-ref in="cxx" to="basic.compound">C++ <span title="basic.compound">§3.9.2</span></cxx-ref>).
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires (T a, T b) {
  a + b;  // A simple requirement
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.simple.2">If the expression would always result in a substitution failure, 
      the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  new T[-1];  // error: the valid expression well never be well-formed.
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.simple -->


    <cxx-section id="expr.req.type">
    

    <section>
      <header><span class="section-number">5.1.3.2</span> <h1 data-bookmark-label="5.1.3.2 Type requirements">Type requirements</h1> <span style="float:right"><a href="#expr.req.type">[expr.req.type]</a></span></header>
      
      
      <p para_num="1" id="expr.req.type.1">A <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> introduces 
      valid type constraint for its 
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm>.
      
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A type requirement requests the validity of an associated
      type, either as a nested type name, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm><i>type-specifiers</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename T::inner;         // Required nested type name
  typename Related&lt;T&gt;; // Required alias
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.type.2">If the required type will always results in a substitution failure,
      then the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename int::X;  // error: int does not have class type
  typename T[-1];   // error: array types cannot have negative extent
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.type -->


    <cxx-section id="expr.req.nested">
    

    <section>
      <header><span class="section-number">5.1.3.3</span> <h1 data-bookmark-label="5.1.3.3 Nested requirements">Nested requirements</h1> <span style="float:right"><a href="#expr.req.nested">[expr.req.nested]</a></span></header>
      
      
      <p para_num="1" id="expr.req.nested.1">A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> introduces
      an additional constraint expression <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref> 
      to be evaluated as part of the satisfaction of the 
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>. 
      The requirement is satisfied if and only if the constraint evaluates to
      value <code>true</code>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
     
      Nested requirements are generally used to provide additional constraints on 
      associated types
      within a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename X<t>;
  requires C&lt;X&lt;T&gt;&gt;();
}
      </t></code></pre>
  
      These requirements are satisfied only when substitution into 
      <code>X&lt;T&gt;</code> is successful and when 
      <code>C&lt;X&lt;T&gt;&gt;()</code> evaluates to <code>true</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.re.nested -->



    <!-- TODO: {e}->cv void is ill-formed.

         For two reasons. First, we can't actually form an invented
         function template that takes cv void as an argumnet (oops).
         Second, even if we could, no expression converts to void. -->

    <cxx-section id="expr.req.compound">
    

    <section>
      <header><span class="section-number">5.1.3.4</span> <h1 data-bookmark-label="5.1.3.4 Compound requirements">Compound requirements</h1> <span style="float:right"><a href="#expr.req.compound">[expr.req.compound]</a></span></header>
      
      
      <p para_num="1" id="expr.req.compound.1">A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces 
      a conjunction of one or more constraints pertaining to its
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>, depending on the syntax
      used. This set includes:
      </p><ul>
      <li>a valid expression constraint,</li>
      <li>an optional associated type constraint</li>
      <li>an optional result type constraint,</li>
      <li>an optional constant expression constraint, and </li>
      <li>an optional an exception constraint.</li>
      </ul>
      A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> is
      satisfied if and only if every constraint in the set is satisfied.
      
      <!-- BUG: There is a core issue on this -->
      The required valid expression is an unevaluated operand
      (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>)
      except in the case when the <code>constexpr</code> specifier is present.
      These other requirements are described in the following paragraphs.
      <!-- </p> -->

      <p para_num="2" id="expr.req.compound.2">The brace-enclosed <cxx-grammarterm><i>expression</i></cxx-grammarterm> in
      a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces
      a valid expression constraint. Let <code>E</code> be the valid expression
      resulting from successful substitution.

      </p><p para_num="3" id="expr.req.compound.3">The presence of a
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> introduces 
      a result type constraint on <code>E</code>.</p>

      <p para_num="4" id="expr.req.compound.4">If the <code>constexpr</code> specifier is present then a constant 
      expression constraint is introduced for the valid expression 
      <code>E</code>.</p>

      <p para_num="5" id="expr.req.compound.5">If the <code>noexcept</code> specifier is present, then an
      exception constraint is introduced for the valid expression
      <code>E</code>.</p>

      <p para_num="6" id="expr.req.compound.6">
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename I&gt;
  concept bool Inscrutible() { ... }

requires(T x) {
  {x++}; #1
  {*x} -&gt; typename T::r; #2
  {f(x)} -&gt; const Inscrutible&amp; #3
  {g(x)} noexcept -&gt; auto&amp; #4
  constexpr {T::value}; #5
  constexpr {T() + T()} -&gt; T #6;
}</code></pre>
  
      Each of these requirements introduces a valid expression constraint
      on the expression in its enclosing braces.

      Requirement #1 introduces no additional constraints. It is equivalent to 
      a <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> containing the 
      same expression.
      
      Requirement #2 <code>*x</code> introduces a result type constraint
      though its <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
      <code>typename T::r</code>. The required valid expression <code>*x</code> 
      must be usable as an argument to the invented function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt; 
  void z1(typename T::r);</code></pre>
  </cxx-codeblock>

      Requirement #3 also introduces a result type constraint on its required
      valid expression <code>f(x)</code>. This expression must be usable as
      an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z2(const Instrutible&amp;)</code></pre>
  </cxx-codeblock>
      
      Requirement #4 introduces a result type constraint and an exception 
      constraint. The required valid expression <code>g(x)</code> must
      be usable as as an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z3(auto&amp;);</code></pre>
  </cxx-codeblock>
      Additionally, <code>g(x)</code> must not propagate exceptions.

      Requirement #5 introduces a constant expression constraint:
      <code>T::value</code> must be a constant expression. 

      The requirement in #6 introduces a result type constraint and a constant 
      expression constraint. The required valid expression 
      <code>T() + T()</code> must be usable as an argument to the invented 
      function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt;
  void z4(T);</code></pre>
  </cxx-codeblock>
      The valid expression must also be a constant expression.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.compound -->
 
  
    </section>
  </cxx-section> <!-- expr.req -->

    </section>
  </cxx-section>
    </section>
  </cxx-clause> <!-- expr -->

<cxx-clause id="dcl.dcl" number="7">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Declarations">Declarations</h1> <span style="float:right"><a href="#dcl.dcl">[dcl.dcl]</a></span></header>
      
  

  <cxx-section id="dcl.spec">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Specifiers">Specifiers</h1> <span style="float:right"><a href="#dcl.spec">[dcl.spec]</a></span></header>
      
    

    Extend the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p para_num="1" id="dcl.spec.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    decl-specifier:
  </bnf-rule>
        <ins><bnf-alt>
    
    <bnf-terminal><code>concept</code></bnf-terminal>
  </bnf-alt></ins>
    
  </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
    

    <section>
      <header><span class="section-number">7.1.6</span> <h1 data-bookmark-label="7.1.6 Type specifiers">Type specifiers</h1> <span style="float:right"><a href="#dcl.type">[dcl.type]</a></span></header>
      
      

      <cxx-section id="dcl.type.simple" number="2">
    

    <section>
      <header><span class="section-number">7.1.6.2</span> <h1 data-bookmark-label="7.1.6.2 Simple type specifiers">Simple type specifiers</h1> <span style="float:right"><a href="#dcl.type.simple">[dcl.type.simple]</a></span></header>
      
        
        
        Add <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        to the grammar for <cxx-grammarterm><i>simple-type-specifier</i></cxx-grammarterm>s
        in <cxx-ref in="cxx" to="dcl.type.simple">C++ <span title="dcl.type.simple">§7.1.6.2</span></cxx-ref>.

        <p para_num="1" id="dcl.type.simple.1" class="quoted">
        <bnf-grammar>
    
    
          <bnf-rule>
    
    simple-type-specifier:
  </bnf-rule>
            <ins><bnf-alt>
    
    constrained-type-specifier
  </bnf-alt></ins>

          <ins>
          <bnf-rule>
    
    constrained-type-specifier:
  </bnf-rule>
            <bnf-alt>
    
    
              <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> constrained-type-name
            
  </bnf-alt>

          <bnf-rule>
    
    constrained-type-name:
  </bnf-rule>
            <bnf-alt>
    
    concept-name
  </bnf-alt>
            <bnf-alt>
    
    partial-concept-id
  </bnf-alt>

          <bnf-rule>
    
    concept-name:
  </bnf-rule>
            <bnf-alt>
    
    identifier
  </bnf-alt>

          <bnf-rule>
    
    partial-concept-id:
  </bnf-rule>
            <bnf-alt>
    
    
              concept-name 
              <bnf-terminal><code>&lt;</code></bnf-terminal> 
              template-argument-list
              <bnf-terminal><code>&gt;</code></bnf-terminal>
            
  </bnf-alt>
          </ins>
        
  </bnf-grammar>
        </p>
      
    </section>
  </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
    

    <section>
      <header><span class="section-number">7.1.6.4</span> <h1 data-bookmark-label="7.1.6.4 auto specifier"><code>auto</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.auto">[dcl.spec.auto]</a></span></header>
      
        

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/1 as
        follows:

        <p para_num="1" id="dcl.spec.auto.1" number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.
        </p>


        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/1.

        <p para_num="2" id="dcl.spec.auto.2" class="quoted">
        <ins>
        The <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        can be used to construct different forms of types, provided that
        the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        shall not appear in a non-deduced context 
        (<cxx-ref in="cxx" to="temp.deduct.type">C++ <span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>),
        and that the type containing the <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        shall have one of the following forms:
        <cxx-codeblock>
    
    </cxx-codeblock></ins></p><pre><code>auto
<i>cv-list</i> auto
auto*
auto&amp;
auto&amp;&amp;
auto[<i>integer-constant</i>]
<i>template-name</i>&lt;auto&gt; (where <i>template-name</i> refers to a class template)
<i>type</i>(auto)
auto()
auto <i>type</i>::*
<i>type</i> auto::*
auto (<i>type</i>::*)()
<i>type</i> (auto::*)()
<i>type</i> (<i>type</i>::*)(auto)</code></pre>
  

        where <code>(auto)</code> represents a 
        <cxx-grammarterm><i>parameter-type-list</i></cxx-grammarterm>
        where at least one parameter type contains an <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, and 
        <code>()</code> represents a
        <cxx-grammarterm><i>parameter-type-list</i></cxx-grammarterm> where no 
        parameter type contains an <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>. 

        Similarly, <code>&lt;T&gt;</code> represents template argument
        lists where at least one argument contains an
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Placeholder types designated by the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> are replaced by
        invented template parameters to facilitate the deduction of a
        value for that type. These forms, and the use of <code>auto</code> within 
        them, are the only forms for which template type deduction can succeed.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        
        <p></p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/2 to read:

        <p para_num="2" id="dcl.spec.auto.2" number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, 
        <cxx-grammarterm><i>type-specifier-seq</i></cxx-grammarterm>,
        <cxx-grammarterm><i>conversion-function-id</i></cxx-grammarterm>, or 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>, in any 
        context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3 as follows:

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of</del>
        <ins>in the type of</ins>
        a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>, the lambda is
        a <dfn>generic lambda</dfn>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        of a function declaration, the function is an <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>)

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>void f(const auto&amp;, int); // <i>OK: an abbreviated function</i></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        <p></p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3.

        <p para_num="4" id="dcl.spec.auto.4" class="quoted">
        The <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        can appear in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in
        a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
        (<cxx-ref to="expr.req.compound"><a title="expr.req.compound" href="#expr.req.compound">5.1.3.4</a></cxx-ref>).
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -&gt; const auto&amp;; // <i>OK</i>
  };
}</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <p></p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p para_num="4" id="dcl.spec.auto.4" number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block">C++ <span title="stmt.block">§6.3</span></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace">C++ <span title="basic.scope.namespace">§3.3.6</span></cxx-ref>), and 
        in a <cxx-grammarterm><i>for-init-statement</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for">C++ <span title="stmt.for">§6.5.3</span></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s in the
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
    
    </cxx-codeblock></p><pre><code>( <i>expression-list</i> )</code></pre>
  
        the <cxx-grammarterm><i>expression-list</i></cxx-grammarterm> shall be a 
        single <cxx-grammarterm><i>assignment-expression</i></cxx-grammarterm>.
        <p></p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/7.

        <p para_num="5" id="dcl.spec.auto.5" class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list">C++ <span title="dcl.init.list">§8.5.4</span></cxx-ref>), the program is 
        ill-formed. 

        <!-- General rule for constructing P -->
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        <!-- The much maligned init deduction -->
        if the initializer is a <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call">C++ <span title="temp.deduct.call">§14.8.2.1</span></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; struct Vec;
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;);

auto x1 = { 1, 2 };                 // <ins><i>OK:</i> </ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = 12;                      // <i>OK:</i> decltype(x3) <i>is</i> const int&amp;
const auto* p = &amp;x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltpye(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3});          // <i>error: cannot deduce element type</i></ins></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>const auto<ins>&amp;</ins><del> &amp;</del>i = expr;</code></pre>
  </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
    
    <pre><code>template &lt;class U&gt; void f(const U&amp; u);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
    
    <pre><code>template&lt;typename F, typename S&gt; struct Pair;

Pair&lt;const auto&amp;, auto*&gt; p = expr;</code></pre>
  </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(expr)</code> of the following invented function template:
        <cxx-codeblock>
    
    <pre><code>template&lt;typename U1, typename U2&gt; void g(Pair&lt;const U1&amp;, const U2*&gt; x);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <p></p>

      
    </section>
  </cxx-section> <!-- dcl.spec.auto -->



        <!-- TODO: Rewrite this section so that it reflects and refers
             to dcl.spec.auto. In particular, we want to say where these
             are allowed, how their placeholder types are deduced, and
             what constraint is introduced. -->
      <cxx-section id="dcl.spec.constr">
    

    <section>
      <header><span class="section-number">7.1.6.5</span> <h1 data-bookmark-label="7.1.6.5 Constrained type specifiers">Constrained type specifiers</h1> <span style="float:right"><a href="#dcl.spec.constr">[dcl.spec.constr]</a></span></header>
      
        

        Add this section to <cxx-ref in="cxx" to="dcl.type">C++ <span title="dcl.type">§7.1.6</span></cxx-ref>.
        The usual formatting marks are omitted since all text is new.

        <p para_num="1" id="dcl.spec.constr.1">
        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from the <cxx-gramarterm>expression</cxx-gramarterm> in a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> or 
        function argument. 

        This deduction succeeds only when the deduced type satisfies the
        constraints introduced by the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
        also signifies that a lambda is a generic lambda or
        that a function is an abbreviated function. 
        </p>

        <!-- TODO: Maybe a little fuzzy. -->
        <p para_num="2" id="dcl.spec.constr.2">
        Like the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>), 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
        can be used to construct other types. The forms of types that
        can be constructed, and the use of 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
        within them are the same as those specified for the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>.
        </p>

        <!-- TODO: Consider adding this to the list of non-deduced
             contexts. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->

        <p para_num="3" id="dcl.spec.constr.3">
        If <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the type of a 
        <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>, the lambda
        is a generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        Similarly, if a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the type of a
        <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a
        function declaration, the function is an abbreviated function
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; class Vec;

auto gl [](C&amp; a, C* b) { a = *b; } // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);          // <i>OK: an abbreviated function</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="4" id="dcl.spec.constr.4">
        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        can also appear in the 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in a
        <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
        (<cxx-ref to="expr.req"><a title="expr.req" href="#expr.req">5.1.3</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -&gt; const C&amp;; // OK
  };
}</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="5" id="dcl.spec.constr.5">
        A program that uses a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in a context not explicitly allowed by this section is ill-formed.
        </p>


        <p para_num="6" id="dcl.spec.constr.6">
        When an <cxx-grammarterm><i>identifier</i></cxx-grammarterm> is a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> it refers to a set
        of concept definitions (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        The first declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
        of a concept definition is called its <dfn>prototype parameter</dfn>.

        Only concept definitions whose prototype parameter is a template
        <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> are in the
        candidate concept set referred to by a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.

        If the candidate concept set is empty, the program is ill-formed.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member when a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        refers to a variable concept has at most one member.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;int N&gt; concept bool C() { return true; }                  // <i>#3</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#4</i>
template&lt;template&lt;typename&gt; class X&gt; concept bool P = true;        // <i>#5</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #4</i>
void h(P); // <i>error: no matching concept definitions for</i> P</code></pre>
  
        In the declaration of <code>f(C)</code>, the candidate concept set
        corresponding to the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>,
        <code>C</code>, does not include #3 because its first
        <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> of that
        concept definition is a non-type template parameter.
        Likewise, in the declaration of <code>h(P)</code>, #5 is not
        included because its prototype parameter is not a template
        <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm>.
        
        
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>

        <p para_num="7" id="dcl.spec.constr.7">
        A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="8" id="dcl.spec.constr.8">
        The concept definition designated by a
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
        determined by forming a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
        from the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> and
        a sequence of <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm>.

        Let <code>C</code> be the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        in the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
        and let <code>T</code> be an invented template <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm>
        corresponding to the placeholder type that the
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> designates.

        When the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, the
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> is formed as
        <code>C&lt;T&gt;</code>.

        When the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> whose
        <cxx-grammarterm><i>template-argument-list</i></cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>,
        the <cxx-grammarterm><i>template-id</i></cxx-grammarterm> is formed as
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>.

        If the <cxx-grammarterm><i>template-id</i></cxx-grammarterm> refers to a
        single concept declaration in the candidate concept set, that 
        concept is the one designated by the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        A <cxx-grammarterm><i>template-id</i></cxx-grammarterm> may not refer to
        a template specialization if the template arguments do not match
        the template's declared parameters (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.3</a></cxx-ref>).
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="9" id="dcl.spec.constr.9">The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the associated constraint appertains 
        to the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        For an abbreviated function declaration, the associated constraint 
        appertains to that function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of
        a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"><a title="expr.req.compound" href="#expr.req.compound">5.1.3.4</a></cxx-ref>).
        </p>

        <p para_num="10" id="dcl.spec.constr.10">
        The constraint associated by a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is formed from the <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
        used to determine the designated concept. The associated
        constraint is
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>
        when the designated concept is a variable concept
        and 
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;()</code>
        when the designated concept is a function concept.
        
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>
        is an empty empty if the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm>
        is a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }

void f(C&amp;);     // associates C&lt;T&gt; with f
void g(D&lt;int&gt;); // associates D&lt;U, int&gt; with g</code></pre>
  
        In the associated constraints, <code>T</code> and <code>U</code> 
        are invented template type parameters corresponding to the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in their respective declarations.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="11" id="dcl.spec.constr.11">
        When multiple <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
        appear in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        or a <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
        the associated or introduced constraints are a conjunction of the
        constraints associated by each 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
        These constraints are evaluated in the order in which they appear.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typemame T&gt; concept bool C = true;
template&lt;typemame T, typename U&gt; concept bool D = true;

void f(Pair&lt;C, D&lt;int&gt;&gt;&amp; p);</code></pre>
  
        The constraint associated by the type of the parameter <code>p</code>
        are:
        <cxx-codeblock>
    
    <pre><code>C&lt;T1&gt; &amp;&amp; D&lt;T2, int&gt;</code></pre>
  </cxx-codeblock>
        where <code>T1</code> and <code>T2</code> are the invented template
        type parameters corresponding to the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
        <code>C</code> and <code>D&lt;int&gt;</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>
      
    </section>
  </cxx-section> <!-- dcl.spec.constr -->

    
    </section>
  </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
    

    <section>
      <header><span class="section-number">7.1.7</span> <h1 data-bookmark-label="7.1.7 concept specifier"><code>concept</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.concept">[dcl.spec.concept]</a></span></header>
      
      

      <p para_num="1" id="dcl.spec.concept.1">The <code>concept</code> specifier shall be applied to only the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its definition or 
      a variable concept and its initializer.</p>

      <p para_num="2" id="dcl.spec.concept.2">A <dfn>type concept</dfn> is a concept whose first template
      parameter is a <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm>, but 
      not a template template parameter. 

      Otherwise, the concept is a <dfn>non-type concept</dfn>.

      A <dfn>variadic concept</dfn> is a concept whose first template
      parameter is a template parameter pack.
      </p>

      <p para_num="3" id="dcl.spec.concept.3">Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr">C++ <span title="dcl.constexpr">§7.1.5</span></cxx-ref>).
      </p>

      <p para_num="4" id="dcl.spec.concept.4">A function concept has the following restrictions:
      </p><ul>
        <li> The template must be unconstrained.</li>
        <li> The result type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The declaration shall be a definition. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose expression shall be a
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool C1() { return true; } // OK

template&lt;typename T&gt;
  concept int C2() { return 0; }  // error: must return bool

template&lt;typename T&gt;
  concept bool C3(T) { return true; } // error: must have no parameters

concept bool p = 0; // error: not a template</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="5" id="dcl.spec.concept.5">A variable template has the following restrictions:
      </p><ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool D1 = has_x&lt;T&gt;::value; // OK

template&lt;typename T&gt;
  concept bool D2 = 3 + 4; // Error: initializer is not a constraint

template&lt;Integral T&gt;
  concept bool D3 = has_x&lt;T&gt;::value; // Error: constrained concept definition</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="6" id="dcl.spec.concept.6">A program that declares an explicit or partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool C = is_iterator&lt;T&gt;::value;

template&lt;typename T&gt;
  concept bool C&lt;T*&gt; = true; // Error: partial specialization of a concept</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="7" id="dcl.spec.concept.7">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

    
    </section>
  </cxx-section> <!-- dcl.concept -->

  
    </section>
  </cxx-section> <!-- dcl.spec -->

    </section>
  </cxx-clause> <!-- dcl.dcl -->


<cxx-clause id="dcl.decl" number="8">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Declarators">Declarators</h1> <span style="float:right"><a href="#dcl.decl">[dcl.decl]</a></span></header>
      
  

  <p para_num="1" id="dcl.decl.1">Modify <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1 as follows:</p>

  <p para_num="2" id="dcl.decl.2">A declarator declares a single variable, function, or type, within a 
  declaration. The <cxx-grammarterm><i>init-declarator-list</i></cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which can 
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    
    
    <bnf-rule>
    
    init-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator
        <bnf-opt>requires-clause<sub>opt</sub></bnf-opt>
        <bnf-opt>initializer<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
  
  </bnf-grammar>
  </p>

  Insert the following paragraph after 
  <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1.

  <p para_num="3" id="dcl.decl.3"> A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the
  <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a generic
  function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template<typename t=""> concept bool C = true;

void f1(auto x) requires C&lt;decltype(x)&gt;;// <i>OK</i>
void f2(int x) requires C&lt;int&gt;;         // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = g();   // <i>error: cannot constrain variable declaration</i>
struct S { } requires C&lt;S&gt;;             // <i>error: cannot constrain a class definition</i>
  </typename></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <cxx-section id="dcl.meaning" number="3">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Meaning of declarators">Meaning of declarators</h1> <span style="float:right"><a href="#dcl.meaning">[dcl.meaning]</a></span></header>
      
    

    <cxx-section id="dcl.fct" number="5">
    

    <section>
      <header><span class="section-number">8.3.5</span> <h1 data-bookmark-label="8.3.5 Functions">Functions</h1> <span style="float:right"><a href="#dcl.fct">[dcl.fct]</a></span></header>
      
      

      <!-- TODO: Add to /15 a rule that disambiguates the ... (without
      a preceeding ',' for constrained-type-specifiers). If it's needed.

      The "or contains auto" will need to be updated. -->


      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct">C++ <span title="dcl.fct">§8.3.5</span></cxx-ref>/14.

      <!-- TODO: Extend this to support constrained-type-specifiers -->
      
      <p para_num="15" id="dcl.fct.15" number="15">
      An abbreviated function (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      (call it <code>F</code>) is equivalent to a 
      function template (<cxx-ref to="temp.fct"><a title="temp.fct" href="#temp.fct">14.5.6</a></cxx-ref>) (call it 
      <code>T</code>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      includes one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
      for each occurrence of a placeholder type, designated by either 
      the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      or by a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),
      in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
      <code>F</code>, in order of appearance. 

      The invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
      declares a function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>)
      and the type of the parameter contains only one placeholder type.

      The function parameters of <code>T</code> are derived from the
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
      <code>F</code> by replacing each occurrence of a placeholder type 
      with the  name of the corresponding invented type
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.
      
      <!-- TODO: Write examples with concepts -->
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(auto);
void f2(auto&amp;, auto);
auto f3(void (*)(auto));
void f4(auto (*)(int));
void f5(Vec&lt;auto&gt;&amp;);
void f6(Pair&lt;auto&amp;, auto*&gt;);
void f7(auto&amp;&amp;...);
void f8(Vec&lt;auto&gt;...);

template&lt;typename T&gt; void f1(T);                        // <i>equivalent to</i> f1(auto)
template&lt;typename T, typename U&gt; void f2(T&amp;, U);        // <i>equivalent to</i> f2(auto&amp;, auto)
template&lt;typename T&gt; void f3(void (*)(T));              // <i>equivalent to</i> f3(void (*)(auto))
template&lt;typename T&gt; void f4(T (*)(int));               // <i>equivalent to</i> f4(auto (*)(int))
template&lt;typename T&gt; void f5(Vec&lt;T&gt;&amp;);                  // <i>equivalent to</i> f5(Vec&lt;auto&gt;&amp;)
template&lt;typename T, typename U&gt; void f6(Pair&lt;T&amp;, U*&gt;); // <i>equivalent to</i> f6(Pair&lt;auto&amp;, auto*&gt;)
template&lt;typename... Args&gt; void f7(Args&amp;&amp;...);          // <i>equivalent to</i> f7(auto&amp;&amp;...)
template&lt;typename... Args&gt; void f8(Vec&lt;Args&gt;...);       // <i>equivalent to</i> f8(Vec&lt;auto&gt;...)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <!-- TODO: This moves into dcl.fct -->
      <p para_num="16" id="dcl.fct.16"> All placeholder types introduced using the same 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> have the 
      same invented template type parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>namespace N {
  template&lt;typename T&gt; concept bool C = true;
}
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int&gt; concept D = true;
template&lt;typename, int = 0&gt; E = true;

void f0(C a, C b);</code></pre>
  
      The types of <code>a</code> and <code>b</code> are the same invented template
      type parameter.
      <cxx-codeblock>
    
    <pre><code>void f1(C&amp; a, C* b);</code></pre>
  </cxx-codeblock>
      The type of <code>a</code> is a reference to an invented template type parameter 
      (call it <code>T</code>), and the type of <code>b</code> is a pointer to 
      <code>T</code>.
      <cxx-codeblock>
    
    <pre><code>void f2(N::C a, C b);
void f3(D&lt;0&gt; a, D&lt;1&gt; b);</code></pre>
  </cxx-codeblock>
      In both functions, the parameters <code>a</code> and
      <code>b</code> have different invented template type parameters.
      <cxx-codeblock>
    
    <pre><code>void f4(E a, E&lt;&gt; b, E&lt;0&gt; c)</code></pre>
  </cxx-codeblock>
      The types of <code>a</code>, <code>b</code>, and <code>c</code> are
      distinct invented template type parameters even though the constraints 
      associated by the each of the 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>) are equivalent.
      <cxx-codeblock>
    
    <pre><code>template&lt;typename...&gt; struct Tuple;

void f5(Tuple&lt;C&amp;, C*, N::C&gt; p);</code></pre>
  </cxx-codeblock>
      The type of <code>p</code> is <code>Tuple&lt;T&amp;, T*, U&gt;</code> where 
      <code>T</code> and <code>U</code> are the invented template type parameters
      corresponding to <code>C</code> and <code>N::C</code>, respectively.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


      <!-- TODO: Move into temp.fct? -->
      <p para_num="17" id="dcl.fct.17"> A function template can be an abbreviated function. The
      invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s are
      added to the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: Equivalent to f(Array&lt;auto, N&gt;*)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <!--

      <p>A <defn>generic function</defn> is a function template whose
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> has a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> whose 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> is either 
      <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.
      </p>

      <p>The declaration of a generic function has a 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> that 
      consists of one invented type 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> for each
      occurrence of <code>auto</code> or each unique occurrence of a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
      in the function's
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 
      
      The invented type of 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> is a parameter 
      pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> declares 
      a function parameter pack (<cxx-ref in="cxx" to="dcl.fct"></cxx-ref>).
      
      If the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of the 
      corresponding <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
      includes a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      the invented type parameter is a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, whose
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> matches
      that of the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>.
      (<cxx-ref to="temp.param"></cxx-ref>).</ins>

      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
template&lt;typenaem T&gt;
  conxtexpr bool C() { ... }

auto f(auto x, const C&amp; y);

template&lt;typename T1, C T2&gt;
  auto f(T1 x, const T2&amp; y);
      </cxx-codeblock>
      The type of <code>y</code> is a type parameter constrained by
      <code>C</code>.
      </cxx-example>
      </p>

      <p>All placeholder types introduced using the same 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm> have the 
      same invented template parameter.
      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
auto g(C a, C* b);

template&lt;C T&gt;
  auto g(T a, T* b);
      </cxx-codeblock>
      </cxx-example>
      </p>
      -->

    
    </section>
  </cxx-section> <!-- dcl.fct -->
  
    </section>
  </cxx-section> <!-- dcl.meaning -->

  <cxx-section id="dcl.fct.def">
    

    <section>
      <header><span class="section-number">8.4</span> <h1 data-bookmark-label="8.4 Function definitions">Function definitions</h1> <span style="float:right"><a href="#dcl.fct.def">[dcl.fct.def]</a></span></header>
      
    

    <cxx-section id="dcl.fct.def.general">
    

    <section>
      <header><span class="section-number">8.4.1</span> <h1 data-bookmark-label="8.4.1 In general">In general</h1> <span style="float:right"><a href="#dcl.fct.def.general">[dcl.fct.def.general]</a></span></header>
      
      
    
      <p para_num="1" id="dcl.fct.def.general.1">Modify the <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>
      to include a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.</p>

      <bnf-grammar>
    
    
        <bnf-rule>
    
    function-definition:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            <bnf-opt>decl-specifier-seq<sub>opt</sub></bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
            <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
            function-body
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="2" id="dcl.fct.def.general.2">Add the following paragraph at the end of
      <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>.</p>

      <p para_num="3" id="dcl.fct.def.general.3">A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the
      <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a generic
      function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>) or a member function
      definition (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Constraints for a function template or member function template are
      written after the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = ...;
template&lt;typename T&gt; concept bool C2 = ...;
template&lt;typename T, typename U&gt; concept bool D = ...;

void f(C1 a, C2 b) requires D&lt;decltype(a), decltype(b)&gt; { } // Ok

template&lt;typename T&gt;
  void f(const T&amp; x) requires C&lt;T&gt;; // Error: f is declared as a template

template&lt;typename T&gt;
  struct S1 {
    S1(T&amp;) requires C1&lt;T&gt; { }   // Defines a constrained constructor
    void f() requires C2&lt;T&gt; { } // Defines a constrained member function
  };

struct S2 {
  void g(auto x) requires D&lt;decltype(x)&gt; { } // Ok
};</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="dcl.fct.def.general.4">A <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      shall not declare a destructor (<cxx-ref in="cxx" to="class.dtor">C++ <span title="class.dtor">§12.4</span></cxx-ref>)
      with a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
     <!-- dcl.fct.def.general -->
   <!-- dcl.fct.def -->

 <!-- dcl.decl -->
</p>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-clause>

<cxx-clause id="class" number="9">
    

    <section>
      <header><span class="section-number">9</span> <h1 data-bookmark-label="9 Classes">Classes</h1> <span style="float:right"><a href="#class">[class]</a></span></header>
      
  

  <cxx-section id="class.mem" number="2">
    

    <section>
      <header><span class="section-number">9.2</span> <h1 data-bookmark-label="9.2 Class members">Class members</h1> <span style="float:right"><a href="#class.mem">[class.mem]</a></span></header>
      
    

    <p para_num="1" id="class.mem.1">In <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref>, modify the
    <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm> syntax.</p>

    <bnf-grammar>
    
    
      <bnf-rule>
    
    member-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator 
        <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
        <bnf-opt>pure-specifier-seq<sub>opt</sub></bnf-opt>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
      
  </bnf-alt>
    
  </bnf-grammar>

  <p para_num="2" id="class.mem.2">Insert the following paragraph after 
  <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref></p>

  <p para_num="3" id="class.mem.3">A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the 
  <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a constrained member
  function of a class template (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>)
  or a generic function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = ...;
template&lt;typename T&gt; concept bool D = ...;

template&lt;typename T&gt;
  struct A {
    A(T*) requires C&lt;T&gt;;    // Declares a constrained constructor
    void f() requires D&lt;T&gt;; // Declares a constrained member function
  };

struct B {
  void g(int n) requires C&lt;int&gt;; // Error: cannont constraint a non-template
  void h(C a, D b);              // Declares a constrained generic member function

};</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A constrained generic function declared at class scope is a member function
  template.
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  <p></p>

  <p para_num="4" id="class.mem.4">A destructor (<cxx-ref in="cxx" to="class.dtor">C++ <span title="class.dtor">§12.4</span></cxx-ref>) shall not be 
  declared with <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>s.</p>

  
    </section>
  </cxx-section> <!-- class.mem -->

    </section>
  </cxx-clause>


<cxx-clause id="temp" number="14">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Templates">Templates</h1> <span style="float:right"><a href="#temp">[temp]</a></span></header>
      
  

  <!-- Editing instruction -->
  Modify the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  grammar in <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>/1.

  <!-- TODO: Put this in block quotes. Currently, some formatting is
       not propagated through the blockquote element, so I'm omitting
       it for now. -->
  <p para_num="1" id="temp.1" number="1" class="quoted">
  <bnf-grammar>
    
    
    <bnf-rule>
    
    template-declaration:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>template</code></bnf-terminal>
        <bnf-terminal><code>&lt;</code></bnf-terminal>
        template-parameter-list
        <bnf-terminal><code>&gt;</code></bnf-terminal>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        declaration
      
  </bnf-alt>
      <ins>
      <bnf-alt>
    
    
        <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> 
        concept-name
        <bnf-terminal><code>{</code></bnf-terminal>
        introduction-list
        <bnf-terminal><code>}</code></bnf-terminal>
        declaration
      
  </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>
    
    requires-clause:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> constraint-expression
  </bnf-alt>

    <bnf-rule>
    
    introduction-list:
  </bnf-rule>
      <bnf-alt>
    
    introduced-parameter
  </bnf-alt>
      <bnf-alt>
    
    introduction-list<bnf-terminal><code>,</code></bnf-terminal> introduced-parameter
  </bnf-alt>

      <bnf-rule>
    
    introduced-parameter:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-opt><bnf-terminal><code>...</code></bnf-terminal><sub>opt</sub></bnf-opt> identifier
  </bnf-alt>
    </ins>
  
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>/6.

  <p para_num="2" id="temp.2"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), or they are
  introduced by a <dfn>concept introduction</dfn>, a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> and following
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.</p>

  <p para_num="3" id="temp.3"> The concept designated by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  is determined by the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.
  Let <code>C</code> be a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm><i>identifiers</i></cxx-grammarterm> in the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s of
  an <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  If the <cxx-grammarterm><i>template-id</i></cxx-grammarterm>,
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code>, refers to a single
  concept declaration, then that concept is the one designated by
  <code>C</code>. Otherwise, the program is ill-formed.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i></code></pre>
  
  It is possible to overload function concepts in such a way that a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> can designate multiple
  concepts.
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of </i> C{X} <i>is ambiguous</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="4" id="temp.4">Each <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  in the <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s
  of the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.
  <cxx-grammarterm><i>
  </i></cxx-grammarterm></p><ul>
  
  <li> If <code>P</code> is a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> using the same keyword;</li>
  
  <li> if <code>P</code> is a template <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> 
  that declares a class template, <code>I</code> is declared as a
  class template with the template parameters of <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type 
  <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, <code>I</code> is
  declared as a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
  having the same type as <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  shall be preceded by an ellipsis, and is declared as a template parameter 
  pack.</li>
  </ul>
  
  An <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T, int N, typename... Xs&gt; concept bool Inscrutable = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool Unary_template = true;

Inscrutable{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;             // B <i>is declared as</i> int B
                        // C <i>is declared as</i> typename... C

Inscrutable{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

Unary_template{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // <i>error: the corresponding parameter is not a</i> 
  void bar();        // <i>template parameter pack</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p para_num="5" id="temp.5"></p>

  <p para_num="6" id="temp.6">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A concept referred to be a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> may omit 
  <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                        // <i>a single template type parameter</i> T</code></pre>
  
There is no <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> 
that corresponds to the template parameter, <code>B</code>, in the
<code>Ineffable</code> concept, so <code>f(T)</code> is declared with only
one template parameter.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="7" id="temp.7"> The <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> shall not
  be empty.</p>

  <p para_num="8" id="temp.8"> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p para_num="9" id="temp.9">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="10" id="temp.10"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> declared
  by a concept introduction can also be an abbreviated function
  (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  The invented template parameters introduced by the presence of
  <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s or
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in
  the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
  are added to the list of template parameters introduced by the the
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} void f(T, D);

template&lt;C T, D __D&gt; void f(T, __D); // <i>OK: redeclaration of</i> f(T, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

C{T} void X&lt;T&gt;::f(D) { } // <i>OK: definition of</i> X&lt;T&gt;::f(D);
                         // f <i>is a function template with one invented</i>
                         // <i>template type-parameter</i>

C{T} D{U} void X&lt;T&gt;::g(U, C) { } // <i>OK: definition of</i> X&lt;T&gt;::g(U, C);
                                 // g <i>is a function template with two template</i>
                                 // <i>type parameters: one introduced (</i>U<i>) and</i>
                                 // <i>one invented</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p></p>

  <p para_num="11" id="temp.11"> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>C</code>,
  associates a constraint with the 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. That constraint is
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;</code> when <code>C</code> designates
  a variable concept and
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;()</code> when <code>C</code> designates
  a function concept. If an <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>
  declares a template parameter pack, its corresponding template argument in the
  associated constraint is a pack expansion 
  (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>).

  <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename A, typename B, int C&gt; concept bool C = true;
template&lt;typename A, typename... Args&gt; concept bool D = true;

C{X, Y, Z} struct S;  // <i>associates</i> C&lt;X, Y, Z&gt; <i>with</i> S
D{P, ...Qs} struct T; // <i>associates</i> D&lt;P, Qs...&gt; <i>with</i> T</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- FIXME: This should move to a separate section? -->


  <p para_num="12" id="temp.12">A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  </p><ul>
  <li> a concept introduction,

  </li><li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>)
  in the declaration's <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
  a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> appearing after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> of an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> whose 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>).

  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declarations are equivalent:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);</code></pre>
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of its
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  <p para_num="13" id="temp.13">

  </p><p para_num="14" id="temp.14"> When <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> whose
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p para_num="15" id="temp.15">When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), it
  is equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>E</code>,
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>).
  
  The declaration, <code>E</code>, has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code> (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>).

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, its
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 A, C2 B&gt; struct R;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename X, int Y&gt; 
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct R; // <i>error: redeclaration of R with different constraints</i>

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="16" id="temp.16"> When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="17" id="temp.17"> An abbreviated function can also be declared as a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in the
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> and the
  following <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

template&lt;C T, D U&gt;
  requires P&lt;T&gt;     // <i>associated constraints are</i> C&lt;T&gt; &amp;&amp; D&lt;U&gt;() &amp;&amp; P&lt;T&gt; 
    void g1(T, U);  // <i>error: ill-formed, no diagnostic required</i>;
  
C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)</code></pre>
  
  The second declaration of <code>g1(T, U)</code> is ill-formed (no diagnostic
  required) because it is functionally equivalent to the first declaration, 
  but not equivalent.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  


  <p></p><p para_num="18" id="temp.18"> A <dfn>trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm></dfn> 
  is a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> that appears after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U, typename __P&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)</code></pre>
  
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Template parameters">Template parameters</h1> <span style="float:right"><a href="#temp.param">[temp.param]</a></span></header>
      
    

    Modify the <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/1 as follow.

    <p para_num="1" id="temp.param.1" number="1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-parameter:
  </bnf-rule>
        <del><bnf-alt>
    
    parameter-declaration
  </bnf-alt></del>
        <ins><bnf-alt>
    
    constrained-or-non-type-parameter
  </bnf-alt></ins>

      <bnf-rule>
    
    constrained-or-non-type-parameter:
  </bnf-rule>
        <bnf-alt>
    
    basic-parameter-declaration
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer-clause 
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> type-id 
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> id-expression 
  </bnf-alt>
      
    
  </bnf-grammar>
    </p>
    
    Modify <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/2 as follows.

    <p para_num="2" id="temp.param.2" number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm><i>unqualified-id</i></cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm><i>qualified-id</i></cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>. 
    </p>

    Modify <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/15 as follows.

    <p para_num="15" id="temp.param.15" number="15" class="quoted">
    If a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is a 
    <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> with an ellipsis prior to 
    its optional identifier 
    or is a 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>
    that declares a parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
    then the template-parameter is a template parameter pack 
    (<cxx-ref to="temp.variadic"><a title="temp.variadic" href="#temp.variadic"></a></cxx-ref>).
     
    A template parameter pack that is a
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> </del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>
    whose type contains one or more unexpanded parameter packs is a pack 
    expansion.
    </p>

    Add the following paragraphs after
    <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/15.

    <!-- TODO: I don't think I can write this until I've rewritten
         the constrained-type-specifier work -->.

    <p para_num="16" id="temp.param.16">A <dfn>constrained template parameter</dfn> is a
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> whose
    <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> contains a
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

    A <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> 
    defines its identifier to be a template parameter that matches in
    kind the first template parameter, called the <dfn>prototype parameter</dfn>, 
    of the concept designated by the 
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; 
  concept bool C1 = ...;
template&lt;template&lt;typename&gt; class X&gt; 
  concept bool C2 = ...;
template&lt;int N&gt; 
  concept bool P = ...;

template&lt;C1 T&gt; void f();       // T is a type parameter
template&lt;C2 X&gt; void g();       // X is a template with one type parameter
template&lt;P N&gt; void x();        // N has type int
template&lt;const P* N&gt; void y(); // N has type const int*</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="17" id="temp.param.17">If the prototype parameter is a type parameter (including template
    template parameters), then the 
    <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of the
    constrained parameter shall consist of only the
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;const C1&gt; // Error: declares a const-qualified type parameter
  struct S;</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="18" id="temp.param.18">The declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is
    a template parameter pack if the prototype parameter declares a
    template parameter pack. In such cases, the 
    <cxx-grammarterm><i>declarator-id</i></cxx-grammarterm> or
    <cxx-grammarterm><i>abstract-declarator</i></cxx-grammarterm> of the
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> shall
    also include an ellipsis.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename... Ts&gt;
  concept bool X = ...;

template&lt;X... Xs&gt; void f(); // Xs is a parameter pack
template&lt;X Xs&gt; void g();    // Error: must X must include ...</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="19" id="temp.param.19">If the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>
    declares a type parameter, then the 
    <cxx-grammarterm><i>constrained-initializer</i></cxx-grammarterm>
    is parsed as a <cxx-grammarterm><i>type-id</i></cxx-grammarterm>. Otherwise, it
    is parsed as a <cxx-grammarterm><i>initializer-clause</i></cxx-grammarterm>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C1 T = int&gt; void p(); // Ok
template&lt;P N = 0&gt; void q();    // Ok
template&lt;P M = int&gt; void r();  // Error: int is not an expression</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="20" id="temp.param.20">The declaration of a 
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> 
    introduces a new constraint on the template declaration. 

    The constraint is formed by substituting the declared 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> as the first
    template argument of the concept declaration designated by the
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> in
    the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> declaration.

    If the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
    a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>, its template
    arguments are substituted after the declared
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

    If the designated concept is a function concept, then the 
    introduced constraint is a function call.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C1 T&gt; void f1(); // requires C1&lt;T&gt;
template&lt;C2 U&gt; void f2(); // requires C2&lt;U&gt;
template&lt;P N&gt; void f3(); // requires P&lt;N&gt;</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="21" id="temp.param.21">If the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> declares 
    a template parameter pack, the formation of the constraint depends on 
    whether the designated concept designated by the parameter's
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is variadic.

    Let <code>T</code> be the declared parameter, <code>C</code> be the
    designated concept, and <code>Args...</code> be a  sequence of template
    arguments from a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>,
    possibly empty.

    If <code>C</code> is a variadic concept, then the associated constraint
    is a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of the form
    <code>C&lt;T..., Args...&gt;</code>. 

    Otherwise, if <code>C</code> is not a variadic concept, the associated
    constraint is a conjunction of sub-constraints
    <code>C&lt;T<i>i</i>, Args...&gt;</code> for each <code>T<i>i</i></code>
    in the parameter pack <code>T</code>.

    If <code>C</code> is a function concept, each introduced constraint or
    sub-constraint is adjusted to be a call expression of the form
    <code>C&lt;X, Args...&gt;()</code> where <code>X</code> is either
    the template parameter pack <code>T</code> or an element 
    <code>T<i>i</i></code>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename... Ts&gt; concept bool P = ...;
template&lt;typename T&gt; concept bool U = ...;


template&lt;P... Xs&gt; void f4();   // requires P&lt;Xs...&gt;
template&lt;U... Args&gt; void f5(); // requires U&lt;Args0&gt; &amp;&amp; U&lt;Args1&gt; &amp;&amp; ... &amp;&amp; U&lt;Argsn&gt;</code></pre>
  
    Here, <code>Args0</code>, <code>Args1</code>, etc. denote elements
    of the template argument pack <code>Args</code> used as part of the
    introduced constraint.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
  
    </section>
  </cxx-section>


  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    

    <section>
      <header><span class="section-number">14.2</span> <h1 data-bookmark-label="14.2 Template names">Template names</h1> <span style="float:right"><a href="#temp.names">[temp.names]</a></span></header>
      
    

    <p para_num="1" id="temp.names.1">Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names">C++ <span title="temp.names">§14.2</span></cxx-ref>/7.</p>

    <p para_num="2" id="temp.names.2">If a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <p></p>

    
    <p para_num="3" id="temp.names.3"></p>
  
    </section>
  </cxx-section> <!-- temp.names -->

  <cxx-section id="temp.arg">
    

    <section>
      <header><span class="section-number">14.3</span> <h1 data-bookmark-label="14.3 Template arguments">Template arguments</h1> <span style="float:right"><a href="#temp.arg">[temp.arg]</a></span></header>
      
    

    <cxx-section id="temp.arg.template">
    

    <section>
      <header><span class="section-number">14.3.1</span> <h1 data-bookmark-label="14.3.1 Template template arguments">Template template arguments</h1> <span style="float:right"><a href="#temp.arg.template">[temp.arg.template]</a></span></header>
      
      

      <p para_num="1" id="temp.arg.template.1">Modify <cxx-ref in="cxx" to="temp.arg.template">C++ <span title="temp.arg.template">§14.3.3</span></cxx-ref>.

      </p><p para_num="2" id="temp.arg.template.2">A <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> matches 
      a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      shall subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool X = has_x&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Y = X&lt;T&gt; &amp;&amp; has_y&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Z = Y&lt;T&gt; &amp;&amp; has_z&lt;T&gt;::value;

template&lt;template&lt;Y&gt; class C&gt;
  class temp { ... };

template&lt;X T&gt; class x;
template&lt;Z T&gt; class z;

temp&lt;x&gt; s1; // OK: X is subsumed by Y
temp&lt;z&gt; s2; // Error: Z subsumes Y</code></pre>
  
      The template <code>x</code> is a valid argument for <code>temp</code>
      because any template arguments satisfying <code>Y</code> will also 
      satisfy <code>X</code>. That is, all uses of <code>x</code> by
      <code>temp</code> should result in well-formed programs. The 
      template <code>y</code> is not valid because some template arguments 
      satisfying <code>Y</code> may not satisfy <code>Z</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.arg.template -->
  
    </section>
  </cxx-section> <!-- tmep.arg -->

  <cxx-section id="temp.decls" number="5">
    

    <section>
      <header><span class="section-number">14.5</span> <h1 data-bookmark-label="14.5 Template declarations">Template declarations</h1> <span style="float:right"><a href="#temp.decls">[temp.decls]</a></span></header>
      
    

    <cxx-section id="temp.class">
    

    <section>
      <header><span class="section-number">14.5.1</span> <h1 data-bookmark-label="14.5.1 Class templates">Class templates</h1> <span style="float:right"><a href="#temp.class">[temp.class]</a></span></header>
      
      

      Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.class">C++ <span title="temp.class">§14.5.1</span></cxx-ref>/3.

      <p para_num="1" id="temp.class.1">When a member of a constrained class template is defined outside of 
      its class template definition, it shall be specified with the
      <cxx-grammarterm><i>template-parameters</i></cxx-grammarterm> and
      associated constraints of the class template.
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Con = ...;

template&lt;typename T&gt; requires Con&lt;T&gt;
  struct S {
    void f();
    void g();
  }

template&lt;typename T&gt; 
  requires Con&lt;T&gt;
    void S&lt;T&gt;::f() { } // Ok: parameters and constraints match

template&lt;typename T&gt;
  void S&lt;T&gt;::g() { } // Error: no declaration of g() in S&lt;T&gt;</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


      <cxx-section id="temp.mem.func">
    

    <section>
      <header><span class="section-number">14.5.1.1</span> <h1 data-bookmark-label="14.5.1.1 Member functions of class templates">Member functions of class templates</h1> <span style="float:right"><a href="#temp.mem.func">[temp.mem.func]</a></span></header>
      
        

        <p para_num="1" id="temp.mem.func.1">Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func">C++ <span title="temp.mem.func">§14.5.1.1</span></cxx-ref>.
        
        </p><p para_num="2" id="temp.mem.func.2">A member function of a class template whose declarator contains a
        <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is a
        <dfn>constrained member function</dfn>.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  class S {
    void f() requires C&lt;T&gt;();
  };</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="3" id="temp.mem.func.3">Constraints on member functions are instantiated as needed
        during overload resolution, not when the class template is
        instantiated
        (<cxx-ref in="cxx" to="temp.inst">C++ <span title="temp.inst">§14.7.1</span></cxx-ref>).
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Constraints on member functions do not affect the declared 
        interface of a class. That is, a constrained copy constructor 
        is still a copy constructor, even if it will not be viable for 
        a specialization of the class template.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>

        <p para_num="4" id="temp.mem.func.4">A constrained member function of a class template may be defined
        outside of its class template definition. Its definition shall be
        specified with the constraints of its declaration.
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Consider possible definitions of the constrained member function 
        <code>S&lt;T&gt;f</code> from above.
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() { }                 // Error: no declaration of f() in S&lt;T&gt;.

template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() requires C&lt;T&gt;() { } // Ok: defines S&lt;T&gt;::f</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

      
    </section>
  </cxx-section> <!-- temp.mem.func -->
    
    </section>
  </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
    

    <section>
      <header><span class="section-number">14.5.2</span> <h1 data-bookmark-label="14.5.2 Member templates">Member templates</h1> <span style="float:right"><a href="#temp.mem">[temp.mem]</a></span></header>
      
      

      <p para_num="1" id="temp.mem.1">Insert the following paragraph after
      <cxx-ref in="cxx" to="temp.mem">C++ <span title="temp.mem">§14.5.2</span></cxx-ref>/1.</p>

      <p para_num="2" id="temp.mem.2">A constrained member template defined outside of its class template 
      definition shall be specified with the
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      and constraints of the class template followed by
      the template parameters and constraints of the member template.
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Foo = ...;
template&lt;typename T&gt; concept bool Bar = ...; // Different than Foo

template&lt;Foo T&gt;
  struct S {
    template&lt;Bar U&gt; void f(U);
    template&lt;Bar U&gt; void g(U);
  };

template&lt;Foo T&gt; template&lt;Bar U&gt; void S&lt;T&gt;::f(U); // Ok
template&lt;Foo T&gt; template&lt;Foo U&gt; void S&lt;T&gt;::g(U); // Error: no g() declared in S</code></pre>
  
      The template constraints in the definition of <code>g</code> do not
      match those in its declaration.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.mem -->


    <cxx-section id="temp.friend" number="4">
    

    <section>
      <header><span class="section-number">14.5.4</span> <h1 data-bookmark-label="14.5.4 Friends">Friends</h1> <span style="float:right"><a href="#temp.friend">[temp.friend]</a></span></header>
      
      

      <p para_num="1" id="temp.friend.1">Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend">C++ <span title="temp.friend">§14.5.4</span></cxx-ref>/9.

      </p><p para_num="2" id="temp.friend.2"> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };</code></pre>
  
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="3" id="temp.friend.3">
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.friend.4">
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="5" id="temp.friend.5">As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    
    </section>
  </cxx-section> <!-- temp.friend -->

    <cxx-section id="temp.class.spec">
    

    <section>
      <header><span class="section-number">14.5.5</span> <h1 data-bookmark-label="14.5.5 Class template partial specialization">Class template partial specialization</h1> <span style="float:right"><a href="#temp.class.spec">[temp.class.spec]</a></span></header>
      
      

      <cxx-section id="temp.class.spec.match">
    

    <section>
      <header><span class="section-number">14.5.5.1</span> <h1 data-bookmark-label="14.5.5.1 Matching of class template partial specializations">Matching of class template partial specializations</h1> <span style="float:right"><a href="#temp.class.spec.match">[temp.class.spec.match]</a></span></header>
      
        

        <p para_num="1" id="temp.class.spec.match.1">Modify 
        <cxx-ref in="cxx" to="temp.class.spec.match">C++ <span title="temp.class.spec.match">§14.5.5.1</span></cxx-ref>/2.</p>

        <p para_num="2" id="temp.class.spec.match.2"> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.</p>

      
    </section>
  </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
    

    <section>
      <header><span class="section-number">14.5.5.2</span> <h1 data-bookmark-label="14.5.5.2 Partial ordering of class template specializations">Partial ordering of class template specializations</h1> <span style="float:right"><a href="#temp.class.order">[temp.class.order]</a></span></header>
      
        

        <p para_num="1" id="temp.class.order.1">Modify 
        <cxx-ref in="cxx" to="temp.class.order">C++ <span title="temp.class.order">§14.5.5.2</span></cxx-ref>/1.</p>

        <p para_num="2" id="temp.class.order.2">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B</code></pre>
  </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      
    </section>
  </cxx-section> <!-- temp.class.order -->
    
    </section>
  </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
    

    <section>
      <header><span class="section-number">14.5.6</span> <h1 data-bookmark-label="14.5.6 Function templates">Function templates</h1> <span style="float:right"><a href="#temp.fct">[temp.fct]</a></span></header>
      
      

      <cxx-section id="temp.over.link">
    

    <section>
      <header><span class="section-number">14.5.6.1</span> <h1 data-bookmark-label="14.5.6.1 Function template overloading">Function template overloading</h1> <span style="float:right"><a href="#temp.over.link">[temp.over.link]</a></span></header>
      
        

        <p para_num="1" id="temp.over.link.1">Modify <cxx-ref in="cxx" to="temp.over.link">C++ <span title="temp.over.link">§14.5.6.1</span></cxx-ref>/6.</p>

        <p para_num="2" id="temp.over.link.2">
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"><a title="temp.deduct" href="#temp.deduct">14.8.2</a></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"="">C++ <span title="">§</span></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"="">C++ <span title="">§</span></cxx-ref>.
        </p>

        <p para_num="3" id="temp.over.link.3">Modify <cxx-ref in="cxx" to="temp.over.link">C++ <span title="temp.over.link">§14.5.6.1</span></cxx-ref>

        </p><p para_num="4" id="temp.over.link.4">
        Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      
    </section>
  </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
    

    <section>
      <header><span class="section-number">14.5.6.2</span> <h1 data-bookmark-label="14.5.6.2 Partial ordering of function templates">Partial ordering of function templates</h1> <span style="float:right"><a href="#temp.func.order">[temp.func.order]</a></span></header>
      
        

        <p para_num="1" id="temp.func.order.1">Modify <cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>/2.</p>

        <p para_num="2" id="temp.func.order.2">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      
    </section>
  </cxx-section> <!-- temp.func.order -->
    
    </section>
  </cxx-section> <!-- temp.fct -->
  
    </section>
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.spec" number="7">
    

    <section>
      <header><span class="section-number">14.7</span> <h1 data-bookmark-label="14.7 Template instantiation and specialization">Template instantiation and specialization</h1> <span style="float:right"><a href="#temp.spec">[temp.spec]</a></span></header>
      
    

    <cxx-section id="temp.inst">
    

    <section>
      <header><span class="section-number">14.7.1</span> <h1 data-bookmark-label="14.7.1 Implicit instantiation">Implicit instantiation</h1> <span style="float:right"><a href="#temp.inst">[temp.inst]</a></span></header>
      
      

      <p para_num="1" id="temp.inst.1">Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.inst">C++ <span title="temp.inst">§14.7.1</span></cxx-ref>/1.</p>

      <p para_num="2" id="temp.inst.2">The implicit instantiation of a class template does not cause
      the instantiation of the associated constraints of constrained member 
      functions.</p>
    
    </section>
  </cxx-section> <!-- temp.inst -->

    <cxx-section id="temp.explicit">
    

    <section>
      <header><span class="section-number">14.7.2</span> <h1 data-bookmark-label="14.7.2 Explicit instantiation">Explicit instantiation</h1> <span style="float:right"><a href="#temp.explicit">[temp.explicit]</a></span></header>
      
      

      <p para_num="1" id="temp.explicit.1">Insert the following paragraph under 
      <cxx-ref in="cxx" to="temp.explicit">C++ <span title="temp.explicit">§14.7.2</span></cxx-ref>.</p>

      <p para_num="2" id="temp.explicit.2">An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); };

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.explicit -->

    <cxx-section id="temp.expl.spec">
    

    <section>
      <header><span class="section-number">14.7.3</span> <h1 data-bookmark-label="14.7.3 Explicit specialization">Explicit specialization</h1> <span style="float:right"><a href="#temp.expl.spec">[temp.expl.spec]</a></span></header>
      
      

      <p para_num="1" id="temp.expl.spec.1">Insert the following paragraphs under 
      <cxx-ref in="cxx" to="temp.expl.spec">C++ <span title="temp.expl.spec">§14.7.3</span></cxx-ref>.</p>

      <p para_num="2" id="temp.expl.spec.2">A constrained template declaration or constrained member function
      of a class template can be declared by a declaration
      introduced by <code>template&lt;&gt;</code>.</p>

      <p para_num="3" id="temp.expl.spec.3">The <cxx-grammarterm><i>template arguments</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> that
      names an explicit specialization of a constrained template
      declaration must satisfy that template's associated constraints
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <code>C</code> is the type concept defined in the previous
      section.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt;
  struct S1 { };

struct X { void c(); }

template&lt;&gt; S1&lt;X&gt; { };   // OK: X satisfies C
template&lt;&gt; S1&lt;int&gt; { }; // Error: int does not satisfy C</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.expl.spec.4">An explicit specialization of a constrained member function
      (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>) shall not include a
      a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S2 { 
    void f(T) requires C&lt;T&gt;;
  };

template&lt;&gt; void S2&lt;X&gt;::f(T a) { }               // OK
template&lt;&gt; void S2&lt;X&gt;::f(T a) requires C&lt;X&gt; { } // Error: extra requires-clause</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.expl.spec -->
  
    </section>
  </cxx-section> <!-- temp.spec -->


  <cxx-section id="temp.fct.spec" number="8">
    

    <section>
      <header><span class="section-number">14.8</span> <h1 data-bookmark-label="14.8 Function template specialization">Function template specialization</h1> <span style="float:right"><a href="#temp.fct.spec">[temp.fct.spec]</a></span></header>
      
    

    <cxx-section id="temp.deduct" number="2">
    

    <section>
      <header><span class="section-number">14.8.2</span> <h1 data-bookmark-label="14.8.2 Template argument deduction">Template argument deduction</h1> <span style="float:right"><a href="#temp.deduct">[temp.deduct]</a></span></header>
      
      

      After <cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>/5, add the following
      paragraph:

      <!-- TODO: Rewrite in terms of satisfaction. -->
      <p para_num="6" id="temp.deduct.6" number="6"> If the template has associated constraints, the template 
      arguments are substituted into those associated constraints and evaluated.
      If the substitution results in an invalid type or expression, or
      if the associated constraints evaluate to <code>false</code>,
      type deduction fails.</p>

    
    </section>
  </cxx-section> <!-- temp.deduct -->

  
    </section>
  </cxx-section>


  <cxx-section id="temp.constr">
    

    <section>
      <header><span class="section-number">14.9</span> <h1 data-bookmark-label="14.9 Template constraints">Template constraints</h1> <span style="float:right"><a href="#temp.constr">[temp.constr]</a></span></header>
      
    

    <p para_num="1" id="temp.constr.1">Add this as a new section under 
    <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>.</p>


    <p para_num="2" id="temp.constr.2">Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    constraint-expression:
  </bnf-rule>
        <bnf-alt>
    
    logical-or-expression
  </bnf-alt>
    
  </bnf-grammar>

    </p><p para_num="3" id="temp.constr.3">A <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> is a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    </p><ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="4" id="temp.constr.4">A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
    is required is ill-formed.</p>

    <p para_num="5" id="temp.constr.5">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P &amp;&amp; Q
P || (Q &amp;&amp; R)
M == N              // only if the result type is bool
has_trait&lt;T&gt;::value // only if value is a bool member
M &lt; N               // only if the result type is bool
M + N &gt;= 0
P || !(M &lt; N)
true
false</code></pre>
  
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="6" id="temp.constr.6">A subexpression of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept"></a></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this section.</p>

    <p para_num="7" id="temp.constr.7">Certain subexpressions of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    </p><ul>
    <li>a <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm><i>logical-and-expression</i></cxx-grammarterm> of the form
        <code>P &amp;&amp; Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>has_trait&lt;T&gt;::value
M &lt; N
M + N &gt;= 0
true
false</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    A concept check is not an atomic expression.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="8" id="temp.constr.8">Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="9" id="temp.constr.9">A concept check that calls a 
function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable 
concepts is simplified by substituting the template arguments into the 
variable's initializer. </p>

    <p para_num="10" id="temp.constr.10">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s its 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Certain atomic constraints introduced by a 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>
 
    <p para_num="11" id="temp.constr.11">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>P</code> and Q be variable templates
    that are atomic constraints.
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();</code></pre>
  
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
    
    <pre><code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p para_num="12" id="temp.constr.12">A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p para_num="13" id="temp.constr.13">
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p para_num="14" id="temp.constr.14">Two <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  
    </section>
  </cxx-section> <!-- temp.constr -->


    </section>
  </cxx-clause> <!-- temp -->






</body></html>