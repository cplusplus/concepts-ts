<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concepts-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-EDNOTE");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-NOTE");document.createElement("CXX-GRAMMARTERM");document.createElement("BNF-GRAMMAR");document.createElement("BNF-RULE");document.createElement("BNF-ALT");document.createElement("CXX-GRAMMARTER");document.createElement("CXX-EXAMPLE");document.createElement("CXX-CODEBLOCK");document.createElement("BNF-TERMINAL");document.createElement("BNF-OPT");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

@media print {
cxx-titlepage {
	height: 8.8in;
}


}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  
  <style>
del.local {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}
del.local > * {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}

ins.local {
  color: Black;
  text-decoration: underline;
  background-color: LightSteelBlue; 
}
ins.local > * {
  color: Black;
  text-decoration: under;
  background-color: LightSteelBlue; 
}

p.quoted {
  margin-left: .25in;
}
</style>
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 10pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: string(current-section, last); font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {height: 100%}
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>C++ Extensions for Concepts, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>NXXX</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-07-15</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4040.pdf">N4040</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Andrew Sutton<br>
    University of Akron<br>
    <cxx-email><a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, C++ Extensions for Concepts</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#intro">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#intro.refs">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#intro.defns">Terms and definitions</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#intro.compliance">Implementation compliance</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#intro.ack">Acknowledgments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#lex">Lexical conventions</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#lex.key">Keywords</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#expr">Expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#expr.prim">Primary expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.2</span><a href="#expr.prim.lambda">Lambda expressions</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#expr.req">Requires expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.3.1</span><a href="#expr.req.simple">Simple requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.2</span><a href="#expr.req.type">Type requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.3</span><a href="#expr.req.nested">Nested requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.4</span><a href="#expr.req.compound">Compound requirements</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#dcl.dcl">Declarations</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#dcl.spec">Specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6</span><a href="#dcl.type">Type specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6.2</span><a href="#dcl.type.simple">Simple type specifiers</a>
        
      </li>
            
              <li><span class="marker">7.1.6.4</span><a href="#dcl.spec.auto">auto specifier</a>
        
      </li>
            
              <li><span class="marker">7.1.6.5</span><a href="#dcl.spec.constr">Constrained type specifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.1.7</span><a href="#dcl.concept">concept specifier</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#dcl.decl">Declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3</span><a href="#dcl.meaning">Meaning of declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3.5</span><a href="#dcl.fct">Functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8.4</span><a href="#dcl.fct.def">Function definitions</a>
        
          <ol>
            
              <li><span class="marker">8.4.1</span><a href="#dcl.fct.def.general">In general</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">9</span><a href="#class">Classes</a>
        
          <ol>
            
              <li><span class="marker">9.2</span><a href="#class.mem">Class members</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#temp">Templates</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#temp.param">Template parameters</a>
        
      </li>
            
              <li><span class="marker">14.2</span><a href="#temp.names">Template names</a>
        
      </li>
            
              <li><span class="marker">14.3</span><a href="#temp.arg">Template arguments</a>
        
          <ol>
            
              <li><span class="marker">14.3.1</span><a href="#temp.arg.template">Template template arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5</span><a href="#temp.decls">Template declarations</a>
        
          <ol>
            
              <li><span class="marker">14.5.1</span><a href="#temp.class">Class templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.1.1</span><a href="#temp.mem.func">Member functions of class templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.2</span><a href="#temp.mem">Member templates</a>
        
      </li>
            
              <li><span class="marker">14.5.4</span><a href="#temp.friend">Friends</a>
        
      </li>
            
              <li><span class="marker">14.5.5</span><a href="#temp.class.spec">Class template partial specialization</a>
        
          <ol>
            
              <li><span class="marker">14.5.5.1</span><a href="#temp.class.spec.match">Matching of class template partial specializations</a>
        
      </li>
            
              <li><span class="marker">14.5.5.2</span><a href="#temp.class.order">Partial ordering of class template specializations</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.6</span><a href="#temp.fct">Function templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.6.1</span><a href="#temp.over.link">Function template overloading</a>
        
      </li>
            
              <li><span class="marker">14.5.6.2</span><a href="#temp.func.order">Partial ordering of function templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.7</span><a href="#temp.spec">Template instantiation and specialization</a>
        
          <ol>
            
              <li><span class="marker">14.7.1</span><a href="#temp.inst">Implicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.2</span><a href="#temp.explicit">Explicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.3</span><a href="#temp.expl.spec">Explicit specialization</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.8</span><a href="#temp.fct.spec">Function template specialization</a>
        
          <ol>
            
              <li><span class="marker">14.8.2</span><a href="#temp.deduct">Template argument deduction</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9</span><a href="#temp.constr">Template constraints</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="intro">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#intro">[intro]</a></span></header>
      
  


  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++ 
    Programming language (<cxx-ref to="intro.refs"><a title="intro.refs" href="#intro.refs">1.2</a></cxx-ref>) that
    enable the specification and checking of constraints on template 
    arguments, and the ability to overload functions and specialize
    templates based on those constraints. These extensions include 
    new syntactic forms and modifications to existing language semantics.</p>

    <p para_num="2" id="general.scope.2">International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document as 
    written as a set of changes against that specification. Instructions
    to modify or add paragraphs are written as explicit instructions. 
    Modifications made directly to existing text from the International
    Standard use <ins>underlining</ins> to represent added text and
    <del>strikethrough</del> to represent deleted text.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.refs">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#intro.refs">[intro.refs]</a></span></header>
      
    

    <cxx-ednote>
    
    <aside><strong>Editor's note:</strong> The TS will formally refer to the ISO/IEC document
    defining the C++14 programming language. Until that document is
    published, the paper targets the current working draft
    NXXX</aside>
  </cxx-ednote>

    <p para_num="1" id="intro.refs.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC 1482:2014, <cite>Programming Languages - C++</cite>
      </li>
    </ul>

    <p para_num="2" id="intro.refs.2">ISO/IEC 1482:2014 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++
    §3.2".</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.defns">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Terms and definitions">Terms and definitions</h1> <span style="float:right"><a href="#intro.defns">[intro.defns]</a></span></header>
      
    

    <p para_num="1" id="intro.defns.1">For the purposes of this document, the terms and definitions
    given in the C++ Standard and the following apply.</p>

    <dl is="cxx-definition-section">
    

    
<!-- FIXME: Formatting for multiple definitions is broken. 

      <dt id="atomic.defns.atomic-constraint">atomic constraint</dt>
      <dd> A subexpression of a constraint that is not a 
      <cxx-grammarterm>logical-and-expression</cxx-grammarterm>,
      <cxx-grammarterm>logical-or-expression</cxx-grammarterm>,
      or a subexpression of an atomic constraint. </dd>

      <dt id="atomic.defns.associated-constraint">associated constraint</dt>
      <dd>A conjunction of all constraints on a constrained template 
        declaration that includes constraints on template parameters, 
        constraints on function parameters, and constraints specified 
        explicitly in a <cxx-grammarterm>requires-clause</cxx-grammarterm>.</dd>
 
      <dt id="atomic.defns.concept">concept</dt>
      <dd>A template declared with the <code>concept</code> declaration 
      specifier.</dd>

      <dt id="atomic.defns.concept-check">concept check</dt>
      <dd>A call to a function concept or a 
      <cxx-grammarterm>template-id</cxx-grammarterm> that names a variable 
      concept.</dd>

      <dt id="atomic.defns.constraint">constraint</dt>
      <dd>A constant expression with type <code>bool</code> that evaluates 
      properties of template arguments, determining whether or not they 
      can be substituted into a template.</dd>

      <dt id="atomic.defns.constrained-declaration">constrained-declaration</dt>
      <dd>A declaration with associated constraints.</dd>

      <dt id="atomic.defns.generic-function">generic function</dt>
      <dd>A constant expression that evaluates requirements of a template 
      argument.</dd>

      <dt id="atomic.defns.introdduced-parameters">introduced parameters</dt>
      <dd>A function declaration having <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name<cxx-grammarterm> in the type 
      specifier any of its parameters.</dd>
 -->
    
  </dl>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.compliance">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Implementation compliance">Implementation compliance</h1> <span style="float:right"><a href="#intro.compliance">[intro.compliance]</a></span></header>
      
    
    <p para_num="1" id="intro.compliance.1">Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance">C++ <span title="intro.compliance">§1.4</span></cxx-ref>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Conformance is defined in terms of the behavior of
    programs.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.ack">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Acknowledgments">Acknowledgments</h1> <span style="float:right"><a href="#intro.ack">[intro.ack]</a></span></header>
      
    
  
    <p para_num="1" id="intro.ack.1">The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ standard library, known 
    as ``The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p para_num="2" id="intro.ack.2">This work was funded by NSF grant ACI-1148461.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>


<cxx-clause id="lex">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Lexical conventions">Lexical conventions</h1> <span style="float:right"><a href="#lex">[lex]</a></span></header>
      
  

  <cxx-section id="lex.key" <="" cxx-section="">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Keywords">Keywords</h1> <span style="float:right"><a href="#lex.key">[lex.key]</a></span></header>
      
    

    <p para_num="1" id="lex.key.1">In <cxx-ref in="cxx" to="lex.key">C++ <span title="lex.key">§2.12</span></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.</p>

  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="expr" number="5">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Expressions">Expressions</h1> <span style="float:right"><a href="#expr">[expr]</a></span></header>
      
  

  <cxx-section id="expr.prim">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Primary expressions">Primary expressions</h1> <span style="float:right"><a href="#expr.prim">[expr.prim]</a></span></header>
      
    

    <p para_num="1" id="expr.prim.1">In <cxx-ref in="cxx" to="expr.prim.general">C++ <span title="expr.prim.general">§5.1.1</span></cxx-ref>, add
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> to the
    rule, <cxx-grammarterm><i>primary-expression</i></cxx-grammarterm>.</p>
    
    <bnf-grammar>
    
    
      <bnf-rule>
    
    primary-expression:
  </bnf-rule>
        <ins><bnf-alt>
    
    requires-expression
  </bnf-alt></ins>
    
  </bnf-grammar>

    <cxx-section id="expr.prim.lambda" number="2">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Lambda expressions">Lambda expressions</h1> <span style="float:right"><a href="#expr.prim.lambda">[expr.prim.lambda]</a></span></header>
      
      

      Modify <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5.

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      The closure type 
      <del>for a non-generic</del>
      <ins>for a</ins>
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call">C++ <span title="over.call">§13.5.4</span></cxx-ref>)
      whose parameters and return type are described by the lambda-expression’s 
      parameter-declaration-clause and trailing-return-type respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"><a title="temp.mem" href="#temp.mem">14.5.2</a></cxx-ref>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarter>template-parameter</cxx-grammarter> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration declares</i></cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      If the <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> is a
      generic lambda, the closure type's function call operator is an
      abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </ins>
      </p>
<!-- 
      <p>The closure type for a non-generic
      <cxx-grammarterm>lambda-expression</cxx-grammarterm> has a public
      <code>inline</code> function call operator 
      (<cxx-ref in="cxx" to="over.over"></cxx-ref>) whose parameters 
      and return type 
      are described by the <cxx-grammarterm>lambda-expression</cxx-grammarterm>'s 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> and 
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
      respectively. 
      
      For a generic lambda, the closure type has a public inline function call 
      operator member template (<cxx-ref in="cxx" to="temp.mem"></cxx-ref>) 
      whose <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
      consists of one invented type 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> for each 
      occurrence of <code>auto</code> <ins>or each unique occurrence of a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm></ins>
      in the lambda's 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 

      The invented type <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      is a parameter pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      declares a function parameter pack 
      (<cxx-ref in="cxx" to="dcl.fct"></cxx-ref>). 
      
      If the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of the 
      corresponding <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
      includes a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      the invented type parameter is a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, whose
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> matches
      that of the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>.
      (<cxx-ref to="temp.param"></cxx-ref>).</ins>
      
      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm>lambda-expression</cxx-grammarterm>'s 
      <cxx-grammarterm>trailing-return-type</cxx-grammarterm> and 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
      by replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm>decl-specifiers</cxx-grammarterm> of the
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> with the 
      name of the corresponding invented 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>.  -->

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda">C++ <span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5.

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      <ins>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      Consider the following:
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>template&lt;typename T&gt; concept bool C = true;

auto gl = [](C&amp; a, C* b) { a = *b } // OK: denotes a generic lambda

struct Fun {
    auto operator()(C&amp; a, C* b) const { a = *b; }
} fun;</code></pre>
  
      <code>C</code> is a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda, <code>gl</code>, 
      and the function object, <code>fun</code>, have equivalent behavior when 
      called with the same arguments.
      <cxx-codeblock>
    
    <pre><code></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      
      <p></p>


      <!-- TODO: This moves into dcl.fct -->
      <!--
      <p> All placeholder types introduced using the same 
      <cxx-grammarterm>concept-name</cxx-grammarterm> have the same invented
      template parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
auto f = [](C a, C b) { };
f(0, 0);   // Ok
f(0, 'a'); // Error: template argument deduction failure
      </cxx-codeblock>
      The second call to <code>f</code> results in a compiler error because
      the types of the deduced arguments cannot be unified.
      </cxx-example>
      </p>
      -->

    
    </section>
  </cxx-section> <!-- expr.prim.lambda -->


  <cxx-section id="expr.req">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Requires expressions">Requires expressions</h1> <span style="float:right"><a href="#expr.req">[expr.req]</a></span></header>
      
    

    <p para_num="1" id="expr.req.1">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    requires-expression:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> 
          requirement-parameter-list requirement-body
  </bnf-alt>

    <bnf-rule>
    
    requirement-parameter-list:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>(</code></bnf-terminal> 
        <bnf-opt>parameter-declaration-clause<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>)</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-body:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>{</code></bnf-terminal> 
        requirement-list 
        <bnf-terminal><code>}</code></bnf-terminal> 
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-list:
  </bnf-rule>
      <bnf-alt>
    
    requirement
  </bnf-alt>
      <bnf-alt>
    
    requirement-list requirement
  </bnf-alt>

    <bnf-rule>
    
    requirement:
  </bnf-rule>
      <bnf-alt>
    
    simple-requirement
  </bnf-alt>
      <bnf-alt>
    
    compound-requirement
  </bnf-alt>
      <bnf-alt>
    
    type-requirement
  </bnf-alt>
      <bnf-alt>
    
    nested-requirement
  </bnf-alt>

    <bnf-rule>
    
    simple-requirement:
  </bnf-rule>
      <bnf-alt>
    
    expression <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>

    <bnf-rule>
    
    compound-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-opt><bnf-terminal><code>constexpr</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-terminal><code>{</code></bnf-terminal> expression <bnf-terminal><code>}</code></bnf-terminal>
        <bnf-opt><bnf-terminal><code>noexcept</code></bnf-terminal><sub>opt</sub></bnf-opt>
        <bnf-opt>trailing-return-type<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    type-requirement:
  </bnf-rule>
      <bnf-alt>
    
    
        typename-specifier <bnf-terminal><code>;</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    nested-requirement:
  </bnf-rule>
      <bnf-alt>
    
    requires-clause <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
    
  </bnf-grammar>
    </p>

    <p para_num="2" id="expr.req.2">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> has type
    <code>bool</code>. </p>

    <p para_num="3" id="expr.req.3">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> shall not appear
    outside of a concept definition (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept">7.1.7</a></cxx-ref>) or a
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>. </p>

    <p para_num="4" id="expr.req.4">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    The most common use of 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s is to define
    syntactic requirements in concepts (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept">7.1.7</a></cxx-ref>) 
    such as the one below:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -&gt; const A&lt;T&gt;&amp;;
    };
  }</code></pre>
  
    The concept is defined in terms of the syntactic and type requirements 
    within the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
    
    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> can also be
    used in a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="5" id="expr.req.5">The <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> may introduce
    local arguments via a <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>. 
    These parameters have no linkage, storage, or lifetime.
    They are used only to write constraints within the
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> and are not visible
    outside the closing <code>}</code> of the 
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm>. 
    The <cxx-grammarterm><i>requirement-parameter-list</i></cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p para_num="6" id="expr.req.6">The <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> is a sequence of
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s separated by semicolons.
     These <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s may refer to local 
    arguments, template parameters, and any other declarations visible from the 
    enclosing context. Each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> 
    introduces a conjunction of one or more atomic constraints 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>). The kinds of atomic constraints
    introduced by a <cxx-grammarterm><i>requirement</i></cxx-grammarterm> are:
    </p><ul>
    <li>A <dfn>valid expression constraint</dfn> is a predicate on an
    expression. The constraint is satisfied if and only if the substitution of 
    template arguments into that expression does not result in substitution 
    failure. The result of successfully substituting template arguments
    into the dependent expression produces a <dfn>valid expression</dfn>.</li>

    <li>A <dfn>valid type constraint</dfn> is a predicate on a type.
    The constraint is satisfied if and only if the substitution of template
    arguments into that type does not result in substitution failure. The
    result of successfully substituting template arguments into the dependent
    type produces an <dfn>associated type</dfn>.</li>

    <li>A <dfn>result type constraint</dfn> is a predicate on the result type
    of a valid expression. Let <code>E</code> be a valid expression and 
    <code>X</code> be a <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>.

    The constraint is satisfied if and only if <code>E</code> can be used as an 
    argument to an invented function <code>f</code>, which has a single function
    parameter of type <code>X</code> and returning <code>void</code>. That is,
    the function call <code>f(E)</code> must be a valid expression.
    
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Each template parameter referred to by <code>X</code> is a template
    parameter of the invented function <code>f</code>. If <code>X</code>
    contains a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
    or <code>auto</code> specifier, then <code>f</code> is a generic function
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </li>

    <li>A <dfn>constant expression constraint</dfn> is satisfied if and only
    if a valid expression <code>E</code> is a constant expression 
    (<cxx-ref in="cxx" to="expr.const">C++ <span title="expr.const">§5.19</span></cxx-ref>).
    </li>

    <li>An <dfn>exception constraint</dfn> is satisfied if and only if, for
    a valid expression <code>E</code>, the expression <code>noexcept(E)</code>
    evaluates to <code>true</code>
    (<cxx-ref in="cxx" to="expr.unary.noexcept">C++ <span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>).
    </li>
    </ul>
    <!-- </p> -->

    <p para_num="7" id="expr.req.7">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> evaluates to
    <code>true</code> if and only the atomic constraints introduced by
    each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> in the 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm> are satisfied
    and <code>false</code> otherwise. The semantics of each kind of 
    requirement are described in the following sections.</p>

    <cxx-section id="expr.req.simple">
    

    <section>
      <header><span class="section-number">5.1.3.1</span> <h1 data-bookmark-label="5.1.3.1 Simple requirements">Simple requirements</h1> <span style="float:right"><a href="#expr.req.simple">[expr.req.simple]</a></span></header>
      
      
      <p para_num="1" id="expr.req.simple.1">A <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> introduces a
      valid expression constraint for its 
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>. The expression is an
      unevaluated operand (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      The following is requirement evaluates to <code>true</code> for all 
      arithmetic types (<cxx-ref in="cxx" to="basic.fundamental">C++ <span title="basic.fundamental">§3.9.1</span></cxx-ref>),
      and <code>false</code> for pointer types 
      (<cxx-ref in="cxx" to="basic.compound">C++ <span title="basic.compound">§3.9.2</span></cxx-ref>).
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires (T a, T b) {
  a + b;  // A simple requirement
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.simple.2">If the expression would always result in a substitution failure, 
      the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  new T[-1];  // error: the valid expression well never be well-formed.
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.simple -->


    <cxx-section id="expr.req.type">
    

    <section>
      <header><span class="section-number">5.1.3.2</span> <h1 data-bookmark-label="5.1.3.2 Type requirements">Type requirements</h1> <span style="float:right"><a href="#expr.req.type">[expr.req.type]</a></span></header>
      
      
      <p para_num="1" id="expr.req.type.1">A <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> introduces 
      valid type constraint for its 
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm>.
      
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A type requirement requests the validity of an associated
      type, either as a nested type name, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm><i>type-specifiers</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename T::inner;         // Required nested type name
  typename Related&lt;T&gt;; // Required alias
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.req.type.2">If the required type will always results in a substitution failure,
      then the program is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename int::X;  // error: int does not have class type
  typename T[-1];   // error: array types cannot have negative extent
}</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.type -->


    <cxx-section id="expr.req.nested">
    

    <section>
      <header><span class="section-number">5.1.3.3</span> <h1 data-bookmark-label="5.1.3.3 Nested requirements">Nested requirements</h1> <span style="float:right"><a href="#expr.req.nested">[expr.req.nested]</a></span></header>
      
      
      <p para_num="1" id="expr.req.nested.1">A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> introduces
      an additional constraint expression <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref> 
      to be evaluated as part of the satisfaction of the 
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>. 
      The requirement is satisfied if and only if the constraint evaluates to
      value <code>true</code>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
     
      Nested requirements are generally used to provide additional constraints on 
      associated types
      within a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>requires () {
  typename X<t>;
  requires C&lt;X&lt;T&gt;&gt;();
}
      </t></code></pre>
  
      These requirements are satisfied only when substitution into 
      <code>X&lt;T&gt;</code> is successful and when 
      <code>C&lt;X&lt;T&gt;&gt;()</code> evaluates to <code>true</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.re.nested -->



    <cxx-section id="expr.req.compound">
    

    <section>
      <header><span class="section-number">5.1.3.4</span> <h1 data-bookmark-label="5.1.3.4 Compound requirements">Compound requirements</h1> <span style="float:right"><a href="#expr.req.compound">[expr.req.compound]</a></span></header>
      
      
      <p para_num="1" id="expr.req.compound.1">A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces 
      a conjunction of one or more constraints pertaining to its
      <cxx-grammarterm><i>expression</i></cxx-grammarterm>, depending on the syntax
      used. This set includes:
      </p><ul>
      <li>a valid expression constraint,</li>
      <li>an optional associated type constraint</li>
      <li>an optional result type constraint,</li>
      <li>an optional constant expression constraint, and </li>
      <li>an optional an exception constraint.</li>
      </ul>
      A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> is
      satisfied if and only if every constraint in the set is satisfied.
      
      <!-- BUG: There is a core issue on this -->
      The required valid expression is an unevaluated operand
      (<cxx-ref in="cxx" to="basic.def.odr">C++ <span title="basic.def.odr">§3.2</span></cxx-ref>)
      except in the case when the <code>constexpr</code> specifier is present.
      These other requirements are described in the following paragraphs.
      <!-- </p> -->

      <p para_num="2" id="expr.req.compound.2">The brace-enclosed <cxx-grammarterm><i>expression</i></cxx-grammarterm> in
      a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces
      a valid expression constraint. Let <code>E</code> be the valid expression
      resulting from successful substitution.

      </p><p para_num="3" id="expr.req.compound.3">The presence of a
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> introduces 
      a result type constraint on <code>E</code>.</p>

      <p para_num="4" id="expr.req.compound.4">If the <code>constexpr</code> specifier is present then a constant 
      expression constraint is introduced for the valid expression 
      <code>E</code>.</p>

      <p para_num="5" id="expr.req.compound.5">If the <code>noexcept</code> specifier is present, then an
      exception constraint is introduced for the valid expression
      <code>E</code>.</p>

      <p para_num="6" id="expr.req.compound.6">
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename I&gt;
  concept bool Inscrutible() { ... }

requires(T x) {
  {x++}; #1
  {*x} -&gt; typename T::r; #2
  {f(x)} -&gt; const Inscrutible&amp; #3
  {g(x)} noexcept -&gt; auto&amp; #4
  constexpr {T::value}; #5
  constexpr {T() + T()} -&gt; T #6;
}</code></pre>
  
      Each of these requirements introduces a valid expression constraint
      on the expression in its enclosing braces.

      Requirement #1 introduces no additional constraints. It is equivalent to 
      a <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> containing the 
      same expression.
      
      Requirement #2 <code>*x</code> introduces a result type constraint
      though its <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
      <code>typename T::r</code>. The required valid expression <code>*x</code> 
      must be usable as an argument to the invented function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt; 
  void z1(typename T::r);</code></pre>
  </cxx-codeblock>

      Requirement #3 also introduces a result type constraint on its required
      valid expression <code>f(x)</code>. This expression must be usable as
      an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z2(const Instrutible&amp;)</code></pre>
  </cxx-codeblock>
      
      Requirement #4 introduces a result type constraint and an exception 
      constraint. The required valid expression <code>g(x)</code> must
      be usable as as an argument to the invented generic function:
      <cxx-codeblock>
    
    <pre><code>void z3(auto&amp;);</code></pre>
  </cxx-codeblock>
      Additionally, <code>g(x)</code> must not propagate exceptions.

      Requirement #5 introduces a constant expression constraint:
      <code>T::value</code> must be a constant expression. 

      The requirement in #6 introduces a result type constraint and a constant 
      expression constraint. The required valid expression 
      <code>T() + T()</code> must be usable as an argument to the invented 
      function:
      <cxx-codeblock>
    
    <pre><code>template&lt;class T&gt;
  void z4(T);</code></pre>
  </cxx-codeblock>
      The valid expression must also be a constant expression.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- expr.req.compound -->
 
  
    </section>
  </cxx-section> <!-- expr.req -->

    </section>
  </cxx-section>
    </section>
  </cxx-clause> <!-- expr -->

<cxx-clause id="dcl.dcl" number="7">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Declarations">Declarations</h1> <span style="float:right"><a href="#dcl.dcl">[dcl.dcl]</a></span></header>
      
  

  <cxx-section id="dcl.spec">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Specifiers">Specifiers</h1> <span style="float:right"><a href="#dcl.spec">[dcl.spec]</a></span></header>
      
    

    Extend the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p para_num="1" id="dcl.spec.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    decl-specifier:
  </bnf-rule>
        <ins><bnf-alt>
    
    <bnf-terminal><code>concept</code></bnf-terminal>
  </bnf-alt></ins>
    
  </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
    

    <section>
      <header><span class="section-number">7.1.6</span> <h1 data-bookmark-label="7.1.6 Type specifiers">Type specifiers</h1> <span style="float:right"><a href="#dcl.type">[dcl.type]</a></span></header>
      
      

      <cxx-section id="dcl.type.simple" number="2">
    

    <section>
      <header><span class="section-number">7.1.6.2</span> <h1 data-bookmark-label="7.1.6.2 Simple type specifiers">Simple type specifiers</h1> <span style="float:right"><a href="#dcl.type.simple">[dcl.type.simple]</a></span></header>
      
        
        
        Add <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        to the grammar for <cxx-grammarterm><i>simple-type-specifier</i></cxx-grammarterm>s
        in <cxx-ref in="cxx" to="dcl.type.simple">C++ <span title="dcl.type.simple">§7.1.6.2</span></cxx-ref>.

        <p para_num="1" id="dcl.type.simple.1" class="quoted">
        <bnf-grammar>
    
    
          <bnf-rule>
    
    simple-type-specifier:
  </bnf-rule>
            <ins><bnf-alt>
    
    constrained-type-specifier
  </bnf-alt></ins>

          <ins>
          <bnf-rule>
    
    constrained-type-specifier:
  </bnf-rule>
            <bnf-alt>
    
    
              <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> constrained-type-name
            
  </bnf-alt>

          <bnf-rule>
    
    constrained-type-name:
  </bnf-rule>
            <bnf-alt>
    
    concept-name
  </bnf-alt>
            <bnf-alt>
    
    partial-concept-id
  </bnf-alt>

          <bnf-rule>
    
    concept-name:
  </bnf-rule>
            <bnf-alt>
    
    identifier
  </bnf-alt>

          <bnf-rule>
    
    partial-concept-id:
  </bnf-rule>
            <bnf-alt>
    
    
              concept-name 
              <bnf-terminal><code>&lt;</code></bnf-terminal> 
              template-argument-list
              <bnf-terminal><code>&gt;</code></bnf-terminal>
            
  </bnf-alt>
          </ins>
        
  </bnf-grammar>
        </p>
      
    </section>
  </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
    

    <section>
      <header><span class="section-number">7.1.6.4</span> <h1 data-bookmark-label="7.1.6.4 auto specifier"><code>auto</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.auto">[dcl.spec.auto]</a></span></header>
      
        

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/1 as
        follows:

        <p para_num="1" id="dcl.spec.auto.1" number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins>, or
        that a function is an abbreviated function</ins>.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3 as follows:

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of</del>
        <ins>in the type of</ins>
        a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>
        <ins>or function declaration</ins>, <del>the</del><ins>that</ins> lambda 
        is a <dfn>generic lambda</dfn> (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>)<ins>, or 
        that function is an <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>)</ins>.

        <ins>
        The use of the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        is valid only when the type of that parameter has one of the
        following forms:
        <cxx-codeblock>
    
    </cxx-codeblock></ins></p><pre><code>auto
<i>cv-list</i> auto
auto*
auto&amp;
auto&amp;&amp;
auto[<i>integer-constant</i>]
<i>template-name</i>&lt;auto&gt; (where <i>template-name</i> refers to a class template)
<i>type</i>(auto)
auto()
auto <i>type</i>::*
<i>type</i> auto::*
auto (<i>type</i>::*)()
<i>type</i> (auto::*)()
<i>type</i> (<i>type</i>::*)(auto)</code></pre>
  

        where <code>(auto)</code> represents a 
        <cxx-grammarterm><i>parameter-type-list</i></cxx-grammarterm>
        where at least one parameter type contains an <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, and 
        <cxx-grammarterm><i>()</i></cxx-grammarterm> represents a
        <cxx-grammarterm><i>parameter-type-list</i></cxx-grammarterm> where no 
        parameter type contains an <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>. 

        Similarly, <code>&lt;T&gt;</code> represents template argument
        lists where at least one argument contains an
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>.

        The <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        shall not appear in a non-deduced context
        (<cxx-ref in="cxx" to="temp.deduct.type">C++ <span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>).

        <!-- TODO: Say something more informative here? -->
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The forms of types in which the 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        can appear are a subset of those forms from which a
        template type argument can be deduced. 
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        <p></p>

        Add the following example to <cxx-ref in="cxx" to="dcl.spec.auto">C++ <span title="dcl.spec.auto">§7.1.6.4</span></cxx-ref>/3:

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, int N&gt; class Array { };
template&lt;typename T, typename U&gt; class Pair { };
template&lt;int N&gt; class Num { };

void f1(auto&amp;, auto);                     // <i>OK: an abbreviated function</i>
auto f2 = [](void (*)(auto)){};           // <i>OK: a generic lambda</i>
void f3(auto (*)(int));                   // <i>OK: an abbreviated function</i>
void f4(Vec&lt;auto&gt;&amp;);                      // <i>OK: an abbreviated function</i>
void f5(Pair&lt;const auto&amp;, auto*&gt;);        // <i>OK: an abbreviated function</i>
template&lt;int N&gt; void f6(Array&lt;auto, N&gt;*); // <i>OK: an abbreviated function template</i>
void f7(auto::Vec&lt;int&gt;);                  // <i>error: auto used in a non-deduced context</i>
void f8(Num&lt;sizeof(auto)&gt;);               // <i>error: auto used in a non-deduced context</i>
void f9(auto x = auto());                 // <i>error: auto used in default argument</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

      
    </section>
  </cxx-section> <!-- dcl.spec.auto -->



        <!-- TODO: Rewrite this section so that it reflects and refers
             to dcl.spec.auto. In particular, we want to say where these
             are allowed, how their placeholder types are deduced, and
             what constraint is introduced. -->
      <cxx-section id="dcl.spec.constr">
    

    <section>
      <header><span class="section-number">7.1.6.5</span> <h1 data-bookmark-label="7.1.6.5 Constrained type specifiers">Constrained type specifiers</h1> <span style="float:right"><a href="#dcl.spec.constr">[dcl.spec.constr]</a></span></header>
      
        

        <p para_num="1" id="dcl.spec.constr.1">A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from a required valid expression in a
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>. A
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is also 
        used to signify that a lambda is a generic lambda or that a function 
        is a generic function. </p>

        <p para_num="2" id="dcl.spec.constr.2">A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        can appear in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> or in
        any context in which the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> appears, except:
        </p><ul>
          <li>in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
          a variable declaration,</li>
          <li>in the return type of a function declaration,</li>
          <li>in the <code>decltype(auto)</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, or</li>
          <li>a <cxx-grammarterm><i>conversion-function-id</i></cxx-grammarterm>.</li>
        </ul> <!-- </p> -->

        <p para_num="3" id="dcl.spec.constr.3">If the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> 
        appears as one of the <cxx-grammarterm><i>decl-specifiers</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in
        a <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>, then the
        declared parameter is a 
        <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>, and its
        meaning is defined in section <cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>.
        Otherwise, the meaning of 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s is
        defined in this section.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    A constrained template parameter can introduce type parameters
        as well as designate the type of a non-type template parameter. The
        meaning of those declarations are specified separately.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>

        <p para_num="4" id="dcl.spec.constr.4">If the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears as one of the <cxx-grammarterm><i>decl-specifiers</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> 
        in either a <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> or
        function declaration then the lambda is a generic lambda 
        <cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref> and the function is
        a generic function <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>.</p>

        <p para_num="5" id="dcl.spec.constr.5">A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder type that will be replaced later, and it 
        introduces an associated constraint on deduced type, called
        the <dfn>constrained type</dfn> within the enclosing declaration or 
        <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.</p>

        <p para_num="6" id="dcl.spec.constr.6">If the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>, then the
        constrained type is deduced from the required valid expression.
        Otherwise, the constrained type is deduced using the rules for
        deducing <code>auto</code> (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>).</p>
        
        <p para_num="7" id="dcl.spec.constr.7">The <dfn>introduced constraint</dfn> is a constraint expression 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) synthesized from the
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> or
        <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> in the
        <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm>.</p>

        <p para_num="8" id="dcl.spec.constr.8">When an identifier is a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, it refers to one or
        more function concepts or a single variable concept. 

        At least one concept referred
        to by the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm>
        shall be a type concept (<cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept">7.1.7</a></cxx-ref>).
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Function concepts can be overloaded to accept different numbers and
        kinds of template arguments. This is sometimes done to generalize
        a single concept for different kinds of arguments.
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
    concept bool C() { ... }
  template&lt;typename T, typename U&gt;
    concept bool C() { ... }</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        The <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> <code>C</code>
        refers to both concept definitions.
        <p></p>

        <p para_num="9" id="dcl.spec.constr.9">A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> followed by a sequence
        of template arguments.
        
        A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> does not refer
        to template specialization; the template argument list must be
        adjusted by adding a template argument before the first of the
        initial template arguments before the name refers to a template
        specialization.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt;
    concept bool C = ...;

  C&lt;int&gt;       // A partial-concept-id
  C&lt;char, int&gt; // A template-id</code></pre>
  
        The first name is a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>
        and can be used as part of constrained type name as part the type 
        specifier of a parameter declaration or a template parameter. The 
        second name is a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> and
        determines whether the concept is satisfied for the given arguments.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="10" id="dcl.spec.constr.10">A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> shall not
        have an empty list of template arguments.</p>


        <p para_num="11" id="dcl.spec.constr.11">An introduced constraint is formed by applying the following
        rules to each concept referenced by the
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> in the
        <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm>.

        Let <code>C</code> be a concept referred to by the
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.
        <code>T</code> be the constrained type, and 
        <code>Args</code> be a sequence of template arguments.

        If the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>, then
        <code>Args</code> is its 
        <cxx-grammarterm><i>template-argument-list</i></cxx-grammarterm>, otherwise
        <code>Args</code> is an empty sequence.

        The <dfn>candidate constraint</dfn> is a 
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> having the form
        <code>C&lt;T, Args&gt;</code>. 
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        If <code>Args</code> is empty, the resulting 
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> is of the form 
        <code>C&lt;T&gt;</code>.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        If <code>C&lt;T, Args&gt;</code> does not refer to a template 
        specialization, the candidate constraint is rejected.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The expression <code>C&lt;T, Args&gt;</code> may not refer to a valid
        template specialization if <code>Args</code> contains too many or to 
        few template arguments for <code>C</code>, or if <code>Args</code>
        do not match <code>C's</code> template parameters.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        </p><p para_num="12" id="dcl.spec.constr.12">If, after constructing candidate constraints for each concept
        named by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, there
        are no candidates or more than one candidate, the program is 
        ill-formed.</p>

        <p para_num="13" id="dcl.spec.constr.13">The introduced constraint is constructed from the remaining candidate. 
        If <code>C</code> is a function concept, then the
        resulting constraint is a function call of the form
        <code>C&lt;T, Args&gt;()</code>. Otherwise, the introduced constraint
        is the same as the remaining candidate.
        </p>

        <p para_num="14" id="dcl.spec.constr.14">
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        The following unary and binary concepts are defined as variables and
        functions.
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool V1 = ...;

  template&lt;typename T, typename U&gt;
  concept bool V2 = ...;

  template&lt;typename T&gt;
  concept bool F1() { return ...; }

  template&lt;typename T, typename T2&gt;
  concept bool F2() { return ...; }</code></pre>
  
        Suppose <code>X</code> is a template parameter being declared, either 
        explicitly or as an invented template parameter of a 
        <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        in a generic function or generic lambda. The synthesized constraints 
        corresponding to each declaration are:
        <cxx-codeblock>
    
    <pre><code>V1 X    // becomes V1&lt;T&gt;
  V2&lt;Y&gt; X // becomes V2&lt;X, Y&gt;
  F1 X    // becomes F1&lt;X&gt;()
  F2&lt;Y&gt; X // becomes F2&lt;X, Y&gt;()</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="15" id="dcl.spec.constr.15">The meaning of the introduced constraint depends on the context
        in which the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears. 

        If it appears in the <cxx-grammarterm><i>decl-specifiers</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> of a 
        generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>) or
        generic function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
        the the introduced constraint is associated with the corresponding 
        template declaration (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).

        If it appears  in <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>, the
        introduced constraint is evaluated as part of the enclosing 
        <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> 
        (<cxx-ref to="expr.req"><a title="expr.req" href="#expr.req">5.1.3</a></cxx-ref>). </p>
      
    </section>
  </cxx-section> <!-- dcl.spec.constr -->

    
    </section>
  </cxx-section> <!-- dcl.type -->

    <cxx-section id="dcl.concept">
    

    <section>
      <header><span class="section-number">7.1.7</span> <h1 data-bookmark-label="7.1.7 concept specifier"><code>concept</code> specifier</h1> <span style="float:right"><a href="#dcl.concept">[dcl.concept]</a></span></header>
      
      

      <p para_num="1" id="dcl.concept.1">The <code>concept</code> specifier shall be applied to only the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its definition or 
      a variable concept and its initializer.</p>

      <p para_num="2" id="dcl.concept.2">A <dfn>type concept</dfn> is a concept whose first template
      parameter is a <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm>, but 
      not a template template parameter. 

      Otherwise, the concept is a <dfn>non-type concept</dfn>.

      A <dfn>variadic concept</dfn> is a concept whose first template
      parameter is a template parameter pack.
      </p>

      <p para_num="3" id="dcl.concept.3">Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr">C++ <span title="dcl.constexpr">§7.1.5</span></cxx-ref>).
      </p>

      <p para_num="4" id="dcl.concept.4">A function concept has the following restrictions:
      </p><ul>
        <li> The template must be unconstrained.</li>
        <li> The result type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The declaration shall be a definition. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose expression shall be a
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool C1() { return true; } // OK

template&lt;typename T&gt;
  concept int C2() { return 0; }  // error: must return bool

template&lt;typename T&gt;
  concept bool C3(T) { return true; } // error: must have no parameters

concept bool p = 0; // error: not a template</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="5" id="dcl.concept.5">A variable template has the following restrictions:
      </p><ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool D1 = has_x&lt;T&gt;::value; // OK

template&lt;typename T&gt;
  concept bool D2 = 3 + 4; // Error: initializer is not a constraint

template&lt;Integral T&gt;
  concept bool D3 = has_x&lt;T&gt;::value; // Error: constrained concept definition</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="6" id="dcl.concept.6">A program that declares an explicit or partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool C = is_iterator&lt;T&gt;::value;

template&lt;typename T&gt;
  concept bool C&lt;T*&gt; = true; // Error: partial specialization of a concept</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="7" id="dcl.concept.7">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

    
    </section>
  </cxx-section> <!-- dcl.concept -->

  
    </section>
  </cxx-section> <!-- dcl.spec -->

    </section>
  </cxx-clause> <!-- dcl.dcl -->


<cxx-clause id="dcl.decl" number="8">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Declarators">Declarators</h1> <span style="float:right"><a href="#dcl.decl">[dcl.decl]</a></span></header>
      
  

  <p para_num="1" id="dcl.decl.1">Modify <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1 as follows:</p>

  <p para_num="2" id="dcl.decl.2">A declarator declares a single variable, function, or type, within a 
  declaration. The <cxx-grammarterm><i>init-declarator-list</i></cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which can 
  <del>have an initializer</del>
  <ins>have constraints, an initializer, or both</ins>.
  <bnf-grammar>
    
    
    <bnf-rule>
    
    init-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator
        <bnf-opt>requires-clause<sub>opt</sub></bnf-opt>
        <bnf-opt>initializer<sub>opt</sub></bnf-opt>
      
  </bnf-alt>
  
  </bnf-grammar>
  </p>

  Insert the following paragraph after 
  <cxx-ref in="cxx" to="dcl.decl">C++ <span title="dcl.decl">§8</span></cxx-ref>/1.

  <p para_num="3" id="dcl.decl.3"> A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the
  <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a generic
  function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template<typename t=""> concept bool C = true;

void f1(auto x) requires C&lt;decltype(x)&gt;;// <i>OK</i>
void f2(int x) requires C&lt;int&gt;;         // <i>OK</i>
auto n requires C&lt;decltype(n)&gt; = g();   // <i>error: cannot constrain variable declaration</i>
struct S { } requires C&lt;S&gt;;             // <i>error: cannot constrain a class definition</i>
  </typename></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <cxx-section id="dcl.meaning" number="3">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Meaning of declarators">Meaning of declarators</h1> <span style="float:right"><a href="#dcl.meaning">[dcl.meaning]</a></span></header>
      
    

    <cxx-section id="dcl.fct" number="5">
    

    <section>
      <header><span class="section-number">8.3.5</span> <h1 data-bookmark-label="8.3.5 Functions">Functions</h1> <span style="float:right"><a href="#dcl.fct">[dcl.fct]</a></span></header>
      
      

      <!-- NOTE: Removal pending discussion of constrained-parameters.
           My feeling is that this will go. -->
      <!-- 
      Refactor the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      grammar in <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>/3 to separate
      the declaration of a parameter from its default argument.

      <bnf-grammar>
        <ins>
        <bnf-rule>basic-parameter-declaration</bnf-rule>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
        </ins>

        <bnf-rule>parameter-declaration</bnf-rule>
          <del>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq declarator <bnf-terminal>=</bnf-terminal> initializer-clause
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> decl-specifier-seq <bnf-opt>abstract-declarator</bnf-opt> <bnf-terminal>=</bnf-terminal> initializer-clause
          </bnf-alt>
          </del>
          
          <ins>
          <bnf-alt>basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer-clause</bnf-alt>
          </ins>
      </bnf-grammar>
      -->
      
    
      <!-- TODO: Add to /15 a rule that disambiguates the ... (without
      a preceeding ',' for constrained-type-specifiers). If it's needed.

      The "or contains auto" will need to be updated. -->

      Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct">C++ <span title="dcl.fct">§8.3.5</span></cxx-ref>/14.

      <!-- TODO: Extend this to support constrained-type-specifiers -->
      
      <p para_num="15" id="dcl.fct.15" number="15">
      An abbreviated function (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      (call it <code>F</code>) is equivalent to a 
      function template (<cxx-ref to="temp.fct"><a title="temp.fct" href="#temp.fct">14.5.6</a></cxx-ref>) (call it 
      <code>T</code>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      includes one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
      for each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
      <code>F</code>, in order of appearance. 

<!--
      The invented type <cxx-grammarterm>template-parameter</cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
      declares a function parameter pack. 
 -->

      The function parameters of <code>T</code> are derived from the
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
      <code>F</code> by replacing each occurrence of <code>auto</code> with the 
      name of the corresponding invented 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(auto);
void f2(auto&amp;, auto);
auto f3(void (*)(auto));
void f4(auto (*)(int));
void f5(Vec&lt;auto&gt;&amp;);
void f6(Pair&lt;const auto&amp;, auto*&gt;);

template&lt;typename T&gt; void g1(T);           // <i>OK: Equivalent to</i> f1(auto)
template&lt;typename T1, typename T2&gt; 
  void g2(T1&amp;, T2);                        // <i>OK: Equivalent to</i> f2(auto&amp;, auto)
template&lt;typename T&gt; void g3(void (*)(T)); // <i>OK: Equivalent to</i> f3(void (*)(auto))
template&lt;typenaem T&gt; void g4(T (*)(int));  // <i>OK: Equivalent to</i> f4(auto (*)(int))
template&lt;typename T&gt; void g5(Vec&lt;T&gt;&amp;);     // <i>OK: Equivalent to</i> f5(Vec&lt;auto&gt;&amp;)
template&lt;typename T1, typename T2&gt; 
  void g6(Pair&lt;const T1&amp;, T2*&gt;);           // <i>OK: Equivalent to</i> f6(Pair&lt;const auto&amp;, auto*&gt;)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <!-- TODO: Variadics are broken. We're allowed to use multiple autos
           per parameter type. If the parameter declares a function
           parameter pack, the there must be at most one auto specifiers.

           void f(vector<auto>... Ts); // Ok?
       -->


      <!-- TODO: Move into temp.fct? -->
      <p para_num="16" id="dcl.fct.16"> A function template can be an abbreviated function. The
      invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s are
      added to the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: Equivalent to f(Array&lt;auto, N&gt;*)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <!--

      <p>A <defn>generic function</defn> is a function template whose
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> has a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> whose 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> is either 
      <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.
      </p>

      <p>The declaration of a generic function has a 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> that 
      consists of one invented type 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> for each
      occurrence of <code>auto</code> or each unique occurrence of a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
      in the function's
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 
      
      The invented type of 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> is a parameter 
      pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> declares 
      a function parameter pack (<cxx-ref in="cxx" to="dcl.fct"></cxx-ref>).
      
      If the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of the 
      corresponding <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
      includes a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      the invented type parameter is a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, whose
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> matches
      that of the <cxx-grammarterm>parameter-declaration</cxx-grammarterm>.
      (<cxx-ref to="temp.param"></cxx-ref>).</ins>

      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
template&lt;typenaem T&gt;
  conxtexpr bool C() { ... }

auto f(auto x, const C&amp; y);

template&lt;typename T1, C T2&gt;
  auto f(T1 x, const T2&amp; y);
      </cxx-codeblock>
      The type of <code>y</code> is a type parameter constrained by
      <code>C</code>.
      </cxx-example>
      </p>

      <p>All placeholder types introduced using the same 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm> have the 
      same invented template parameter.
      <cxx-example class="inline">
      The following generic function declarations are equivalent:
      <cxx-codeblock>
auto g(C a, C* b);

template&lt;C T&gt;
  auto g(T a, T* b);
      </cxx-codeblock>
      </cxx-example>
      </p>
      -->

    
    </section>
  </cxx-section> <!-- dcl.fct -->
  
    </section>
  </cxx-section> <!-- dcl.meaning -->

  <cxx-section id="dcl.fct.def">
    

    <section>
      <header><span class="section-number">8.4</span> <h1 data-bookmark-label="8.4 Function definitions">Function definitions</h1> <span style="float:right"><a href="#dcl.fct.def">[dcl.fct.def]</a></span></header>
      
    

    <cxx-section id="dcl.fct.def.general">
    

    <section>
      <header><span class="section-number">8.4.1</span> <h1 data-bookmark-label="8.4.1 In general">In general</h1> <span style="float:right"><a href="#dcl.fct.def.general">[dcl.fct.def.general]</a></span></header>
      
      
    
      <p para_num="1" id="dcl.fct.def.general.1">Modify the <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      syntax in <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>
      to include a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.</p>

      <bnf-grammar>
    
    
        <bnf-rule>
    
    function-definition:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt>
            <bnf-opt>decl-specifier-seq<sub>opt</sub></bnf-opt>
            declarator
            <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
            <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
            function-body
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="2" id="dcl.fct.def.general.2">Add the following paragraph at the end of
      <cxx-ref in="cxx" to="dcl.fct.def.general">C++ <span title="dcl.fct.def.general">§8.4.1</span></cxx-ref>.</p>

      <p para_num="3" id="dcl.fct.def.general.3">A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the
      <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a generic
      function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>) or a member function
      definition (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Constraints for a function template or member function template are
      written after the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = ...;
template&lt;typename T&gt; concept bool C2 = ...;
template&lt;typename T, typename U&gt; concept bool D = ...;

void f(C1 a, C2 b) requires D&lt;decltype(a), decltype(b)&gt; { } // Ok

template&lt;typename T&gt;
  void f(const T&amp; x) requires C&lt;T&gt;; // Error: f is declared as a template

template&lt;typename T&gt;
  struct S1 {
    S1(T&amp;) requires C1&lt;T&gt; { }   // Defines a constrained constructor
    void f() requires C2&lt;T&gt; { } // Defines a constrained member function
  };

struct S2 {
  void g(auto x) requires D&lt;decltype(x)&gt; { } // Ok
};</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="dcl.fct.def.general.4">A <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
      shall not declare a destructor (<cxx-ref in="cxx" to="class.dtor">C++ <span title="class.dtor">§12.4</span></cxx-ref>)
      with a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
     <!-- dcl.fct.def.general -->
   <!-- dcl.fct.def -->

 <!-- dcl.decl -->
</p>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-clause>

<cxx-clause id="class" number="9">
    

    <section>
      <header><span class="section-number">9</span> <h1 data-bookmark-label="9 Classes">Classes</h1> <span style="float:right"><a href="#class">[class]</a></span></header>
      
  

  <cxx-section id="class.mem" number="2">
    

    <section>
      <header><span class="section-number">9.2</span> <h1 data-bookmark-label="9.2 Class members">Class members</h1> <span style="float:right"><a href="#class.mem">[class.mem]</a></span></header>
      
    

    <p para_num="1" id="class.mem.1">In <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref>, modify the
    <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm> syntax.</p>

    <bnf-grammar>
    
    
      <bnf-rule>
    
    member-declarator:
  </bnf-rule>
      <bnf-alt>
    
    
        declarator 
        <bnf-opt>virt-specifier-seq<sub>opt</sub></bnf-opt>
        <bnf-opt>pure-specifier-seq<sub>opt</sub></bnf-opt>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
      
  </bnf-alt>
    
  </bnf-grammar>

  <p para_num="2" id="class.mem.2">Insert the following paragraph after 
  <cxx-ref in="cxx" to="class.mem">C++ <span title="class.mem">§9.2</span></cxx-ref></p>

  <p para_num="3" id="class.mem.3">A <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) shall only be present if the 
  <cxx-grammarterm><i>declarator</i></cxx-grammarterm> declares a constrained member
  function of a class template (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>)
  or a generic function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = ...;
template&lt;typename T&gt; concept bool D = ...;

template&lt;typename T&gt;
  struct A {
    A(T*) requires C&lt;T&gt;;    // Declares a constrained constructor
    void f() requires D&lt;T&gt;; // Declares a constrained member function
  };

struct B {
  void g(int n) requires C&lt;int&gt;; // Error: cannont constraint a non-template
  void h(C a, D b);              // Declares a constrained generic member function

};</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A constrained generic function declared at class scope is a member function
  template.
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  <p></p>

  <p para_num="4" id="class.mem.4">A destructor (<cxx-ref in="cxx" to="class.dtor">C++ <span title="class.dtor">§12.4</span></cxx-ref>) shall not be 
  declared with <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>s.</p>

  
    </section>
  </cxx-section> <!-- class.mem -->

    </section>
  </cxx-clause>


<cxx-clause id="temp" number="14">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Templates">Templates</h1> <span style="float:right"><a href="#temp">[temp]</a></span></header>
      
  

  <!-- Editing instruction -->
  Modify the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  grammar in <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>/1.

  <!-- TODO: Put this in block quotes. Currently, some formatting is
       not propagated through the blockquote element, so I'm omitting
       it for now. -->
  <p para_num="1" id="temp.1" number="1" class="quoted">
  <bnf-grammar>
    
    
    <bnf-rule>
    
    template-declaration:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>template</code></bnf-terminal>
        <bnf-terminal><code>&lt;</code></bnf-terminal>
        template-parameter-list
        <bnf-terminal><code>&gt;</code></bnf-terminal>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        declaration
      
  </bnf-alt>
      <ins>
      <bnf-alt>
    
    
        <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> 
        concept-name
        <bnf-terminal><code>{</code></bnf-terminal>
        introduction-list
        <bnf-terminal><code>}</code></bnf-terminal>
        declaration
      
  </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>
    
    requires-clause:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> constraint-expression
  </bnf-alt>

    <bnf-rule>
    
    introduction-list:
  </bnf-rule>
      <bnf-alt>
    
    introduced-parameter
  </bnf-alt>
      <bnf-alt>
    
    introduction-list<bnf-terminal><code>,</code></bnf-terminal> introduced-parameter
  </bnf-alt>

      <bnf-rule>
    
    introduced-parameter:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-opt><bnf-terminal><code>...</code></bnf-terminal><sub>opt</sub></bnf-opt> identifier
  </bnf-alt>
    </ins>
  
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>/6.

  <p para_num="2" id="temp.2"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), or they are
  introduced by a <dfn>concept introduction</dfn>, a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> and following
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.</p>

  <p para_num="3" id="temp.3"> The concept designated by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  is determined by the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.
  Let <code>C</code> be a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm><i>identifiers</i></cxx-grammarterm> in the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s of
  an <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  If the <cxx-grammarterm><i>template-id</i></cxx-grammarterm>,
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code>, refers to a single
  concept declaration, then that concept is the one designated by
  <code>C</code>. Otherwise, the program is ill-formed.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i></code></pre>
  
  It is possible to overload function concepts in such a way that a
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> can designate multiple
  concepts.
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of the concept</i> C <i>is ambiguous</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="4" id="temp.4">Each <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  in the <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s
  of the <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>.
  <cxx-grammarterm><i>
  </i></cxx-grammarterm></p><ul>
  
  <li> If <code>P</code> is a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a template 
  <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> using the same keyword;</li>
  
  <li> if <code>P</code> is a template <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> 
  that declares a class template, <code>I</code> is declared as a
  class template with the template parameters of <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type 
  <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, <code>I</code> is
  declared as a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
  having the same type as <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm><i>identifier</i></cxx-grammarterm>, <code>I</code>,
  shall be preceded by an ellipsis, and is declared as a template parameter 
  pack.</li>
  </ul>
  
  An <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T, int N, typename... Xs&gt; concept bool Inscrutable = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool Unary_template = true;

Inscrutable{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;             // B <i>is declared as</i> int B
                        // C <i>is declared as</i> typename... C

Inscrutable{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

Unary_template{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // <i>error: the corresponding parameter is not a</i> 
  void bar();        // <i>template parameter pack</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p para_num="5" id="temp.5"></p>

  <p para_num="6" id="temp.6">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A concept referred to be a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> may omit 
  <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                        // <i>a single template type parameter</i> T</code></pre>
  
There is no <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> 
that corresponds to the template parameter, <code>B</code>, in the
<code>Ineffable</code> concept, so <code>f(T)</code> is declared with only
one template parameter.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="7" id="temp.7"> The <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> shall not
  be empty.</p>

  <p para_num="8" id="temp.8"> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p para_num="9" id="temp.9">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
    <span class="nowrap">— <em>end note</em> ]</span>
  
  <p></p>

  <p para_num="10" id="temp.10"> A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> declared
  by a concept introduction can also be an abbreviated function
  (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  The invented template parameters introduced by the presence of
  <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s or
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in
  the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
  are added to the list of template parameters introduced by the the
  <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} void f(T, D);

template&lt;C T, D __D&gt; void f(T, __D); // <i>OK: redeclaration of</i> f(T, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

C{T} void X&lt;T&gt;::f(D) { } // <i>OK: definition of</i> X&lt;T&gt;::f(D);
                         // f <i>is a function template with one invented</i>
                         // <i>template type-parameter</i>

C{T} D{U} void X&lt;T&gt;::g(U, C) { } // <i>OK: definition of</i> X&lt;T&gt;::g(U, C);
                                 // g <i>is a function template with two template</i>
                                 // <i>type parameters: one introduced (</i>U<i>) and</i>
                                 // <i>one invented</i></code></pre>
  </cxx-codeblock>
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  <p></p>

  <p para_num="11" id="temp.11"> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>C</code>,
  associates a constraint with the 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. That constraint is
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;</code> when <code>C</code> designates
  a variable concept and
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;()</code> when <code>C</code> designates
  a function concept. If an <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>
  declares a template parameter pack, its corresponding template argument in the
  associated constraint is a pack expansion 
  (<cxx-ref in="cxx" to="temp.variadic">C++ <span title="temp.variadic">§14.5.3</span></cxx-ref>).

  <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename A, typename B, int C&gt; concept bool C = true;
template&lt;typename A, typename... Args&gt; concept bool D = true;

C{X, Y, Z} struct S;  // <i>associates</i> C&lt;X, Y, Z&gt; <i>with</i> S
D{P, ...Qs} struct T; // <i>associates</i> D&lt;P, Qs...&gt; <i>with</i> T</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- FIXME: This should move to a separate section? -->


  <p para_num="12" id="temp.12">A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  </p><ul>
  <li> a concept introduction,

  </li><li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>)
  in the declaration's <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
  a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> appearing after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> of an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> whose 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>).

  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declarations are equivalent:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);</code></pre>
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of its
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
  <p para_num="13" id="temp.13">

  </p><p para_num="14" id="temp.14"> When <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> whose
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p para_num="15" id="temp.15">When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), it
  is equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>, <code>E</code>,
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>).
  
  The declaration, <code>E</code>, has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code> (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>).

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, its
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 A, C2 B&gt; struct R;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename X, int Y&gt; 
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct R; // <i>error: redeclaration of R with different constraints</i>

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="16" id="temp.16"> When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="17" id="temp.17"> An abbreviated function can also be declared as a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in the
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> and the
  following <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.
  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

template&lt;C T, D U&gt;
  requires P&lt;T&gt;     // <i>associated constraints are</i> C&lt;T&gt; &amp;&amp; D&lt;U&gt;() &amp;&amp; P&lt;T&gt; 
    void g1(T, U);  // <i>error: ill-formed, no diagnostic required</i>;
  
C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)</code></pre>
  
  The second declaration of <code>g1(T, U)</code> is ill-formed (no diagnostic
  required) because it is functionally equivalent to the first declaration, 
  but not equivalent.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  


  <p></p><p para_num="18" id="temp.18"> A <dfn>trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm></dfn> 
  is a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> that appears after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U, typename __P&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)</code></pre>
  
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Template parameters">Template parameters</h1> <span style="float:right"><a href="#temp.param">[temp.param]</a></span></header>
      
    

    Modify the <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/1 as follow.

    <p para_num="1" id="temp.param.1" number="1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-parameter:
  </bnf-rule>
        <del><bnf-alt>
    
    parameter-declaration
  </bnf-alt></del>
        <ins><bnf-alt>
    
    constrained-or-non-type-parameter
  </bnf-alt></ins>

      <bnf-rule>
    
    constrained-or-non-type-parameter:
  </bnf-rule>
        <bnf-alt>
    
    basic-parameter-declaration
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> initializer-clause 
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> type-id 
  </bnf-alt>
        <bnf-alt>
    
    basic-parameter-declaration <bnf-terminal><code>=</code></bnf-terminal> id-expression 
  </bnf-alt>
      
    
  </bnf-grammar>
    </p>
    
    Modify <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/2 as follows.

    <p para_num="2" id="temp.param.2" number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm><i>unqualified-id</i></cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm><i>qualified-id</i></cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>. 
    </p>

    Modify <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/15 as follows.

    <p para_num="15" id="temp.param.15" number="15" class="quoted">
    If a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is a 
    <cxx-grammarterm><i>type-parameter</i></cxx-grammarterm> with an ellipsis prior to 
    its optional identifier 
    or is a 
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>
    that declares a parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
    then the template-parameter is a template parameter pack 
    (<cxx-ref to="temp.variadic"><a title="temp.variadic" href="#temp.variadic"></a></cxx-ref>).
     
    A template parameter pack that is a
    <del><cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> </del>
    <ins><cxx-grammarterm><i>constrained-or-non-type-parameter</i></cxx-grammarterm></ins>
    whose type contains one or more unexpanded parameter packs is a pack 
    expansion.
    </p>

    Add the following paragraphs after
    <cxx-ref in="cxx" to="temp.param">C++ <span title="temp.param">§14.1</span></cxx-ref>/15.

    <!-- TODO: I don't think I can write this until I've rewritten
         the constrained-type-specifier work -->.

    <p para_num="16" id="temp.param.16">A <dfn>constrained template parameter</dfn> is a
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> whose
    <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> contains a
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

    A <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> 
    defines its identifier to be a template parameter that matches in
    kind the first template parameter, called the <dfn>prototype parameter</dfn>, 
    of the concept designated by the 
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; 
  concept bool C1 = ...;
template&lt;template&lt;typename&gt; class X&gt; 
  concept bool C2 = ...;
template&lt;int N&gt; 
  concept bool P = ...;

template&lt;C1 T&gt; void f();       // T is a type parameter
template&lt;C2 X&gt; void g();       // X is a template with one type parameter
template&lt;P N&gt; void x();        // N has type int
template&lt;const P* N&gt; void y(); // N has type const int*</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="17" id="temp.param.17">If the prototype parameter is a type parameter (including template
    template parameters), then the 
    <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of the
    constrained parameter shall consist of only the
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;const C1&gt; // Error: declares a const-qualified type parameter
  struct S;</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="18" id="temp.param.18">The declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is
    a template parameter pack if the prototype parameter declares a
    template parameter pack. In such cases, the 
    <cxx-grammarterm><i>declarator-id</i></cxx-grammarterm> or
    <cxx-grammarterm><i>abstract-declarator</i></cxx-grammarterm> of the
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> shall
    also include an ellipsis.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename... Ts&gt;
  concept bool X = ...;

template&lt;X... Xs&gt; void f(); // Xs is a parameter pack
template&lt;X Xs&gt; void g();    // Error: must X must include ...</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="19" id="temp.param.19">If the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>
    declares a type parameter, then the 
    <cxx-grammarterm><i>constrained-initializer</i></cxx-grammarterm>
    is parsed as a <cxx-grammarterm><i>type-id</i></cxx-grammarterm>. Otherwise, it
    is parsed as a <cxx-grammarterm><i>initializer-clause</i></cxx-grammarterm>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C1 T = int&gt; void p(); // Ok
template&lt;P N = 0&gt; void q();    // Ok
template&lt;P M = int&gt; void r();  // Error: int is not an expression</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="20" id="temp.param.20">The declaration of a 
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> 
    introduces a new constraint on the template declaration. 

    The constraint is formed by substituting the declared 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> as the first
    template argument of the concept declaration designated by the
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> in
    the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> declaration.

    If the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
    a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>, its template
    arguments are substituted after the declared
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

    If the designated concept is a function concept, then the 
    introduced constraint is a function call.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C1 T&gt; void f1(); // requires C1&lt;T&gt;
template&lt;C2 U&gt; void f2(); // requires C2&lt;U&gt;
template&lt;P N&gt; void f3(); // requires P&lt;N&gt;</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="21" id="temp.param.21">If the <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> declares 
    a template parameter pack, the formation of the constraint depends on 
    whether the designated concept designated by the parameter's
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is variadic.

    Let <code>T</code> be the declared parameter, <code>C</code> be the
    designated concept, and <code>Args...</code> be a  sequence of template
    arguments from a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>,
    possibly empty.

    If <code>C</code> is a variadic concept, then the associated constraint
    is a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of the form
    <code>C&lt;T..., Args...&gt;</code>. 

    Otherwise, if <code>C</code> is not a variadic concept, the associated
    constraint is a conjunction of sub-constraints
    <code>C&lt;T<i>i</i>, Args...&gt;</code> for each <code>T<i>i</i></code>
    in the parameter pack <code>T</code>.

    If <code>C</code> is a function concept, each introduced constraint or
    sub-constraint is adjusted to be a call expression of the form
    <code>C&lt;X, Args...&gt;()</code> where <code>X</code> is either
    the template parameter pack <code>T</code> or an element 
    <code>T<i>i</i></code>.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename... Ts&gt; concept bool P = ...;
template&lt;typename T&gt; concept bool U = ...;


template&lt;P... Xs&gt; void f4();   // requires P&lt;Xs...&gt;
template&lt;U... Args&gt; void f5(); // requires U&lt;Args0&gt; &amp;&amp; U&lt;Args1&gt; &amp;&amp; ... &amp;&amp; U&lt;Argsn&gt;</code></pre>
  
    Here, <code>Args0</code>, <code>Args1</code>, etc. denote elements
    of the template argument pack <code>Args</code> used as part of the
    introduced constraint.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
  
    </section>
  </cxx-section>


  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    

    <section>
      <header><span class="section-number">14.2</span> <h1 data-bookmark-label="14.2 Template names">Template names</h1> <span style="float:right"><a href="#temp.names">[temp.names]</a></span></header>
      
    

    <p para_num="1" id="temp.names.1">Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names">C++ <span title="temp.names">§14.2</span></cxx-ref>/7.</p>

    <p para_num="2" id="temp.names.2">If a <cxx-grammarterm><i>template-id</i></cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <p></p>

    
    <p para_num="3" id="temp.names.3"></p>
  
    </section>
  </cxx-section> <!-- temp.names -->

  <cxx-section id="temp.arg">
    

    <section>
      <header><span class="section-number">14.3</span> <h1 data-bookmark-label="14.3 Template arguments">Template arguments</h1> <span style="float:right"><a href="#temp.arg">[temp.arg]</a></span></header>
      
    

    <cxx-section id="temp.arg.template">
    

    <section>
      <header><span class="section-number">14.3.1</span> <h1 data-bookmark-label="14.3.1 Template template arguments">Template template arguments</h1> <span style="float:right"><a href="#temp.arg.template">[temp.arg.template]</a></span></header>
      
      

      <p para_num="1" id="temp.arg.template.1">Modify <cxx-ref in="cxx" to="temp.arg.template">C++ <span title="temp.arg.template">§14.3.3</span></cxx-ref>.

      </p><p para_num="2" id="temp.arg.template.2">A <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> matches 
      a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      shall subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool X = has_x&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Y = X&lt;T&gt; &amp;&amp; has_y&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Z = Y&lt;T&gt; &amp;&amp; has_z&lt;T&gt;::value;

template&lt;template&lt;Y&gt; class C&gt;
  class temp { ... };

template&lt;X T&gt; class x;
template&lt;Z T&gt; class z;

temp&lt;x&gt; s1; // OK: X is subsumed by Y
temp&lt;z&gt; s2; // Error: Z subsumes Y</code></pre>
  
      The template <code>x</code> is a valid argument for <code>temp</code>
      because any template arguments satisfying <code>Y</code> will also 
      satisfy <code>X</code>. That is, all uses of <code>x</code> by
      <code>temp</code> should result in well-formed programs. The 
      template <code>y</code> is not valid because some template arguments 
      satisfying <code>Y</code> may not satisfy <code>Z</code>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.arg.template -->
  
    </section>
  </cxx-section> <!-- tmep.arg -->

  <cxx-section id="temp.decls" number="5">
    

    <section>
      <header><span class="section-number">14.5</span> <h1 data-bookmark-label="14.5 Template declarations">Template declarations</h1> <span style="float:right"><a href="#temp.decls">[temp.decls]</a></span></header>
      
    

    <cxx-section id="temp.class">
    

    <section>
      <header><span class="section-number">14.5.1</span> <h1 data-bookmark-label="14.5.1 Class templates">Class templates</h1> <span style="float:right"><a href="#temp.class">[temp.class]</a></span></header>
      
      

      Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.class">C++ <span title="temp.class">§14.5.1</span></cxx-ref>/3.

      <p para_num="1" id="temp.class.1">When a member of a constrained class template is defined outside of 
      its class template definition, it shall be specified with the
      <cxx-grammarterm><i>template-parameters</i></cxx-grammarterm> and
      associated constraints of the class template.
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Con = ...;

template&lt;typename T&gt; requires Con&lt;T&gt;
  struct S {
    void f();
    void g();
  }

template&lt;typename T&gt; 
  requires Con&lt;T&gt;
    void S&lt;T&gt;::f() { } // Ok: parameters and constraints match

template&lt;typename T&gt;
  void S&lt;T&gt;::g() { } // Error: no declaration of g() in S&lt;T&gt;</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


      <cxx-section id="temp.mem.func">
    

    <section>
      <header><span class="section-number">14.5.1.1</span> <h1 data-bookmark-label="14.5.1.1 Member functions of class templates">Member functions of class templates</h1> <span style="float:right"><a href="#temp.mem.func">[temp.mem.func]</a></span></header>
      
        

        <p para_num="1" id="temp.mem.func.1">Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func">C++ <span title="temp.mem.func">§14.5.1.1</span></cxx-ref>.
        
        </p><p para_num="2" id="temp.mem.func.2">A member function of a class template whose declarator contains a
        <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is a
        <dfn>constrained member function</dfn>.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  class S {
    void f() requires C&lt;T&gt;();
  };</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="3" id="temp.mem.func.3">Constraints on member functions are instantiated as needed
        during overload resolution, not when the class template is
        instantiated
        (<cxx-ref in="cxx" to="temp.inst">C++ <span title="temp.inst">§14.7.1</span></cxx-ref>).
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Constraints on member functions do not affect the declared 
        interface of a class. That is, a constrained copy constructor 
        is still a copy constructor, even if it will not be viable for 
        a specialization of the class template.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </p>

        <p para_num="4" id="temp.mem.func.4">A constrained member function of a class template may be defined
        outside of its class template definition. Its definition shall be
        specified with the constraints of its declaration.
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        Consider possible definitions of the constrained member function 
        <code>S&lt;T&gt;f</code> from above.
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() { }                 // Error: no declaration of f() in S&lt;T&gt;.

template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() requires C&lt;T&gt;() { } // Ok: defines S&lt;T&gt;::f</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

      
    </section>
  </cxx-section> <!-- temp.mem.func -->
    
    </section>
  </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
    

    <section>
      <header><span class="section-number">14.5.2</span> <h1 data-bookmark-label="14.5.2 Member templates">Member templates</h1> <span style="float:right"><a href="#temp.mem">[temp.mem]</a></span></header>
      
      

      <p para_num="1" id="temp.mem.1">Insert the following paragraph after
      <cxx-ref in="cxx" to="temp.mem">C++ <span title="temp.mem">§14.5.2</span></cxx-ref>/1.</p>

      <p para_num="2" id="temp.mem.2">A constrained member template defined outside of its class template 
      definition shall be specified with the
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      and constraints of the class template followed by
      the template parameters and constraints of the member template.
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool Foo = ...;
template&lt;typename T&gt; concept bool Bar = ...; // Different than Foo

template&lt;Foo T&gt;
  struct S {
    template&lt;Bar U&gt; void f(U);
    template&lt;Bar U&gt; void g(U);
  };

template&lt;Foo T&gt; template&lt;Bar U&gt; void S&lt;T&gt;::f(U); // Ok
template&lt;Foo T&gt; template&lt;Foo U&gt; void S&lt;T&gt;::g(U); // Error: no g() declared in S</code></pre>
  
      The template constraints in the definition of <code>g</code> do not
      match those in its declaration.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.mem -->


    <cxx-section id="temp.friend" number="4">
    

    <section>
      <header><span class="section-number">14.5.4</span> <h1 data-bookmark-label="14.5.4 Friends">Friends</h1> <span style="float:right"><a href="#temp.friend">[temp.friend]</a></span></header>
      
      

      <p para_num="1" id="temp.friend.1">Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend">C++ <span title="temp.friend">§14.5.4</span></cxx-ref>/9.

      </p><p para_num="2" id="temp.friend.2"> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };</code></pre>
  
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="3" id="temp.friend.3">
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.friend.4">
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="5" id="temp.friend.5">As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    
    </section>
  </cxx-section> <!-- temp.friend -->

    <cxx-section id="temp.class.spec">
    

    <section>
      <header><span class="section-number">14.5.5</span> <h1 data-bookmark-label="14.5.5 Class template partial specialization">Class template partial specialization</h1> <span style="float:right"><a href="#temp.class.spec">[temp.class.spec]</a></span></header>
      
      

      <cxx-section id="temp.class.spec.match">
    

    <section>
      <header><span class="section-number">14.5.5.1</span> <h1 data-bookmark-label="14.5.5.1 Matching of class template partial specializations">Matching of class template partial specializations</h1> <span style="float:right"><a href="#temp.class.spec.match">[temp.class.spec.match]</a></span></header>
      
        

        <p para_num="1" id="temp.class.spec.match.1">Modify 
        <cxx-ref in="cxx" to="temp.class.spec.match">C++ <span title="temp.class.spec.match">§14.5.5.1</span></cxx-ref>/2.</p>

        <p para_num="2" id="temp.class.spec.match.2"> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.</p>

      
    </section>
  </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
    

    <section>
      <header><span class="section-number">14.5.5.2</span> <h1 data-bookmark-label="14.5.5.2 Partial ordering of class template specializations">Partial ordering of class template specializations</h1> <span style="float:right"><a href="#temp.class.order">[temp.class.order]</a></span></header>
      
        

        <p para_num="1" id="temp.class.order.1">Modify 
        <cxx-ref in="cxx" to="temp.class.order">C++ <span title="temp.class.order">§14.5.5.2</span></cxx-ref>/1.</p>

        <p para_num="2" id="temp.class.order.2">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B</code></pre>
  </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      
    </section>
  </cxx-section> <!-- temp.class.order -->
    
    </section>
  </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
    

    <section>
      <header><span class="section-number">14.5.6</span> <h1 data-bookmark-label="14.5.6 Function templates">Function templates</h1> <span style="float:right"><a href="#temp.fct">[temp.fct]</a></span></header>
      
      

      <cxx-section id="temp.over.link">
    

    <section>
      <header><span class="section-number">14.5.6.1</span> <h1 data-bookmark-label="14.5.6.1 Function template overloading">Function template overloading</h1> <span style="float:right"><a href="#temp.over.link">[temp.over.link]</a></span></header>
      
        

        <p para_num="1" id="temp.over.link.1">Modify <cxx-ref in="cxx" to="temp.over.link">C++ <span title="temp.over.link">§14.5.6.1</span></cxx-ref>/6.</p>

        <p para_num="2" id="temp.over.link.2">
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"><a title="temp.deduct" href="#temp.deduct">14.8.2</a></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"="">C++ <span title="">§</span></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"="">C++ <span title="">§</span></cxx-ref>.
        </p>

        <p para_num="3" id="temp.over.link.3">Modify <cxx-ref in="cxx" to="temp.over.link">C++ <span title="temp.over.link">§14.5.6.1</span></cxx-ref>

        </p><p para_num="4" id="temp.over.link.4">
        Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      
    </section>
  </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
    

    <section>
      <header><span class="section-number">14.5.6.2</span> <h1 data-bookmark-label="14.5.6.2 Partial ordering of function templates">Partial ordering of function templates</h1> <span style="float:right"><a href="#temp.func.order">[temp.func.order]</a></span></header>
      
        

        <p para_num="1" id="temp.func.order.1">Modify <cxx-ref in="cxx" to="temp.func.order">C++ <span title="temp.func.order">§14.5.6.2</span></cxx-ref>/2.</p>

        <p para_num="2" id="temp.func.order.2">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      
    </section>
  </cxx-section> <!-- temp.func.order -->
    
    </section>
  </cxx-section> <!-- temp.fct -->
  
    </section>
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.spec" number="7">
    

    <section>
      <header><span class="section-number">14.7</span> <h1 data-bookmark-label="14.7 Template instantiation and specialization">Template instantiation and specialization</h1> <span style="float:right"><a href="#temp.spec">[temp.spec]</a></span></header>
      
    

    <cxx-section id="temp.inst">
    

    <section>
      <header><span class="section-number">14.7.1</span> <h1 data-bookmark-label="14.7.1 Implicit instantiation">Implicit instantiation</h1> <span style="float:right"><a href="#temp.inst">[temp.inst]</a></span></header>
      
      

      <p para_num="1" id="temp.inst.1">Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.inst">C++ <span title="temp.inst">§14.7.1</span></cxx-ref>/1.</p>

      <p para_num="2" id="temp.inst.2">The implicit instantiation of a class template does not cause
      the instantiation of the associated constraints of constrained member 
      functions.</p>
    
    </section>
  </cxx-section> <!-- temp.inst -->

    <cxx-section id="temp.explicit">
    

    <section>
      <header><span class="section-number">14.7.2</span> <h1 data-bookmark-label="14.7.2 Explicit instantiation">Explicit instantiation</h1> <span style="float:right"><a href="#temp.explicit">[temp.explicit]</a></span></header>
      
      

      <p para_num="1" id="temp.explicit.1">Insert the following paragraph under 
      <cxx-ref in="cxx" to="temp.explicit">C++ <span title="temp.explicit">§14.7.2</span></cxx-ref>.</p>

      <p para_num="2" id="temp.explicit.2">An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); };

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.explicit -->

    <cxx-section id="temp.expl.spec">
    

    <section>
      <header><span class="section-number">14.7.3</span> <h1 data-bookmark-label="14.7.3 Explicit specialization">Explicit specialization</h1> <span style="float:right"><a href="#temp.expl.spec">[temp.expl.spec]</a></span></header>
      
      

      <p para_num="1" id="temp.expl.spec.1">Insert the following paragraphs under 
      <cxx-ref in="cxx" to="temp.expl.spec">C++ <span title="temp.expl.spec">§14.7.3</span></cxx-ref>.</p>

      <p para_num="2" id="temp.expl.spec.2">A constrained template declaration or constrained member function
      of a class template can be declared by a declaration
      introduced by <code>template&lt;&gt;</code>.</p>

      <p para_num="3" id="temp.expl.spec.3">The <cxx-grammarterm><i>template arguments</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> that
      names an explicit specialization of a constrained template
      declaration must satisfy that template's associated constraints
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <code>C</code> is the type concept defined in the previous
      section.
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt;
  struct S1 { };

struct X { void c(); }

template&lt;&gt; S1&lt;X&gt; { };   // OK: X satisfies C
template&lt;&gt; S1&lt;int&gt; { }; // Error: int does not satisfy C</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="4" id="temp.expl.spec.4">An explicit specialization of a constrained member function
      (<cxx-ref to="temp.mem.func"><a title="temp.mem.func" href="#temp.mem.func">14.5.1.1</a></cxx-ref>) shall not include a
      a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  struct S2 { 
    void f(T) requires C&lt;T&gt;;
  };

template&lt;&gt; void S2&lt;X&gt;::f(T a) { }               // OK
template&lt;&gt; void S2&lt;X&gt;::f(T a) requires C&lt;X&gt; { } // Error: extra requires-clause</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
    
    </section>
  </cxx-section> <!-- temp.expl.spec -->
  
    </section>
  </cxx-section> <!-- temp.spec -->


  <cxx-section id="temp.fct.spec" number="8">
    

    <section>
      <header><span class="section-number">14.8</span> <h1 data-bookmark-label="14.8 Function template specialization">Function template specialization</h1> <span style="float:right"><a href="#temp.fct.spec">[temp.fct.spec]</a></span></header>
      
    

    <cxx-section id="temp.deduct" number="2">
    

    <section>
      <header><span class="section-number">14.8.2</span> <h1 data-bookmark-label="14.8.2 Template argument deduction">Template argument deduction</h1> <span style="float:right"><a href="#temp.deduct">[temp.deduct]</a></span></header>
      
      

      After <cxx-ref in="cxx" to="temp.deduct">C++ <span title="temp.deduct">§14.8.2</span></cxx-ref>/5, add the following
      paragraph:

      <!-- TODO: Rewrite in terms of satisfaction. -->
      <p para_num="6" id="temp.deduct.6" number="6"> If the template has associated constraints, the template 
      arguments are substituted into those associated constraints and evaluated.
      If the substitution results in an invalid type or expression, or
      if the associated constraints evaluate to <code>false</code>,
      type deduction fails.</p>

    
    </section>
  </cxx-section> <!-- temp.deduct -->

  
    </section>
  </cxx-section>


  <cxx-section id="temp.constr">
    

    <section>
      <header><span class="section-number">14.9</span> <h1 data-bookmark-label="14.9 Template constraints">Template constraints</h1> <span style="float:right"><a href="#temp.constr">[temp.constr]</a></span></header>
      
    

    <p para_num="1" id="temp.constr.1">Add this as a new section under 
    <cxx-ref in="cxx" to="temp">C++ <span title="temp">§14</span></cxx-ref>.</p>


    <p para_num="2" id="temp.constr.2">Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
    
    
      <bnf-rule>
    
    constraint-expression:
  </bnf-rule>
        <bnf-alt>
    
    logical-or-expression
  </bnf-alt>
    
  </bnf-grammar>

    </p><p para_num="3" id="temp.constr.3">A <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> is a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    </p><ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="4" id="temp.constr.4">A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
    is required is ill-formed.</p>

    <p para_num="5" id="temp.constr.5">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P &amp;&amp; Q
P || (Q &amp;&amp; R)
M == N              // only if the result type is bool
has_trait&lt;T&gt;::value // only if value is a bool member
M &lt; N               // only if the result type is bool
M + N &gt;= 0
P || !(M &lt; N)
true
false</code></pre>
  
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="6" id="temp.constr.6">A subexpression of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"><a title="dcl.concept" href="#dcl.concept">7.1.7</a></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this section.</p>

    <p para_num="7" id="temp.constr.7">Certain subexpressions of a
    <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    </p><ul>
    <li>a <cxx-grammarterm><i>logical-or-expression</i></cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm><i>logical-and-expression</i></cxx-grammarterm> of the form
        <code>P &amp;&amp; Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>has_trait&lt;T&gt;::value
M &lt; N
M + N &gt;= 0
true
false</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    A concept check is not an atomic expression.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <!-- </p> -->

    <p para_num="8" id="temp.constr.8">Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="9" id="temp.constr.9">A concept check that calls a 
function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable 
concepts is simplified by substituting the template arguments into the 
variable's initializer. </p>

    <p para_num="10" id="temp.constr.10">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s its 
    <cxx-grammarterm><i>requirement-list</i></cxx-grammarterm>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Certain atomic constraints introduced by a 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>
 
    <p para_num="11" id="temp.constr.11">
    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    Let <code>P</code> and Q be variable templates
    that are atomic constraints.
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();</code></pre>
  
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
    
    <pre><code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p para_num="12" id="temp.constr.12">A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p para_num="13" id="temp.constr.13">
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p para_num="14" id="temp.constr.14">Two <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  
    </section>
  </cxx-section> <!-- temp.constr -->


    </section>
  </cxx-clause> <!-- temp -->






</body></html>