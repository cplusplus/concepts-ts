<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/concepts-ts -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-NOTE");document.createElement("CXX-GRAMMARTERM");document.createElement("BNF-GRAMMAR");document.createElement("BNF-RULE");document.createElement("BNF-ALT");document.createElement("BNF-TERMINAL");document.createElement("BNF-OPT");document.createElement("CXX-EXAMPLE");document.createElement("CXX-CODEBLOCK");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header:after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header:after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none;
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}core-xhr {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage {
	display: block; min-height: 100%;
}

@media print {
cxx-titlepage {
	height: 8.8in;
}


}

cxx-titlepage  {
	position: relative;
}

cxx-titlepage table {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepage h1 {
	position: absolute; top: 40%;
}

cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepage h1 {
	text-align: center;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

aside {  }


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}</style>
  <meta charset="utf-8">
  
  
  <style>
del.local {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}
del.local > * {
  color: Black;
  text-decoration: line-through;
  background-color: LightCoral; 
}

ins.local {
  color: Black;
  text-decoration: underline;
  background-color: LightSteelBlue; 
}
ins.local > * {
  color: Black;
  text-decoration: under;
  background-color: LightSteelBlue; 
}

.quoted {
  margin-left: .25in;
  margin-right: .35in;
}
</style>
<style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 9pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 9pt; }
    @bottom-left { content: string(current-section, last); font-size: 9pt; }
    @bottom-right { content: counter(page); font-size: 9pt; }
}
cxx-titlepage { page: title; page-break-after: always; }
@page title {
    @top-left { content: "© ISO 2014 — All rights reserved"; }
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 9pt; text-align: justify; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {
        height: 100%;
        text-align: justify; 
    }
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><title>C++ Extensions for Concepts, Working Draft</title></head>
<body>
<cxx-titlepage stage="draft">
    
    <table>
      
        <tbody><tr><th>Document Number:</th><td><cxx-docnum>Dxxxx</cxx-docnum></td></tr>
      
      
        <tr><th>Date:</th><td><time pubdate="">2014-11-04</time></td></tr>
      
      
        <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4205.pdf">N4205</a></cxx-revises></td></tr>
      
      
        <tr><th>Editor:</th><td><cxx-editor>
    Andrew Sutton<br>
    University of Akron<br>
    <cxx-email><a href="mailto:asutton@uakron.edu">asutton@uakron.edu</a></cxx-email>
  </cxx-editor></td></tr>
      
    </tbody></table>
    <h1>Working Draft, C++ Extensions for Concepts</h1>
    
      <p class="warning"><strong>Note: this is an early draft. It’s known to be
      incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#intro">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#intro.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#intro.refs">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#intro.compliance">Implementation compliance</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#intro.defs">Terms and definitions</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#intro.ack">Acknowledgments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#lex">Lexical conventions</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#lex.key">Keywords</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#expr">Expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#expr.prim">Primary expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.1</span><a href="#expr.prim.general">General</a>
        
      </li>
            
              <li><span class="marker">5.1.2</span><a href="#expr.prim.lambda">Lambda expressions</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#expr.prim.req">Requires expressions</a>
        
          <ol>
            
              <li><span class="marker">5.1.3.1</span><a href="#expr.prim.req.simple">Simple requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.2</span><a href="#expr.prim.req.type">Type requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.3</span><a href="#expr.prim.req.compound">Compound requirements</a>
        
      </li>
            
              <li><span class="marker">5.1.3.4</span><a href="#expr.prim.req.nested">Nested requirements</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#dcl.dcl">Declarations</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#dcl.spec">Specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6</span><a href="#dcl.type">Type specifiers</a>
        
          <ol>
            
              <li><span class="marker">7.1.6.2</span><a href="#dcl.type.simple">Simple type specifiers</a>
        
      </li>
            
              <li><span class="marker">7.1.6.4</span><a href="#dcl.spec.auto">auto specifier</a>
        
      </li>
            
              <li><span class="marker">7.1.6.5</span><a href="#dcl.spec.constr">Constrained type specifiers</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7.1.7</span><a href="#dcl.spec.concept">concept specifier</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#dcl.decl">Declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3</span><a href="#dcl.meaning">Meaning of declarators</a>
        
          <ol>
            
              <li><span class="marker">8.3.5</span><a href="#dcl.fct">Functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">10</span><a href="#class.derived">Derived classes</a>
        
          <ol>
            
              <li><span class="marker">10.3</span><a href="#class.virtual">Virtual functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13</span><a href="#over">Overloading</a>
        
          <ol>
            
              <li><span class="marker">13.2</span><a href="#over.dcl">Declaration matching</a>
        
      </li>
            
              <li><span class="marker">13.3</span><a href="#over.match">Overload resolution</a>
        
          <ol>
            
              <li><span class="marker">13.3.2</span><a href="#over.match.viable">Viable functions</a>
        
      </li>
            
              <li><span class="marker">13.3.3</span><a href="#over.match.best">Best viable function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">13.4</span><a href="#over.over">Address of overloaded function</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14</span><a href="#temp">Templates</a>
        
          <ol>
            
              <li><span class="marker">14.1</span><a href="#temp.param">Template parameters</a>
        
      </li>
            
              <li><span class="marker">14.2</span><a href="#temp.intro">Introduction of template parameters</a>
        
      </li>
            
              <li><span class="marker">14.3</span><a href="#temp.names">Names of template specializations</a>
        
      </li>
            
              <li><span class="marker">14.4</span><a href="#temp.arg">Template arguments</a>
        
          <ol>
            
              <li><span class="marker">14.4.3</span><a href="#temp.arg.template">Template template arguments</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5</span><a href="#temp.decls">Template declarations</a>
        
          <ol>
            
              <li><span class="marker">14.5.1</span><a href="#temp.class">Class templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.1.1</span><a href="#temp.mem.func">Member functions of class templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.2</span><a href="#temp.mem">Member templates</a>
        
      </li>
            
              <li><span class="marker">14.5.4</span><a href="#temp.friend">Friends</a>
        
      </li>
            
              <li><span class="marker">14.5.5</span><a href="#temp.class.spec">Class template partial specialization</a>
        
          <ol>
            
              <li><span class="marker">14.5.5.1</span><a href="#temp.class.spec.match">Matching of class template partial specializations</a>
        
      </li>
            
              <li><span class="marker">14.5.5.2</span><a href="#temp.class.order">Partial ordering of class template specializations</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.5.6</span><a href="#temp.fct">Function templates</a>
        
          <ol>
            
              <li><span class="marker">14.5.6.1</span><a href="#temp.over.link">Function template overloading</a>
        
      </li>
            
              <li><span class="marker">14.5.6.2</span><a href="#temp.func.order">Partial ordering of function templates</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.7</span><a href="#temp.spec">Template instantiation and specialization</a>
        
          <ol>
            
              <li><span class="marker">14.7.1</span><a href="#temp.inst">Implicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.2</span><a href="#temp.explicit">Explicit instantiation</a>
        
      </li>
            
              <li><span class="marker">14.7.3</span><a href="#temp.expl.spec">Explicit specialization</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.8</span><a href="#temp.fct.spec">Function template specializations</a>
        
          <ol>
            
              <li><span class="marker">14.8.2</span><a href="#temp.deduct">Template argument deduction</a>
        
          <ol>
            
              <li><span class="marker">14.8.2.6</span><a href="#temp.deduct.decl">Deducing template arguments from a function declaration</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9</span><a href="#temp.constr">Template constraints</a>
        
          <ol>
            
              <li><span class="marker">14.9.1</span><a href="#temp.constr.op">Logical operations</a>
        
      </li>
            
              <li><span class="marker">14.9.2</span><a href="#temp.constr.atom">Atomic constraints</a>
        
          <ol>
            
              <li><span class="marker">14.9.2.1</span><a href="#temp.constr.atom.pred">Predicate constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.2</span><a href="#temp.constr.atom.expr">Expression constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.3</span><a href="#temp.constr.atom.type">Type constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.4</span><a href="#temp.constr.atom.conv">Implicit conversion constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.5</span><a href="#temp.constr.atom.deduct">Argument deduction constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.2.6</span><a href="#temp.constr.atom.noexcept">Exception constraints</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">14.9.3</span><a href="#temp.constr.order">Partial ordering by constraints</a>
        
      </li>
            
              <li><span class="marker">14.9.4</span><a href="#temp.constr.expr">Constraint expressions</a>
        
      </li>
            
              <li><span class="marker">14.9.5</span><a href="#temp.concept.resolve">Concept resolution</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>


<cxx-clause id="intro">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#intro">[intro]</a></span></header>
      
  

  <cxx-section id="intro.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#intro.scope">[intro.scope]</a></span></header>
      
    
    <p para_num="1" id="intro.scope.1">This Technical Specification describes extensions to the C++ 
    Programming Language (<cxx-ref to="intro.refs"><a title="intro.refs" href="#intro.refs">1.2</a></cxx-ref>) that
    enable the specification and checking of constraints on template 
    arguments, and the ability to overload functions and specialize
    class templates based on those constraints. These extensions include 
    new syntactic forms and modifications to existing language semantics.</p>

    <p para_num="2" id="intro.scope.2">The International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document is 
    written as a set of changes against that specification. Instructions
    to modify or add paragraphs are written as explicit instructions. 
    Modifications made directly to existing text from the International
    Standard use <ins>underlining</ins> to represent added text and
    <del>strikethrough</del> to represent deleted text.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.refs">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#intro.refs">[intro.refs]</a></span></header>
      
    

    <p para_num="1" id="intro.refs.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC 14882:2014, <cite>Programming Languages - C++</cite>
      </li>
    </ul>

    <p para_num="2" id="intro.refs.2">ISO/IEC 14882:2014 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as
    "§3.2".</p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.compliance">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Implementation compliance">Implementation compliance</h1> <span style="float:right"><a href="#intro.compliance">[intro.compliance]</a></span></header>
      
    
    <p para_num="1" id="intro.compliance.1">Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance"><span title="intro.compliance">§1.4</span></cxx-ref>.
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Conformance is defined in terms of the behavior of
    programs.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.defs">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Terms and definitions">Terms and definitions</h1> <span style="float:right"><a href="#intro.defs">[intro.defs]</a></span></header>
      
    

    Modify the definitions of "signature" to include associated
    constraints (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).

    <dl>
    <dt>Signature</dt>
    <dd>
    &lt;function&gt; name, parameter type list 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), <del>and</del> 
    enclosing namespace (if any)<ins>, and associated constraints
    (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     
    Signatures are used as a basis for name mangling and linking.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </dd>
    
    <dt>Signature</dt>
    <dd>
    &lt;function template&gt; name, parameter type list 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), enclosing namespace (if any), 
    return type, <del>and</del> template parameter list<ins>,
    and and associated constraints (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>


    &lt;function&gt; name, parameter type list 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), <del>and</del> 
    enclosing namespace (if any)<ins>, and associated constraints
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     
    Signatures are used as a basis for name mangling and linking.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </dd>

    <dt>Signature</dt>
    <dd>
    &lt;class member function&gt; name, parameter type list 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), 
    class of which the function is a member, 
    <cxx-grammarterm><i>cv</i></cxx-grammarterm>-qualifiers (if any), <del>and</del> 
    <cxx-grammarterm><i>ref-qualifier</i></cxx-grammarterm> (if any)<ins>,
    and associated constraints (if any) (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
    </dd>

    <dt>Signature</dt>
    <dd>
    &lt;class member function template&gt; name, parameter type list 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), class of which the function is a 
    member, <cxx-grammarterm><i>cv</i></cxx-grammarterm>-qualifiers (if any), 
    <cxx-grammarterm><i>ref-qualifier</i></cxx-grammarterm> (if any), 
    return type, <del>and</del> template parameter list<ins>, and
    associated constraints (if any) (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
    </dd>

    </dl>
  
    </section>
  </cxx-section>

  <cxx-section id="intro.ack">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Acknowledgments">Acknowledgments</h1> <span style="float:right"><a href="#intro.ack">[intro.ack]</a></span></header>
      
    
  
    <p para_num="1" id="intro.ack.1">The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ Standard Library, known 
    as "The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p para_num="2" id="intro.ack.2">This work was funded by NSF grant ACI-1148461.</p>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>


<cxx-clause id="lex">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 Lexical conventions">Lexical conventions</h1> <span style="float:right"><a href="#lex">[lex]</a></span></header>
      
  

  <cxx-section id="lex.key" <="" cxx-section="">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Keywords">Keywords</h1> <span style="float:right"><a href="#lex.key">[lex.key]</a></span></header>
      
    

    In <cxx-ref in="cxx" to="lex.key"><span title="lex.key">§2.12</span></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.

  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="expr" number="5">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Expressions">Expressions</h1> <span style="float:right"><a href="#expr">[expr]</a></span></header>
      
  

  Modify paragraph 8 to include a reference to 
  <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s.

  <p para_num="8" id="expr.8" number="8" class="quoted">
  In some contexts, unevaluated operands appear
  (<cxx-ref in="cxx" to="expr.typeid"><span title="expr.typeid">§5.2.8</span></cxx-ref>,
  <cxx-ref in="cxx" to="expr.sizeof"><span title="expr.sizeof">§5.3.3</span></cxx-ref>,
  <cxx-ref in="cxx" to="expr.unary.noexcept"><span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>,
  <ins><cxx-ref in="cxx" to="expr.prim.req"><span title="expr.prim.req">§5.1.3</span></cxx-ref></ins>).
  </p>

  <!-- ===================
       Primary expressions
       =================== -->

  <cxx-section id="expr.prim">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Primary expressions">Primary expressions</h1> <span style="float:right"><a href="#expr.prim">[expr.prim]</a></span></header>
      
    
  
  <cxx-section id="expr.prim.general">
    

    <section>
      <header><span class="section-number">5.1.1</span> <h1 data-bookmark-label="5.1.1 General">General</h1> <span style="float:right"><a href="#expr.prim.general">[expr.prim.general]</a></span></header>
      
    

    In this section, add the 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> to the rule for 
    <cxx-grammarterm><i>primary-expression</i></cxx-grammarterm>.
    
    <bnf-grammar>
    
    
      <bnf-rule>
    
    primary-expression:
  </bnf-rule>
        <ins><bnf-alt>
    
    requires-expression
  </bnf-alt></ins>
    
  </bnf-grammar>

    <br>
    Add <code>auto</code> to <cxx-grammarterm><i>nested-name-specifier</i></cxx-grammarterm>:
    <bnf-grammar>
    
    
      <bnf-rule>
    
    nested-name-specifier:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    type-name <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    namespace-name <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    decltype-specifier <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    <ins><bnf-terminal><code>auto</code></bnf-terminal> <bnf-terminal><code>::</code></bnf-terminal></ins>
  </bnf-alt>
      <bnf-alt>
    
    nested-name-specifier identifier <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
      <bnf-alt>
    
    nested-name-specifier <bnf-opt>template<sub>opt</sub></bnf-opt> simple-template-id <bnf-terminal><code>::</code></bnf-terminal>
  </bnf-alt>
    
  </bnf-grammar>

    Add a new paragraph after paragraph 11:

    <p para_num="12" id="expr.prim.general.12" number="12" class="quoted">
      In a <cxx-grammarterm><i>nested-name-specifier</i></cxx-grammarterm> of the
      form <code>auto::</code>, the <code>auto</code> specifier is a
      placeholder for a type to be deduced
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>).
    </p>

    Add the following paragraph after paragraph 13 in the original
    document.

    <p para_num="14" id="expr.prim.general.14" number="14" class="quoted">
    If an <cxx-grammarterm><i>id-expression</i></cxx-grammarterm> denotes a
    non-overloaded function declaration that was declared with a
    <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
    its associated constraints shall be satisfied 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>void f(int) requires false;

f(0);               // <i>error: constraints not satisfied</i>
void (*p)(int) = f; // <i>error: constraints not satisfied</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

  
    </section>
  </cxx-section>

  <!-- ==================
       Lambda expressions
       ================== -->

    <cxx-section id="expr.prim.lambda">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Lambda expressions">Lambda expressions</h1> <span style="float:right"><a href="#expr.prim.lambda">[expr.prim.lambda]</a></span></header>
      
      

      Insert the following paragraph after paragraph 4 to define the
      term "generic lambda". 

      <p para_num="5" id="expr.prim.lambda.5" number="5" class="quoted">
      A <dfn>generic lambda</dfn> is a 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> where either the
      <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>)
      or a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>)
      appears in a parameter type of the
      <cxx-grammarterm><i>lambda-declarator</i></cxx-grammarterm>.
      </p>

      Modify paragraph 5 so that the meaning of a generic lambda is defined 
      in terms of its abbreviated member function template call operator.

      <p para_num="6" id="expr.prim.lambda.6" number="6" class="quoted">
      The closure type for a non-generic
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm> has a public inline 
      function call operator (<cxx-ref in="cxx" to="over.call"><span title="over.call">§13.5.4</span></cxx-ref>)
      whose parameters and return type are described by the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>, respectively. 

      <del>
      For a generic lambda, the closure type has a public inline function call
      operator member template (<cxx-ref to="temp.mem"><a title="temp.mem" href="#temp.mem">14.5.2</a></cxx-ref>) whose 
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> consists of 
      one invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      for each occurrence of <code>auto</code> in the lambda’s 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, in order 
      of appearance.

      The invented type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration declares</i></cxx-grammarterm> a 
      function parameter pack (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

      The return type and function parameters of the function call operator 
      template are derived from the 
      <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>’s 
      <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> and 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> by 
      replacing each occurrence of <code>auto</code> in the 
      <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
      with the name of the corresponding invented template-parameter.
      </del>

      <ins>
      For a generic lambda, the function call operator 
      (<cxx-ref in="cxx" to="over.call"><span title="over.call">§13.5.4</span></cxx-ref>)
      is an abbreviated function template (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).
      </ins>
      </p>

      Add the following example after those in 
      <cxx-ref in="cxx" to="expr.prim.lambda"><span title="expr.prim.lambda">§5.1.2</span></cxx-ref>/5. Note that
      the existing examples in the original document are omitted in this
      document.

      <ins>
      <p number="5" class="quoted">
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;

auto gl = [](C&amp; a, C* b) { a = *b }; // <i>OK: denotes a generic lambda</i>

struct Fun {
    auto operator()(C&amp; a, C* b) const { a = *b; }
} fun;</code></pre>
  
      <code>C</code> is a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>,
      signifying that the lambda is generic. The generic lambda <code>gl</code>
      and the function object <code>fun</code> have equivalent behavior when 
      called with the same arguments.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
      </ins>

    
    </section>
  </cxx-section> <!-- expr.prim.lambda -->


  <!-- ====================
       Requires expressions
       ==================== -->

  <cxx-section id="expr.prim.req">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Requires expressions">Requires expressions</h1> <span style="float:right"><a href="#expr.prim.req">[expr.prim.req]</a></span></header>
      
    

    <p para_num="1" id="expr.prim.req.1">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    
    A syntactic requirement is one that can be checked by name lookup 
    (<cxx-ref in="cxx" to="basic.lookup"><span title="basic.lookup">§3.4</span></cxx-ref>) or by checking
    properties of types and expressions. 

    <bnf-grammar>
    
    
      <bnf-rule>
    
    requires-expression:
  </bnf-rule>
        <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> 
          requirement-parameter-list requirement-body
  </bnf-alt>

    <bnf-rule>
    
    requirement-parameter-list:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>(</code></bnf-terminal> 
        <bnf-opt>parameter-declaration-clause<sub>opt</sub></bnf-opt>
        <bnf-terminal><code>)</code></bnf-terminal>
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-body:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>{</code></bnf-terminal> 
        requirement-list 
        <bnf-terminal><code>}</code></bnf-terminal> 
      
  </bnf-alt>

    <bnf-rule>
    
    requirement-list:
  </bnf-rule>
      <bnf-alt>
    
    requirement
  </bnf-alt>
      <bnf-alt>
    
    requirement-list requirement
  </bnf-alt>

    <bnf-rule>
    
    requirement:
  </bnf-rule>
      <bnf-alt>
    
    simple-requirement
  </bnf-alt>
      <bnf-alt>
    
    type-requirement
  </bnf-alt>
      <bnf-alt>
    
    compound-requirement
  </bnf-alt>
      <bnf-alt>
    
    nested-requirement
  </bnf-alt>
    
  </bnf-grammar>

    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> defines
    a conjunction of the constraints (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)
    introduced by its <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s.

    </p>

    <p para_num="2" id="expr.prim.req.2"> A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> has type
    <code>bool</code> and is an unevaluated operand 
    (<cxx-ref to="expr"><a title="expr" href="#expr">5</a></cxx-ref>).

    <!-- NOTE: There is a core issue related to determining when something
    is unevaluated. -->
    </p>

    <p para_num="3" id="expr.prim.req.3">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> shall appear
    only within a concept definition (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>),
    or a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
    <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) or
    function declaration (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    A common use of 
    <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s is to define
    syntactic requirements in concepts  
    such as the one below:
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -&gt; const A&lt;T&gt;&amp;;
    };
  }</code></pre>
  
    A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> can also be
    used in a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> templates 
    as a way of writing ad hoc constraints on template arguments such as 
    the one below:
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
The first <code>requires</code> introduces the 
<cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, and the second
introduces the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
Such requirements can also be written using by defining them within
a concept.
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt;
  concept bool C = requires (T x) { x + x; };

template&lt;typename T&gt; requires C&lt;T&gt; 
  T add(T a, T b) { return a + b; }</code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    <p></p>

    <p para_num="4" id="expr.prim.req.4">A <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> may introduce
    local parameters using a 
    <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
    (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>). 

    A local parameter of a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> 
    shall not have a default argument.
  
    Each name introduced by a local parameter is in scope from the point
    of its declaration until the closing brace of the
    <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm>.

    These parameters have no linkage, storage, or lifetime; they are only used
    as notation for the purpose of defining 
    <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s. 

    The <cxx-grammarterm><i>requirement-parameter-list</i></cxx-grammarterm> shall
    not include an ellipsis.
    </p>

    <p para_num="5" id="expr.prim.req.5">The <cxx-grammarterm><i>requirement-body</i></cxx-grammarterm> is comprised of 
    a sequence of <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s.

    These <cxx-grammarterm><i>requirement</i></cxx-grammarterm>s may refer to local 
    parameters, template parameters, and any other declarations visible from the 
    enclosing context. 

    Each <cxx-grammarterm><i>requirement</i></cxx-grammarterm> 
    appends one or more atomic constraints 
    (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) to the conjunction of constraints
    defined by the <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>s.
    </p>

    <p para_num="6" id="expr.prim.req.6">If the substitution of template arguments into an expression or type 
    in a <cxx-grammarterm><i>requirement</i></cxx-grammarterm> would always result in
    a substitution failure, the program is ill-formed; no diagnostic
    required.

    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C =
  requires () {
    new int[-sizeof(T)]; // <i>error</i>
  };</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>


  <!-- ====================
       Simple requirements
       ==================== -->

    <cxx-section id="expr.prim.req.simple">
    

    <section>
      <header><span class="section-number">5.1.3.1</span> <h1 data-bookmark-label="5.1.3.1 Simple requirements">Simple requirements</h1> <span style="float:right"><a href="#expr.prim.req.simple">[expr.prim.req.simple]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    simple-requirement:
  </bnf-rule>
          <bnf-alt>
    
    expression <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.simple.1">A <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> introduces 
      an expression constraint (<cxx-ref to="temp.constr.atom.expr"><a title="temp.constr.atom.expr" href="#temp.constr.atom.expr">14.9.2.2</a></cxx-ref>) 
      for its <cxx-grammarterm><i>expression</i></cxx-grammarterm>.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C =
  requires (T a, T b) {
    a + b;  // <i>a simple requirement</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.prim.req.simple.2"> The substitution of template arguments into the
      <cxx-grammarterm><i>expression</i></cxx-grammarterm> of a 
      <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> may result
      in an ill-formed expression. However, the resulting program is not 
      ill-formed. </p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.simple -->


  <!-- =================
       Type requirements
       ================= -->

    <cxx-section id="expr.prim.req.type">
    

    <section>
      <header><span class="section-number">5.1.3.2</span> <h1 data-bookmark-label="5.1.3.2 Type requirements">Type requirements</h1> <span style="float:right"><a href="#expr.prim.req.type">[expr.prim.req.type]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    type-requirement:
  </bnf-rule>
          <bnf-alt>
    
    
            typename-specifier <bnf-terminal><code>;</code></bnf-terminal>
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.type.1">A <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> introduces 
      a type constraint (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) for 
      the type named by its 
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm>.
      
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A type requirement asserts the validity of an associated
      type, either as a member type, a class template specialization,
      or an alias template. It is not used to specify requirements for
      arbitrary <cxx-grammarterm><i>type-specifiers</i></cxx-grammarterm>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; struct S { };
template&lt;typename T&gt; using Ref = T&amp;;

template&lt;typename T&gt; concept bool C =
  requires () {
    typename T::inner; // <i>required nested type name</i>
    typename S&lt;T&gt;;     // <i>required class template specialization</i>
    typename Ref&lt;T&gt;;   // <i>required alias template substitution</i>
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="expr.prim.req.type.2"> The substitution of template arguments into the
      <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> may result
      in an ill-formed type. However, the resulting program is not 
      ill-formed. </p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.type -->



    <!-- =====================
         Compound requirements
         ===================== -->

    <cxx-section id="expr.prim.req.compound">
    

    <section>
      <header><span class="section-number">5.1.3.3</span> <h1 data-bookmark-label="5.1.3.3 Compound requirements">Compound requirements</h1> <span style="float:right"><a href="#expr.prim.req.compound">[expr.prim.req.compound]</a></span></header>
      
      
      
      <bnf-grammar>
    
    
        <bnf-rule>
    
    compound-requirement:
  </bnf-rule>
          <bnf-alt>
    
    
            <bnf-terminal><code>{</code></bnf-terminal> expression <bnf-terminal><code>}</code></bnf-terminal>
            <bnf-opt><bnf-terminal><code>noexcept</code></bnf-terminal><sub>opt</sub></bnf-opt>
            <bnf-opt>trailing-return-type<sub>opt</sub></bnf-opt>
            <bnf-terminal><code>;</code></bnf-terminal>
          
  </bnf-alt>
      
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.compound.1">A <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> introduces 
      a conjunction of one or more atomic constraints for the
      <cxx-grammarterm><i>expression</i></cxx-grammarterm> <code>E</code>:
      
      </p><ul>
      <li>the <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> 
      introduces an expression constraint for <code>E</code>
      (<cxx-ref to="temp.constr.atom.expr"><a title="temp.constr.atom.expr" href="#temp.constr.atom.expr">14.9.2.2</a></cxx-ref>);</li>

      <li> if the the <code>noexcept</code> specifier is present, 
      the <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> appends an 
      exception constraint for <code>E</code>
      (<cxx-ref to="temp.constr.atom.noexcept"><a title="temp.constr.atom.noexcept" href="#temp.constr.atom.noexcept">14.9.2.6</a></cxx-ref>);</li>

      <li>
      if the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> is
      given and its type <code>T</code> contains no placeholders
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>, <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>),
      the requirement appends two constraints to the conjunction of 
      constraints: 
      
      a type constraint on the formation of <code>T</code>
      (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) and

      an implicit conversion constraint from <code>E</code> to <code>T</code>
      (<cxx-ref to="temp.constr.atom.conv"><a title="temp.constr.atom.conv" href="#temp.constr.atom.conv">14.9.2.4</a></cxx-ref>).

      Otherwise, if <code>T</code> contains placeholders, an argument deduction 
      constraint (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>)
      of <code>E</code> against the type <code>T</code>
      is appended to the conjunction of constraints. 
      </li>
      </ul>

      <cxx-example class="inline">
    
      <span class="nowrap">[ <em>Example:</em></span> <p/>
    
      The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> <code>C1</code> 
      introduces an expression constraint on <code>x++</code>.
      It is equivalent to a <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm>
      with the same <cxx-grammarterm><i>expression</i></cxx-grammarterm>.
      
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 =
  requires(T x) {
    {x++};
  };</code></pre>
  </cxx-codeblock>

      <cxx-codeblock>
    
      The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> <code>C2</code> 
      introduces three constraints: an expression constraint for <code>*x</code>, 
      a type constraint for <code>typename T::inner</code>, and a conversion 
      constraint requiring <code>*x</code> to be implicitly convertible to
      <code>typename T::inner</code>.

    <pre><code>template&lt;typename T&gt; concept bool C2 =
  requires(T x) {
    {*x} -&gt; typename T::inner;
  };</code></pre>
  </cxx-codeblock>

      <cxx-codeblock>
    
      The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> <code>C3</code> 
      introduces two constraints: an expression constraint for <code>g(x)</code> 
      and an exception constraint on <code>g(x)</code>.

    <pre><code>template&lt;typename T&gt; concept bool C3 =
  requires(T x) {
    {g(x)} noexcept;
  };</code></pre>
  </cxx-codeblock>

      The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> <code>C5</code> 
      introduces two constraints: an expression constraint for <code>f(x)</code>, 
      and a deduction constraint requiring that overload resolution succeeds for the
      call <code>g(f(x))</code> where <code>g</code> is the following
      invented abbreviated function template.
      
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }

template&lt;typename T&gt; concept bool C5 =
  requires(T x) {
    {f(x)} -&gt; const C&amp;;
  };</code></pre>
  </cxx-codeblock>

      <cxx-codeblock>
    
    <pre><code>void g(const C&amp;);</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p para_num="2" id="expr.prim.req.compound.2"></p>
      
      <p para_num="3" id="expr.prim.req.compound.3"> The substitution of template arguments into the
      <cxx-grammarterm><i>expression</i></cxx-grammarterm> of a 
      <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> may result
      in an ill-formed expression. However, the resulting program is not 
      ill-formed. </p>

    
    </section>
  </cxx-section> <!-- expr.prim.req.compound -->


    <cxx-section id="expr.prim.req.nested">
    

    <section>
      <header><span class="section-number">5.1.3.4</span> <h1 data-bookmark-label="5.1.3.4 Nested requirements">Nested requirements</h1> <span style="float:right"><a href="#expr.prim.req.nested">[expr.prim.req.nested]</a></span></header>
      
      

      <bnf-grammar>
    
    
        <bnf-rule>
    
    nested-requirement:
  </bnf-rule>
          <bnf-alt>
    
    requires-clause <bnf-terminal><code>;</code></bnf-terminal>
  </bnf-alt>
        
  </bnf-grammar>

      <p para_num="1" id="expr.prim.req.nested.1"> A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> can be used
      to specify additional constraints in terms of local parameters.

      A <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> appends the 
      normalized form (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>) of its
      <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> to the
      conjunction (<cxx-ref to="temp.constr.op.conj"><a title="temp.constr.op.conj" href="#temp.constr.op.conj">14.9.1.1</a></cxx-ref>) of 
      constraints introduced by its enclosing
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
     
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return sizeof(T) == 1; }

template&lt;typename T&gt; concept bool D =
  requires (T t) {
    requires C&lt;decltype (+t)&gt;();
  };</code></pre>
  
      The <cxx-grammarterm><i>nested-requirement</i></cxx-grammarterm> appends
      the predicate constraint <code>sizeof(decltype (+t)) == 1</code>
      (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>).
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
     <!-- expr.prim.req.nested -->
 
   <!-- expr.prim.req -->

 <!-- expr -->
<p></p>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-section>
    </section>
  </cxx-clause>

<cxx-clause id="dcl.dcl" number="7">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Declarations">Declarations</h1> <span style="float:right"><a href="#dcl.dcl">[dcl.dcl]</a></span></header>
      
  

  <!-- ==========
       Specifiers
       ========== -->

  <cxx-section id="dcl.spec">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Specifiers">Specifiers</h1> <span style="float:right"><a href="#dcl.spec">[dcl.spec]</a></span></header>
      
    

    Extend the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p para_num="1" id="dcl.spec.1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    decl-specifier:
  </bnf-rule>
        <ins><bnf-alt>
    
    <bnf-terminal><code>concept</code></bnf-terminal>
  </bnf-alt></ins>
    
  </bnf-grammar>
    </p>


    <!-- ===============
         Type specifiers
         =============== -->

    <cxx-section id="dcl.type" number="6">
    

    <section>
      <header><span class="section-number">7.1.6</span> <h1 data-bookmark-label="7.1.6 Type specifiers">Type specifiers</h1> <span style="float:right"><a href="#dcl.type">[dcl.type]</a></span></header>
      
      


      <!-- ======================
           Simple type specifiers
           ====================== -->

      <cxx-section id="dcl.type.simple" number="2">
    

    <section>
      <header><span class="section-number">7.1.6.2</span> <h1 data-bookmark-label="7.1.6.2 Simple type specifiers">Simple type specifiers</h1> <span style="float:right"><a href="#dcl.type.simple">[dcl.type.simple]</a></span></header>
      
        
        
        Add <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        to the grammar for <cxx-grammarterm><i>simple-type-specifier</i></cxx-grammarterm>s.

        <p para_num="1" id="dcl.type.simple.1" class="quoted">
        <bnf-grammar>
    
    
          <bnf-rule>
    
    simple-type-specifier:
  </bnf-rule>
            <ins><bnf-alt>
    
    constrained-type-specifier
  </bnf-alt></ins>
        
  </bnf-grammar>
        </p>
      
    </section>
  </cxx-section> <!-- dcl.type.simple -->


      <!-- ==============
           auto specifier
           ============== -->

      <cxx-section id="dcl.spec.auto" number="4">
    

    <section>
      <header><span class="section-number">7.1.6.4</span> <h1 data-bookmark-label="7.1.6.4 auto specifier"><code>auto</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.auto">[dcl.spec.auto]</a></span></header>
      
        

        Modify paragraph 1 to extend the use of <code>auto</code> to
        designate abbreviated function templates.

        <p para_num="1" id="dcl.spec.auto.1" number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>s <ins>(as well
        as <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s,
	<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>)</ins> designate <del>a</del>
        placeholder <del>type</del><ins>types</ins> that will be replaced 
	later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function template</ins>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code><ins>struct N {
  template&lt;typename T&gt; struct Wrap;
  template&lt;typename T&gt; static Wrap&lt;T&gt; make_wrap(T);
};
template&lt;typename T, typename U&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

template&lt;int N&gt; struct Size { void f(int) { }  };
Size&lt;0&gt; s;
bool g(char, double);

void (auto::*)(auto) p = &amp;Size&lt;0&gt;::f;   // <i>OK</i>
N::Wrap&lt;auto&gt; a = N::make_wrap(0.0);    // <i>OK</i>
Pair&lt;auto, auto&gt; p = make_pair(0, 'a'); // <i>OK</i>
auto::Wrap&lt;int&gt; x = N::make_wrap(0);    // <i>error: failed to deduce value for</i> auto
Size&lt;sizeof(auto)&gt; y = s;               // <i>error: failed to deduce value for</i> auto</ins></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        Modify paragraph 2, allowing multiple occurrences of <code>auto</code>
        in those contexts where it is valid.

        <p para_num="2" id="dcl.spec.auto.2" number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>, 
        <cxx-grammarterm><i>type-specifier-seq</i></cxx-grammarterm>,
        <cxx-grammarterm><i>conversion-function-id</i></cxx-grammarterm>, or
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>,
        in any context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify paragraph 3 to allow the use of <code>auto</code> within the 
        parameter type of a lambda or function.

        <p para_num="3" id="dcl.spec.auto.3" number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s
        in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm></del>
        <ins>in a parameter type</ins> 
        of a
        <cxx-grammarterm><i>lambda-expression</i></cxx-grammarterm>, the lambda is
        a generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        appears in a parameter type of a function declaration, the function
	declaration declares an
        abbreviated function template (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>void f(const auto&amp;, int); // <i>OK: an abbreviated function template</i></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        <p></p>

        Add the following after paragraph 3 to allow the use of 
        <code>auto</code> in the 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>.

        <p para_num="4" id="dcl.spec.auto.4" class="quoted">
        If the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm> 
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> 
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in
        a <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
        (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>), that
        return type introduces an argument deduction constraint
        (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>).
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -&gt; const auto&amp;; // <i>OK: introduces an argument deduction constraint</i>
  };
}</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        Modify paragraph 4 to allow multiple uses of <code>auto</code> within
        certain declarations. Note that the examples in the original text are 
        unchanged and therefore omitted.

        <p para_num="4" id="dcl.spec.auto.4" number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block"><span title="stmt.block">§6.3</span></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace"><span title="basic.scope.namespace">§3.3.6</span></cxx-ref>), and 
        in a <cxx-grammarterm><i>for-init-statement</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for"><span title="stmt.for">§6.5.3</span></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s in the 
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>
        </del>

        <ins>
        <code>auto</code> can appear anywhere in the declared type
        of the variable, but <code>decltype(auto)</code>
        shall appear only as one of the
        <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>s of the
        <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
    
    </cxx-codeblock></p><pre><code>( <i>expression-list</i> )</code></pre>
  
        the <cxx-grammarterm><i>expression-list</i></cxx-grammarterm> shall be a 
        single <cxx-grammarterm><i>assignment-expression</i></cxx-grammarterm>.
        <p></p>

        Update the rules in paragraph 7 to allow deduction of multiple
        occurrences of <code>auto</code> in a declaration.

        <p para_num="5" id="dcl.spec.auto.5" class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list"><span title="dcl.init.list">§8.5.4</span></cxx-ref>), the program is 
        ill-formed. 

        <del>
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing the 
        occurrences of <code>auto</code> with either a new invented type 
        template parameter <code>U</code> or, if the initializer is a 
        <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>, with 
        <code>std::initializer_list&lt;U&gt;</code>.
        </del>

        <ins>
        Otherwise, obtain <code>P</code> from <code>T</code> as follows:
        </ins></p><div class="quoted">
        <ul>
        <li><ins> replace each occurrence of <code>auto</code> in the
        variable type with a new invented type template parameter,
        or </ins></li>

        <li><ins> when the initializer is
        a <cxx-grammarterm><i>braced-init-list</i></cxx-grammarterm>
        and <code>auto</code> is a <cxx-grammarterm><i>decl-specifier</i></cxx-grammarterm>
        of the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
        the variable declaration, replace that occurrence of <code>auto</code> 
        with <code>std::initializer_list&lt;U&gt;</code>
        where <code>U</code> is an invented template type parameter.</ins></li>
        </ul>
        

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call"><span title="temp.deduct.call">§14.8.2.1</span></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code><ins>template&lt;typename T&gt; struct Vec { };
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initializer_list&lt;T&gt;) { return Vec&lt;T&gt;{}; } </ins>

auto x1 = { 1, 2 };                 // <ins><i>OK:</i></ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = *x1.begin();             // <i>OK:</i> decltype(x3) <i>is</i> int&amp;
const auto* p = &amp;x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltype(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3};           // <i>error: cannot deduce element type</i></ins></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>const auto &amp;i = expr;</code></pre>
  </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
    
    <pre><code>template &lt;class U&gt; void f(const U&amp; u);</code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <ins>Similarly, the type of <code>p</code> in the following program</ins>
        <cxx-codeblock>
    
    <pre><code><ins>template&lt;typename F, typename S&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

struct S { void mfn(bool); } s;
int fn(char, double);

Pair&lt;auto (*)(auto, auto), auto (auto::*)(auto)&gt; p = make_pair(fn, &amp;S::mfn);</ins></code></pre>
  </cxx-codeblock>
<ins>is the deduced type of the parameter <code>x</code> in the call of
<code>g(make_pair(fn, &amp;S::mfn))</code> of the following invented function 
template:</ins>
        <cxx-codeblock>
    
    <pre><code><ins>template&lt;class T1, class T2, class T2, class T3, class T4, class T5, class T6&gt;</ins>
  <ins>void g(Pair&lt; T1(*)(T2, T3), T4 (T5::*)(T6)&gt; x);</ins></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </div>

      
    </section>
  </cxx-section> <!-- dcl.spec.auto -->


      <!-- ===========================
           Constrained type specifiers
           =========================== -->

      <cxx-section id="dcl.spec.constr">
    

    <section>
      <header><span class="section-number">7.1.6.5</span> <h1 data-bookmark-label="7.1.6.5 Constrained type specifiers">Constrained type specifiers</h1> <span style="float:right"><a href="#dcl.spec.constr">[dcl.spec.constr]</a></span></header>
      
        

        Add this section to <cxx-ref in="cxx" to="dcl.type"><span title="dcl.type">§7.1.6</span></cxx-ref>.

        <p para_num="1" id="dcl.spec.constr.1"> Like the <code>auto</code> <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>),
        a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        designates a placeholder that will be replaced later by deduction
        from the <cxx-grammarterm><i>expression</i></cxx-grammarterm> in a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> or a
        function argument. 

        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s have
        the form

        <bnf-grammar>
    
    
          <bnf-rule>
    
    constrained-type-specifier:
  </bnf-rule>
            <bnf-alt>
    
    
              <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt> constrained-type-name
            
  </bnf-alt>

          <bnf-rule>
    
    constrained-type-name:
  </bnf-rule>
            <bnf-alt>
    
    concept-name
  </bnf-alt>
            <bnf-alt>
    
    partial-concept-id
  </bnf-alt>

          <bnf-rule>
    
    concept-name:
  </bnf-rule>
            <bnf-alt>
    
    identifier
  </bnf-alt>

          <bnf-rule>
    
    partial-concept-id:
  </bnf-rule>
            <bnf-alt>
    
    
              concept-name 
              <bnf-terminal><code>&lt;</code></bnf-terminal> 
              <bnf-opt>template-argument-list<sub>opt</sub></bnf-opt>
              <bnf-terminal><code>&gt;</code></bnf-terminal>
            
  </bnf-alt>
        
  </bnf-grammar>

        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        may also designate placeholders for deduced non-type and template 
        template arguments.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = false;
template&lt;int N&gt; concept bool C2 = false;
template&lt;template&lt;typename&gt; class X&gt; C3 = false;

template&lt;typename T, int N&gt; class Array { };
template&lt;typename T, template&lt;typename&gt; class A&gt; class Stack { };
template&lt;typename T&gt; class Alloc { };

void f1(C1 c);            // C1 <i>designates a placeholder type</i>
void f2(Array&lt;auto, C2&gt;); // C2 <i>designates a placeholder for an integer value</i>
void f3(Stack&lt;auto, C3&gt;); // C3 <i>designates a placeholder for a class template</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="2" id="dcl.spec.constr.2">
        A <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        can appear in many of the same places as the <code>auto</code>
        <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, is subject
        to the same rules, and has equivalent meaning in those contexts. 
        In particular, a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
        can appear in the following contexts with the given meaning:
        </p><ul>
        <li> a parameter type of a function declaration, signifying an 
             abbreviated function template (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>);</li>
        <li> a parameter of a lambda, signifying a generic lambda 
             (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>);</li>
        <li> the parameter type of a template parameter, signifying a
             constrained template parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>);</li>
        <li> the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of
             a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>
             (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>),
             signifying an argument deduction constraint 
             (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>). </li>
        </ul>
        A program that includes a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in any other contexts is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T, int N&gt; concept bool C2 = true;
template&lt;bool (*)(int)&gt; concept bool C3 = true;

template&lt;typename T&gt; class Vec;

struct N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;
template&lt;bool (*)(int)&gt; struct Pred;

auto gl = [](C1&amp; a, C1* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C1&gt;&amp; x);              // <i>OK: an abbreviated function template</i>

void f1(N::Wrap&lt;C1&gt;);     // <i>OK</i>
void f2(Pair&lt;C1, C2&lt;0&gt;&gt;); // <i>OK</i>
void f3(Pred&lt;C3&gt;);        // <i>OK</i>

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -&gt; const C1&amp;; // <i>OK: an argument deduction constraint</i>
  };
}</code></pre>
  </cxx-codeblock>
The declaration of <code>f4</code> is valid, but a value can never be deduced 
for the placeholder designated by <code>C1</code> since it appears in a
non-deduced context (<cxx-ref in="cxx" to="temp.deduct.type"><span title="temp.deduct.type">§14.8.2.5</span></cxx-ref>).
However, a value may be explicitly given as a template argument in a
<cxx-grammarterm><i>template-id</i></cxx-grammarterm>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        <!-- </p> -->

        <p para_num="3" id="dcl.spec.constr.3">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Unlike <code>auto</code>, a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> cannot 
        be used in the type of a variable declaration or the return type of
        a function.
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

const C* x = 0;  // <i>error:</i> C <i>used in a variable type</i>
D&lt;0&gt; fn(int x);  // <i>error:</i> D&lt;0&gt; <i>used as a return type</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        
    <span class="nowrap">— <em>end note</em> ]</span>
  
        <p></p>

        <p para_num="4" id="dcl.spec.constr.4">
        A <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> refers to a
        set of concept definitions (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        If that set is empty, the program is ill-formed.

        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member of this set when a 
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        refers to a variable concept.
        
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#3</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #3</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="5" id="dcl.spec.constr.5">
        A <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> is a
        <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>

        <p para_num="6" id="dcl.spec.constr.6">
        The concept designated by a 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is resolved by determining the viability of each concept in the
        candidate concept set.

        For each candidate concept in that set, <code>TT</code> is a 
        <cxx-grammarterm><i>template-id</i></cxx-grammarterm> formed as follows:

        let <code>C</code> be the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
        for the candidate concept set, and let <code>X</code> be a template 
        argument that matches
        the type and form (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.4</a></cxx-ref>) of the prototype 
        parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>)
        of the candidate concept. 

        The template <code>X</code> is called the 
        <dfn>deduced concept argument</dfn>.

        If the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> in
        the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, <code>TT</code> is
        formed as <code>C&lt;X&gt;</code>.

        Otherwise, the <cxx-grammarterm><i>constrained-type-name</i></cxx-grammarterm> is
        a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> whose
        <cxx-grammarterm><i>template-argument-list</i></cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub></code>, and
        <code>TT</code> is formed as
        <code>C&lt;X, A<sub>1</sub>, A<sub>2</sub>, ..., A<sub><i>n</i></sub>&gt;</code>.

        The candidate concept is a <dfn>viable candidate concept</dfn> when all
        <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> of <code>TT</code> 
        match the template parameters of that candidate 
        (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.4</a></cxx-ref>).

        If, after determining the viability of each concept, there is a
        single viable candidate concept, that is the concept designated by the
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i></code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        <p></p>


        <p para_num="7" id="dcl.spec.constr.7">The use of a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        associates a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the association is with
        the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>).

        For an abbreviated function template declaration
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>), the association is with that
        function template.

        When a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the 
        <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a 
        <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> it
        associates a <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        with the invented function template of the introduced argument 
        deduction constraint (<cxx-ref to="temp.constr.atom.deduct"><a title="temp.constr.atom.deduct" href="#temp.constr.atom.deduct">14.9.2.5</a></cxx-ref>).

        When a <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is used in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>,
        it associates a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> with the
        <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> in which the
        <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is declared.
        </p>

        <!-- FIXME: This is practically unreadable -->

        <p para_num="8" id="dcl.spec.constr.8"> The <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
        associated by a
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        is derived from the <cxx-grammarterm><i>template-id</i></cxx-grammarterm> 
        (called <code>TT</code> above) used to determine the viability of
        the designated concept (call it <code>D</code>).

        The constraint is formed by replacing the
        deduced concept argument <code>X</code> in <code>TT</code> with a 
        template argument, <code>A</code>. That template argument is
        defined as follows:
        </p><ul>
        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the type of a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
        of a function or lambda, 

        or when the when the 
        <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm>
        of a <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>,

        <code>A</code> is the name of the
        invented template parameter corresponding to the 
        placeholder in that (possibly invented) function template 
        (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>) ;</li>

        <li> when the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
        appears in a <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
        declaration, <code>A</code> is the name of the declared
        parameter (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>). </li>
        </ul>

        Let <code>TT2</code> be a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
        formed as follows. 

        If the template parameter <code>A</code> declares a template parameter 
        pack, and <code>D</code> is a variadic concept 
        (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>),
        <code>TT2</code> is formed by replacing the deduced concept
        argument <code>X</code> in 
        <code>TT</code> with the pack expansion <code>A...</code>.

        Otherwise <code>TT2</code> is formed by replacing <code>X</code>
        with <code>A</code>.

        Let <code>E</code> be the <cxx-grammarterm><i>id-expression</i></cxx-grammarterm>
        <code>TT2</code> when the <code>D</code> is a variable concept, and
        the function call <code>TT2()</code> when the <code>D</code> is a 
        function concept.

        If the template parameter <code>A</code> declares a template
        parameter pack, and <code>D</code> is not a variadic concept,
        then the associated constraint is the fold expression 
        <code>(E &amp;&amp; ...)</code>
        (<cxx-ref in="cxx" to="expr.prim.fold"><span title="expr.prim.fold">§5.1.4</span></cxx-ref>).
        
        Otherwise, the associated constraint is the expression <code>E</code>.
        
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }
template&lt;int N&gt; concept bool Num = true;

template&lt;int&gt; struct X { };

void f(C&amp;);              // <i>associates</i> C&lt;T1&gt; <i>with</i> f
void g(D&lt;int&gt;);          // <i>associates</i> D&lt;T2, int&gt;() <i>with</i> g
void h(X&lt;Num&gt;);          // <i>associates</i> Num&lt;M&gt; <i>with</i> h
template&lt;C T&gt; struct s1; // <i>associates</i> C&lt;T&gt; <i>with</i> s1</code></pre>
  </cxx-codeblock>
        Here, <code>T1</code> and <code>T2</code> are invented type template 
        parameters corresponding to the
        prototype parameter of their respective designated concepts.
        Likewise, <code>M</code> is an invented non-type template parameter
        corresponding to the prototype parameter of <code>Num</code>.
        <p></p>

        <p>Two <cxx-grammarterm><i>constrained-type-specifiers</i></cxx-grammarterm>
        are said to be equivalent if their associated
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s are
        equivalent according to the rules in 
        <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>.</p>

      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    </section>
  </cxx-section> <!-- dcl.spec.constr -->

    
    </section>
  </cxx-section> <!-- dcl.type -->


    <!-- =================
         concept specifier
         ================= --> 

    <cxx-section id="dcl.spec.concept">
    

    <section>
      <header><span class="section-number">7.1.7</span> <h1 data-bookmark-label="7.1.7 concept specifier"><code>concept</code> specifier</h1> <span style="float:right"><a href="#dcl.spec.concept">[dcl.spec.concept]</a></span></header>
      
      

      <p para_num="1" id="dcl.spec.concept.1"> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template, declared
      in namespace scope (<cxx-ref in="cxx" to="basic.scope.namespace"><span title="basic.scope.namespace">§3.3.6</span></cxx-ref>).
      
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A function
      concept is a non-throwing function 
      (<cxx-ref in="cxx" to="except.spec"><span title="except.spec">§15.4</span></cxx-ref>).

      When a function is declared to be a concept, it shall be the only
      declaration of that function.
      
      A variable template definition having the <code>concept</code> 
      specifier is called a <dfn>variable concept</dfn>.

      A <dfn>concept definition</dfn> refers to either a function concept 
      and its definition or a variable concept and its initializer.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; 
  concept bool F1() { return true; } // <i>OK: declares a function concept</i>
template&lt;typename T&gt; 
  concept bool F2();                 // <i>error: function concept is not a definition</i>
template&lt;typename T&gt; constexpr bool F3();
template&lt;typename T&gt;
  concept bool F3() { return true; } // <i>error: redeclaration of a function as a concept</i>
template&lt;typename T&gt; 
  concept bool V1 = true;            // <i>OK: declares a variable concept</i>
template&lt;typename T&gt; 
  concept bool V2;                   // <i>error: variable concept with no initializer</i>
struct S {
  template&lt;typename T&gt; 
    static concept bool C = true;    // <i>error: concept declared in class scope</i>
};</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="2" id="dcl.spec.concept.2"> Every concept definition is implicitly defined to be a 
      <code>constexpr</code> declaration 
      (<cxx-ref in="cxx" to="dcl.constexpr"><span title="dcl.constexpr">§7.1.5</span></cxx-ref>). </p>

      <p para_num="3" id="dcl.spec.concept.3"> A concept definition shall not be declared with the 
      <code>friend</code> or <code>constexpr</code> specifiers. 

      Additionally, a concept definition shall not have associated constraints
      (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>). </p>

      <p para_num="4" id="dcl.spec.concept.4">The definition of a function concept or the initializer of
      a variable concept shall not include a reference to the concept being
      declared.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
	concept bool F() { return F&lt;typename T::type&gt;(); } // error
template&lt;typename T&gt;
	concept bool V = V&lt;T*&gt;;                            // error</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="5" id="dcl.spec.concept.5"> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p para_num="6" id="dcl.spec.concept.6">A function concept has the following restrictions:
      </p><ul>
        <li> No <cxx-grammarterm><i>function-specifier</i></cxx-grammarterm>s shall
             appear in its declaration (<cxx-ref in="cxx" to="dcl.fct.spec"><span title="dcl.fct.spec">§7.1.2</span></cxx-ref>). </li>
        <li> The declared return type shall be the non-deduced type <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm><i>expression</i></cxx-grammarterm> shall be a
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
        (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).
        </li>
      </ul>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Return type deduction requires the instantiation of the function 
      definition, but concept definitions are not instantiated; they
      are normalized (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept int F1() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept auto F3(T) { return true; } // <i>error: return type is deduced</i>
template&lt;typename T&gt; 
  concept bool F2(T) { return true; } // <i>error: must have no parameters</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="7" id="dcl.spec.concept.7">A variable concept has the following restrictions:
      </p><ul>
        <li> The declared type shall be <code>bool</code>. </li>
        <li> The declaration shall have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; 
  concept bool V1 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
concept bool V3 = 0;       // <i>error: not a template</i>

template&lt;typename T&gt; concept bool C = true;

template&lt;C T&gt; 
  concept bool V2 = true;  // <i>error: constrained template declared as a concept</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <!-- </p> -->

      <p para_num="8" id="dcl.spec.concept.8">A program that declares an explicit instantiation
      (<cxx-ref to="temp.explicit"><a title="temp.explicit" href="#temp.explicit">14.7.2</a></cxx-ref>), an explicit specialization 
      (<cxx-ref to="temp.expl.spec"><a title="temp.expl.spec" href="#temp.expl.spec">14.7.3</a></cxx-ref>), or a partial specialization 
      of a concept definition is ill-formed.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      This prevents users from subverting the constraint system by providing a 
      meaning for a concept that differs from its original definition.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

    
    </section>
  </cxx-section> <!-- dcl.concept -->

  
    </section>
  </cxx-section> <!-- dcl.spec -->

    </section>
  </cxx-clause> <!-- dcl.dcl -->


<cxx-clause id="dcl.decl" number="8">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Declarators">Declarators</h1> <span style="float:right"><a href="#dcl.decl">[dcl.decl]</a></span></header>
      
  

  Factor the grammar of <cxx-grammarterm><i>declarator</i></cxx-grammarterm>s to
  allow the specification of constraints on function declarations.

  <p para_num="4" id="dcl.decl.4" number="4" class="quoted">
  <bnf-grammar>
    
    
  <bnf-rule>
    
    declarator:
  </bnf-rule>
    <del>
    <bnf-alt>
    
    ptr-declarator
  </bnf-alt>
    <bnf-alt>
    
    noptr-declarator parameters-and-qualifiers trailing-return-type
  </bnf-alt>
    </del>
    <ins>
    <bnf-alt>
    
    basic-declarator <bnf-opt>requires-clause<sub>opt</sub></bnf-opt>
  </bnf-alt>
    </ins>

  <ins>
  <bnf-rule>
    
    basic-declarator:
  </bnf-rule>
    <bnf-alt>
    
    ptr-declarator
  </bnf-alt>
    <bnf-alt>
    
    noptr-declarator parameters-and-qualifiers trailing-return-type
  </bnf-alt>
  </ins>
  
  </bnf-grammar>
  </p>

  Add the following paragraph at the end of this section.

  <p para_num="6" id="dcl.decl.6" number="6" class="quoted">
  The optional <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>) in a
  <cxx-grammarterm><i>declarator</i></cxx-grammarterm> shall be present only when
  the declarator declares a function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>).

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>void f1(int a) requires true;         // <i>OK</i>
auto f2(int a) -&gt; bool requires true; // <i>OK</i>
void (*pf)() requires true;           // <i>error: constraint on a variable</i>
void g(int (*)() requires true);      // <i>error: constraint on a parameter</i>
  
auto* p = new void(*[3])(char) requires true; // <i>error: not a function declaration</i></code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>


  <!-- ======================
       Meaning of declarators
       ====================== -->

  <cxx-section id="dcl.meaning" number="3">
    

    <section>
      <header><span class="section-number">8.3</span> <h1 data-bookmark-label="8.3 Meaning of declarators">Meaning of declarators</h1> <span style="float:right"><a href="#dcl.meaning">[dcl.meaning]</a></span></header>
      
    


    <!-- =========
         Functions
         ========= -->

    <cxx-section id="dcl.fct" number="5">
    

    <section>
      <header><span class="section-number">8.3.5</span> <h1 data-bookmark-label="8.3.5 Functions">Functions</h1> <span style="float:right"><a href="#dcl.fct">[dcl.fct]</a></span></header>
      
      

      Modify the matching condition in paragraph 1 to accept
      a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.
      
      <p para_num="1" id="dcl.fct.1" number="1" class="quoted">
      <bnf-grammar>
    
    
      <bnf-terminal><code>D1</code></bnf-terminal> 
      <bnf-terminal><code>(</code></bnf-terminal> parameter-declaration-clause <bnf-terminal><code>)</code></bnf-terminal>
      <bnf-opt>cv-qualifier-seq<sub>opt</sub></bnf-opt> <br>
      <bnf-opt>ref-qualifier<sub>opt</sub></bnf-opt>
      <bnf-opt>exception-specification<sub>opt</sub></bnf-opt> 
      <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
      <bnf-opt>requires-clause<sub>opt</sub></bnf-opt>
      
  </bnf-grammar>
      </p>

      Modify the matching condition in paragraph 2 to accept
      a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>.

      <p para_num="1" id="dcl.fct.1" number="1" class="quoted">
      <bnf-grammar>
    
    
      <bnf-terminal><code>D1</code></bnf-terminal> 
      <bnf-terminal><code>(</code></bnf-terminal> parameter-declaration-clause <bnf-terminal><code>)</code></bnf-terminal> 
      <bnf-opt>cv-qualifier-seq<sub>opt</sub></bnf-opt> <br>
      <bnf-opt>ref-qualifier<sub>opt</sub></bnf-opt>
      <bnf-opt>exception-specification<sub>opt</sub></bnf-opt> 
      <bnf-opt>attribute-specifier-seq<sub>opt</sub></bnf-opt> 
      trailing-return-type
      <bnf-opt>requires-clause<sub>opt</sub></bnf-opt>
      
  </bnf-grammar>
      </p>

<!--
      Refactor the grammar for 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>s in
      paragraph 3 in order to support the definition of
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s in
      Clause 14.

      <p class="quoted" number="3">
      <bnf-grammar>
        <bnf-rule>parameter-declaration</bnf-rule>
          <del>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> 
            decl-specifier-seq declarator
          </bnf-alt>
          
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> 
            decl-specifier-seq declarator 
            <bnf-terminal>=</bnf-terminal> 
            initializer-clause
          </bnf-alt>
          
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
          
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator</bnf-opt> 
            <bnf-terminal>=</bnf-terminal> 
            initializer-clause</bnf-alt>
          </del>

          <ins>
          <bnf-alt>
            basic-parameter-declaration
          </bnf-alt>
          <bnf-alt>
            basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer
          </bnf-alt>
          </ins>

        <ins>
        <bnf-rule>basic-parameter-declaration</bnf-rule>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt>
            decl-specifier-seq 
            declarator
          </bnf-alt>
          <bnf-alt>
            <bnf-opt>attribute-specifier-seq</bnf-opt> 
            decl-specifier-seq 
            <bnf-opt>abstract-declarator</bnf-opt>
          </bnf-alt>
        </ins>
      </p>
-->


      Modify the second sentence of paragraph 5. The remainder of this
      paragraph has been omitted.

      <p para_num="5" id="dcl.fct.5" class="quoted" number="5">
      A single name can be used for several different functions in a single 
      scope; this is function overloading (Clause <cxx-ref to="over"><a title="over" href="#over">13</a></cxx-ref>). 

      All declarations for a function shall agree exactly in <del>both</del> 
      the return type<ins>,</ins> <del>and</del> the parameter-type-list<ins>,
      and associated constraints, if any 
      (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
      </p>

      Modify paragraph 6 to exclude constraints from the type of a function.
      Note that the change occurs in the sentence following the example
      in the original document.

      <p para_num="6" id="dcl.fct.6" class="quoted" number="6">
      The return type, the parameter-type-list, the 
      <cxx-grammarterm><i>ref-qualifier</i></cxx-grammarterm>, and the 
      <cxx-grammarterm><i>cv-qualifier-seq</i></cxx-grammarterm>, but not the 
      default arguments 
      (<cxx-ref in="cxx" to="dcl.fct.default"><span title="dcl.fct.default">§8.3.6</span></cxx-ref>)<ins>, constraints 
      associated by an optional <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
      (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>),</ins> or
      the exception specification (<cxx-ref in="cxx" to="except.spec"><span title="except.spec">§15.4</span></cxx-ref>), 
      are part of the function type.
      </p>

      Modify paragraph 15. Note that the footnote reference has been
      omitted.

      <p para_num="15" id="dcl.fct.15" class="quoted" number="15">
      There is a syntactic ambiguity when an ellipsis occurs at the end of a 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> without
      a preceding comma. In this case, the ellipsis is parsed as part of the 
      <cxx-grammarterm><i>abstract-declarator</i></cxx-grammarterm> if the type of the
      parameter either names a template parameter pack that has not been 
      expanded or contains <ins>either</ins> <code>auto</code> <ins>or a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm></ins>; otherwise, 
      it is parsed as part of the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>.
      </p>

      Add the following paragraphs after paragraph 15.

      <p para_num="16" id="dcl.fct.16" class="quoted" number="16">
      An <dfn>abbreviated function template</dfn> is a function declaration whose
      parameter-type-list includes one or more placeholders 
      (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>,
      <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).

      An abbreviated function template is equivalent to a function template
      (<cxx-ref to="temp.fct"><a title="temp.fct" href="#temp.fct">14.5.6</a></cxx-ref>) whose
      <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      includes one invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
      for each occurrence of a placeholder in the 
      <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm>, 
      in order of appearance. 

      If the placeholder is designated by the <code>auto</code>
      <cxx-grammarterm><i>type-specifier</i></cxx-grammarterm>, then the corresponding
      invented template parameter is a type 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      Otherwise, the placeholder is designated by a
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>, and
      the corresponding invented parameter matches the type and form of
      the prototype parameter (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) of 
      the concept designated by the 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>.

      The invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> is 
      a parameter pack if the corresponding 
      <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm>
      declares a function parameter pack and the type of the parameter 
      contains only one placeholder.

      The adjusted function parameters of an abbreviated function template are derived
      from the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> 
      by replacing each occurrence of a placeholder with the name of the 
      corresponding invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.

      If the replacement of a placeholder with the name of a template parameter
      results in an invalid parameter declaration, the program is ill-formed.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; class Vec { };
template&lt;typename T, typename U&gt; class Pair { };

void f1(const auto&amp;, auto);
void f2(Vec&lt;auto*&gt;...);
void f3(auto (auto::*)(auto));

template&lt;typename T, typename U&gt; 
  void f1(const T&amp;, U);        // <i>redeclaration of</i> f1(const auto&amp;, auto)
template&lt;typename... T&gt; 
  void f2(Vec&lt;T*&gt;...);         // <i>redeclaration of</i> f2(Vec&lt;auto*&gt;...)
template&lt;typename T, typename U, typename V&gt;
  void f3(T (U::*)(V));        // <i>redeclaration of</i> f3(auto (auto::*)(auto))

template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;
template&lt;typename T, typename U&gt; concept bool D = true;

void g1(const C1*, C2&amp;);
void g2(Vec&lt;C1&gt;&amp;);
void g3(C1&amp;...);
void g4(Vec&lt;D&lt;int&gt;&gt;);

template&lt;C1 T, C2 U&gt; void g1(const T*, U&amp;); // <i>redeclaration of</i> g1(const C1*, C2&amp;)
template&lt;C1 T&gt; void g2(Vec&lt;T&gt;&amp;);            // <i>redeclaration of</i> g2(Vec&lt;C1&gt;&amp;)
template&lt;C1... Ts&gt; void g3(Ts&amp;...);         // <i>redeclaration of</i> g3(C1&amp;...)
template&lt;D&lt;int&gt; T&gt; void g4(Vec&lt;T&gt;);         // <i>redeclaration of</i> g4(Vec&lt;D&lt;int&gt;&gt;)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; concept bool Num = true;

void h(Num*); // <i>error: invalid type in parameter declaration</i></code></pre>
  </cxx-codeblock>
The equivalent declaration would have this form:
      <cxx-codeblock>
    
    <pre><code>template&lt;int N&gt; void h(N*); // <i>error: invalid type</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p></p>

      <p para_num="17" id="dcl.fct.17"> A function template can be an abbreviated function template. The
      invented <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s are
      added to the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
      after the explicitly declared <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N&gt; class Array { };

template&lt;int N&gt; void f(Array&lt;auto, N&gt;*);
template&lt;int N, typename T&gt; void f(Array&lt;T, N&gt;*); // OK: equivalent to f(Array&lt;auto, N&gt;*)</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>


      <p para_num="18" id="dcl.fct.18"> All placeholders introduced by
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      that are equivalent according to the definition in
      <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref> have the
      same invented template parameter.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>namespace N {
  template&lt;typename T&gt; concept bool C = true;
}
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int&gt; concept bool D = true;
template&lt;typename, int = 0&gt; concept bool E = true;

void f0(C a, C b);</code></pre>
  
      The types of <code>a</code> and <code>b</code> are the same invented template
      type parameter.

      <cxx-codeblock>
    
    <pre><code>void f1(C&amp; a, C* b);</code></pre>
  </cxx-codeblock>
      The type of <code>a</code> is a reference to an invented template type parameter 
      (call it <code>T</code>), and the type of <code>b</code> is a pointer to 
      <code>T</code>.

      <cxx-codeblock>
    
    <pre><code>void f2(N::C a, C b);
void f3(D&lt;0&gt; a, D&lt;1&gt; b);</code></pre>
  </cxx-codeblock>
      In both functions, the parameters <code>a</code> and
      <code>b</code> have different invented template type parameters.

      <cxx-codeblock>
    
    <pre><code>void f4(E a, E&lt;&gt; b, E&lt;0&gt; c);</code></pre>
  </cxx-codeblock>
      The types of <code>a</code>, <code>b</code>, and <code>c</code> are
      the same because the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
      <code>E</code>, <code>E&lt;&gt;</code>, and <code>E&lt;0&gt;</code>
      all associate the <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      <code>E&lt;T, 0&gt;</code>, where <code>T</code> is an invented
      template type parameter.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  <p></p>

    
    </section>
  </cxx-section> <!-- dcl.fct -->
  
  
    </section>
  </cxx-section> <!-- dcl.meaning -->


    </section>
  </cxx-clause> <!-- dcl.decl -->


<cxx-clause id="class.derived" number="10">
    

    <section>
      <header><span class="section-number">10</span> <h1 data-bookmark-label="10 Derived classes">Derived classes</h1> <span style="float:right"><a href="#class.derived">[class.derived]</a></span></header>
      
  

  <cxx-section id="class.virtual" number="3">
    

    <section>
      <header><span class="section-number">10.3</span> <h1 data-bookmark-label="10.3 Virtual functions">Virtual functions</h1> <span style="float:right"><a href="#class.virtual">[class.virtual]</a></span></header>
      
    

    Insert the following paragraph after paragraph 5 in order to
    prohibit the declaration of constrained virtual functions and
    the overriding of a virtual function by a constrained member
    function.

    <p para_num="6" id="class.virtual.6" class="quoted" number="6">
    If a virtual function has associated constraints 
    (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), the program is ill-formed.
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>struct A {
  virtual void f() requires true; // <i>error: constrained virtual function</i>
};

struct B {
  virtual void f();
};

struct D : B {
  void f() requires true; // <i>error: constrained override</i>
};</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    
    </section>
  </cxx-section> <!-- class.virtual -->


    </section>
  </cxx-clause> <!-- class.derived -->


<cxx-clause id="over" number="13">
    

    <section>
      <header><span class="section-number">13</span> <h1 data-bookmark-label="13 Overloading">Overloading</h1> <span style="float:right"><a href="#over">[over]</a></span></header>
      
  

  Modify paragraph 1 to allow overloading based on constraints.

  <p para_num="1" id="over.1" class="quoted">
  When two or more different declarations are specified for a single name 
  in the same scope, that name is said to be overloaded. By extension, two 
  declarations in the same scope that declare the same name but with
  different types 
  <ins>or different associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>
  are called <dfn>overloaded declarations</dfn>. Only function and function 
  template declarations can be overloaded; variable and type declarations 
  cannot be overloaded.
  </p>

  Update paragraph 3 to mention a function's overloaded constraints. 
  Note that the itemized list in the original text is omitted in this
  document.

  <p para_num="3" id="over.3" number="3" class="quoted">
  <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
  As specified in <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>, function declarations 
  that have equivalent parameter declarations 
  <ins>and associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>,
  declare the same function and therefore cannot be overloaded: ...
  
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>


  <cxx-section id="over.dcl" number="2">
    

    <section>
      <header><span class="section-number">13.2</span> <h1 data-bookmark-label="13.2 Declaration matching">Declaration matching</h1> <span style="float:right"><a href="#over.dcl">[over.dcl]</a></span></header>
      
    

    Modify paragraph 1 to extend the notion of declaration matching to
    also include a function's associated constraints. Note that the
    example in the original text is omitted in this document.

    <p para_num="1" id="over.dcl.1" class="quoted">
    Two function declarations of the same name refer to the same function if 
    they are in the same scope and have equivalent parameter declarations 
    (<cxx-ref in="cxx" to="over.load"><span title="over.load">§13.1</span></cxx-ref>)
    <ins>and equivalent associated constraints, 
    if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>)</ins>.
    </p>
  
    </section>
  </cxx-section> <!-- over.dcl -->

  <cxx-section id="over.match">
    

    <section>
      <header><span class="section-number">13.3</span> <h1 data-bookmark-label="13.3 Overload resolution">Overload resolution</h1> <span style="float:right"><a href="#over.match">[over.match]</a></span></header>
      
    

    <cxx-section id="over.match.viable" number="2">
    

    <section>
      <header><span class="section-number">13.3.2</span> <h1 data-bookmark-label="13.3.2 Viable functions">Viable functions</h1> <span style="float:right"><a href="#over.match.viable">[over.match.viable]</a></span></header>
      
      

      Update paragraph 1 to require the checking of a candidate's associated
      constraints when determining if that candidate is viable.

      <p para_num="1" id="over.match.viable.1" class="quoted">
      From the set of candidate functions constructed for a given context 
      (<cxx-ref in="cxx" to="over.match.funcs"><span title="over.match.funcs">§13.3.1</span></cxx-ref>), a set of viable 
      functions is chosen, from which the best function will be selected by 
      comparing argument conversion sequences and associated constraints
      for the best fit (<cxx-ref to="over.match.best"><a title="over.match.best" href="#over.match.best">13.3.3</a></cxx-ref>).

      The selection of viable functions considers 
      <ins>associated constraints, if any (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), and</ins>
      relationships between arguments and function parameters other 
      than the ranking of conversion sequences.
      </p>

      Insert a new paragraph after paragraph 2; this introduces
      new a criterion for determining if a candidate is viable. Also, update
      the beginning of the subsequent paragraphs to account for the
      insertion.

      <p para_num="3" id="over.match.viable.3" class="quoted" number="3">
      <ins>
      Second, for a function to be viable, if it has 
      associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), those 
      constraints shall be satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      </ins>
      </p>

      <p para_num="4" id="over.match.viable.4" class="quoted" number="4">
      <del>Second</del><ins>Third</ins>, for <code>F</code> to be a viable function ...
      </p>

    
    </section>
  </cxx-section> <!-- over.match.viable -->

    <cxx-section id="over.match.best">
    

    <section>
      <header><span class="section-number">13.3.3</span> <h1 data-bookmark-label="13.3.3 Best viable function">Best viable function</h1> <span style="float:right"><a href="#over.match.best">[over.match.best]</a></span></header>
      
      

      Modify the last item in the list in paragraph 1 and extend it with
      a final comparison based on the associated constraints of those
      functions. Note that the preceding (unmodified) items in the original 
      document are elided in this document.

      <p para_num="1" id="over.match.best.1" class="quoted">
      Define ICS<i>i</i>(<code>F</code>) as follows:
      </p><ul>
      <li> ... </li>
      <li> <code>F1</code> and <code>F2</code> are function template 
      specializations, and the function template for <code>F1</code> is more 
      specialized than the template for <code>F2</code> according to the 
      partial ordering rules described in 
      <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref><del>.</del><ins>, or, 
      if not that,</ins> </li>
      
      <li><ins>
      <code>F1</code> and <code>F2</code> are non-template functions with the
      same parameter-type-lists, and  <code>F1</code> is more constrained than 
      <code>F2</code> according to the partial ordering of constraints 
      described in <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.
      </ins></li>
      </ul>
      <!-- </p> -->
    
    </section>
  </cxx-section> <!-- over.match.best -->
  
    </section>
  </cxx-section> <!-- over.match -->



  <cxx-section id="over.over">
    

    <section>
      <header><span class="section-number">13.4</span> <h1 data-bookmark-label="13.4 Address of overloaded function">Address of overloaded function</h1> <span style="float:right"><a href="#over.over">[over.over]</a></span></header>
      
    

    Insert the following after paragraph 3 to remove those functions
    whose constraints are not satisfied.

    <p para_num="4" id="over.over.4" number="4" class="quoted">
    </p>

    Modify paragraph 4 (paragraph 5 in this document) to incorporate 
    constraints in the selection of an overloaded function when its address is 
    taken. Also add the following example after that in the original document 
    (not shown here).

    <p para_num="5" id="over.over.5" number="5" class="quoted">
    <ins>Eliminate from the set of selected functions all those whose constraints
    are not satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).</ins>


    <del>If more than one function is selected</del>
    <ins>If more than one function in the set remains</ins>, 
    any function template specializations in the set are eliminated if the 
    set also contains a function that is not a function template
    specialization<del>, and</del><ins>. 

    Any given non-template function
    <code>F0</code> is eliminated if the set contains a second non-template
    function that is more constrained than <code>F0</code> according to
    the partial ordering rules of 
    <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.</ins>
    
    <ins>Furthermore,</ins> any given function template specialization
    <code>F1</code> is eliminated if the set contains a second function 
    template specialization whose function template is more specialized than 
    the function template of <code>F1</code> according to the partial ordering 
    rules of <cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>.

    After such eliminations, if any, there shall remain exactly one 
    selected function.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>void f();                // <i>#1</i>
void f() requires true ; // <i>#2</i>
void g() requires false;
void g() requires false and true;

void (*pf)() = &amp;f;         // <i>selects #2</i>
void (*pg)() = &amp;g;         // <i>error: no matching function</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>
    
    </section>
  </cxx-section> <!-- over.over -->


    </section>
  </cxx-clause>


<cxx-clause id="temp" number="14">
    

    <section>
      <header><span class="section-number">14</span> <h1 data-bookmark-label="14 Templates">Templates</h1> <span style="float:right"><a href="#temp">[temp]</a></span></header>
      
  

  Modify the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p para_num="1" id="temp.1" number="1" class="quoted">
  <bnf-grammar>
    
    
    <bnf-rule>
    
    template-declaration:
  </bnf-rule>
      <bnf-alt>
    
    
        <bnf-terminal><code>template</code></bnf-terminal>
        <bnf-terminal><code>&lt;</code></bnf-terminal>
        template-parameter-list
        <bnf-terminal><code>&gt;</code></bnf-terminal>
        <ins><bnf-opt>requires-clause<sub>opt</sub></bnf-opt></ins>
        declaration
      
  </bnf-alt>
      <ins>
      <bnf-alt>
    
    template-introduction declaration
  </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>
    
    requires-clause:
  </bnf-rule>
      <bnf-alt>
    
    <bnf-terminal><code>requires</code></bnf-terminal> constraint-expression
  </bnf-alt>
    </ins>
  
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after paragraph 6.

  <p para_num="7" id="temp.7" number="7" class="quoted"> 
  A <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), or they are
  introduced by a <cxx-grammarterm><i>template-introduction</i></cxx-grammarterm>
  (<cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>).
  </p>


  <p para_num="8" id="temp.8" class="quoted">
  The <dfn>associated constraints</dfn> of a 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> are the 
  logical <code>&amp;&amp;</code> of all 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s introduced by:
  </p>
  
  <div class="quoted">
  <ul>
  <li> a concept introduction, and</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> following a
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>, and</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>)
  in the declaration's <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>,
  and </li>

  <li> any <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>decl-specifier-seq</i></cxx-grammarterm> of
  a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>), and</li>

  <li> a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> appearing after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> of an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general"></a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem"></a></cxx-ref>).</li>
  </ul>

  Let <code>T1</code> be a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  with associated constraints. <code>T1</code> is equivalent to another
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T2</code>) 
  whose template parameters are declared explicitly as unconstrained template 
  parameters, and <code>T2</code> has a single
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> whose 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T1</code> 
  (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>). <code>T2</code> is said
  to be the <dfn>canonical declaration</dfn> of all declarations that are 
  equivalent to it according to the rules below.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);</code></pre>
  </cxx-codeblock>
  The last declaration is the canonical declaration of <code>g(T)</code>.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
  </div>

  <p para_num="8" id="temp.8" class="quoted" number="8"> 
  When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> is
  declared by a template introduction (<cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>), 
  its canonical declaration is a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> whose
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> is defined 
  according to the rules for introducing template parameters in
  <cxx-ref to="temp.intro"><a title="temp.intro" href="#temp.intro">14.2</a></cxx-ref>, and the 
  equivalent declaration has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> 
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  formed as follows.

  Let <code>TT</code> be a <cxx-grammarterm><i>template-id</i></cxx-grammarterm>
  formed as 
  <code>C&lt;I<i>1</i>, I<i>2</i>, ..., I<i>n</i>, D<i>1</i>, D<i>2</i>, ..., D<i>n</i>&gt;</code>
  where <code>C</code> is the name of the designated concept,
  <code>I<i>1</i>, I<i>2</i>, ..., I<i>n</i></code> is the sequence
  of introduced template parameters, and
  <code>D<i>1</i>, D<i>2</i>, ..., D<i>n</i></code> is the (possibly empty)
  sequence of instantiated default template arguments needed to form the
  <cxx-grammarterm><i>template-id</i></cxx-grammarterm> that refers to <code>C</code>.

  If an introduced parameter declares a template parameter pack, the
  corresponding template argument in the <code>TT</code> is a pack
  expansion (<cxx-ref in="cxx" to="temp.variadic"><span title="temp.variadic">§14.5.3</span></cxx-ref>).
  
  If <code>C</code> is a variable concept, then the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  the <cxx-grammarterm><i>id-expression</i></cxx-grammarterm> <code>TT</code>.
  
  If <code>C</code> is a function concept, then the
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is
  the function call <code>TT()</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt; // <i>constraint associated by</i> C4{...Qs}
    void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p para_num="9" id="temp.9" class="quoted">
  When a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T1</code>) is
  explicitly declared with a <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>), 
  its canonical declaration is a 
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm> (call it <code>T2</code>)
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).
  
  The declaration, <code>T2</code>, has a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  whose <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is the
  conjunction of the <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s 
  associated by the constrained template parameters in <code>T1</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration <code>T1</code> includes a 
  <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, its
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>T2</code>.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="10" id="temp.10" class="quoted"> 
  When the declaration is an abbreviated function template, it is
  equivalent to a <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>. The associated constraints of the
  abbreviated function template are evaluated in the order in which they appear.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="11" id="temp.11" class="quoted"> 
  An abbreviated function template can also be declared as a
  <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s
  in the <cxx-grammarterm><i>parameter-declaration-clause</i></cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>s in the
  <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> and the
  following <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>, if present.
  This is also the case for an abbreviated function template that
  is declared with a concept introduction.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)</code></pre>
  
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <p para_num="12" id="temp.12" class="quoted"> 
  A <dfn>trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm></dfn> 
  is a <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> that appears after
  the <cxx-grammarterm><i>declarator</i></cxx-grammarterm> in an
  <cxx-grammarterm><i>init-declarator</i></cxx-grammarterm>
  (<cxx-ref to="dcl.decl"><a title="dcl.decl" href="#dcl.decl">8</a></cxx-ref>),
  <cxx-grammarterm><i>function-definition</i></cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"><a title="dcl.fct.def.general" href="#dcl.fct.def.general">8.4.1</a></cxx-ref>), or
  <cxx-grammarterm><i>member-declarator</i></cxx-grammarterm>
  (<cxx-ref to="class.mem"><a title="class.mem" href="#class.mem">9.2</a></cxx-ref>).

  When a constrained function template or member function template is
  declared with a trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm>
  it is equivalent to a declaration in which the 
  <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> of the
  trailing <cxx-grammarterm><i>requires-clause</i></cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
  <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)</code></pre>
  
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  
    <span class="nowrap">— <em>end example</em> ]</span>
  
  <p></p>

  <!-- FIXME: Does this need to go somewhere? Notes refer to it as 
       redundant. -->
  <!--  
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p> 
  -->


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    

    <section>
      <header><span class="section-number">14.1</span> <h1 data-bookmark-label="14.1 Template parameters">Template parameters</h1> <span style="float:right"><a href="#temp.param">[temp.param]</a></span></header>
      
    

    In paragraph 1, extend the grammar for template parameters to 
    constrained template parameters.

    <p para_num="1" id="temp.param.1" number="1" class="quoted">
    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-parameter:
  </bnf-rule>
        <ins>
        <bnf-alt>
    
    constrained-parameter
  </bnf-alt>
        </ins>

      <ins>
      <bnf-rule>
    
    constrained-parameter:
  </bnf-rule>
        <bnf-alt>
    
    
          constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt>
        
  </bnf-alt>
        <bnf-alt>
    
    
          constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt> <bnf-terminal><code>=</code></bnf-terminal> type-id
        
  </bnf-alt>
        <bnf-alt>
    
    
          constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt> <bnf-terminal><code>=</code></bnf-terminal> id-expression
        
  </bnf-alt>
        <bnf-alt>
    
    
          constrained-type-specifier <bnf-opt>...<sub>opt</sub></bnf-opt> <bnf-opt>identifier<sub>opt</sub></bnf-opt> <bnf-terminal><code>=</code></bnf-terminal> initializer-clause
        
  </bnf-alt>
    </ins>
  </bnf-grammar>
    </p>

    Insert a new paragraph after paragraph 1.

    <p para_num="2" id="temp.param.2" number="2" class="quoted">
    There is an ambiguity in the syntax of a 
    <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> and
    a <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>. 

    If the <cxx-grammarterm><i>type-specifier-seq</i></cxx-grammarterm> of
    a <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> is a
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>, then
    the <cxx-grammarterm><i>parameter-declaration</i></cxx-grammarterm> is a
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>.
    </p>

    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.

    <p para_num="9" id="temp.param.9" number="9" class="quoted">
    A <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> declares a 
    template parameter whose type and form match that of the prototype 
    parameter of the concept designated by its 
    <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
    The designated concept is selected by concept resolution
    (<cxx-ref to="temp.concept.resolve"><a title="temp.concept.resolve" href="#temp.concept.resolve">14.9.5</a></cxx-ref>). 

    <!-- TODO: Specify the associated constraint? -->

    Let <code>P</code> be the prototype parameter of the designated
    concept. The declared template parameter is determined by the type
    and form of <code>P</code> and the optional ellipsis in the
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>.
    <!-- FIXME: this last line should not be template-parameter. -->
    </p>
    
    <div class="quoted">
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> the declared 
    parameter is a type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>. 
    </li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, the declared
    parameter is a non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same type as <code>P</code>. </li>

    <li> If <code>P</code> is a template 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>, the declared
    parameter is a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>
    having the same <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm>
    as <code>P</code>, excluding default template arguments. </li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>I</code> shall include an ellipsis, and the declared parameter
    is a template parameter pack. </li>
    </ul>

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error:</i> Ts <i>must be preceded by an ellipsis</i>
template&lt;C5... Cs&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i></code></pre>
  </cxx-codeblock>
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    </div>

    Insert the following paragraph after paragraph 9 to restrict the forms 
    of default template argument for 
    <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>.

    <p para_num="10" id="temp.param.10" number="10" class="quoted">
    The default <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> of
    a <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> shall match
    the kind (type, non-type, template) of the declared parameter.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;int N&gt; concept bool C2 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C3 = true;

template&lt;typename T&gt; struct S0;

template&lt;C1 T = int&gt; struct S1; // OK
template&lt;C2 N = 0&gt; struct S2;   // OK
template&lt;C3 X = S0&gt; struct S3;  // OK
template&lt;C1 T = 0&gt; struct S4;   // error: default argument is not a type</code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

  
    </section>
  </cxx-section> <!-- temp.param -->


  <!-- ===================================
       Introduction of template parameters
       =================================== -->

  <cxx-section id="temp.intro" number="2">
    

    <section>
      <header><span class="section-number">14.2</span> <h1 data-bookmark-label="14.2 Introduction of template parameters">Introduction of template parameters</h1> <span style="float:right"><a href="#temp.intro">[temp.intro]</a></span></header>
      
    

    Add this section after <cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>.

    <p para_num="1" id="temp.intro.1"> A <dfn>template introduction</dfn> provides a convenient way of declaring
    different templates that have the same template parameters and constraints.

    <bnf-grammar>
    
    
      <bnf-rule>
    
    template-introduction:
  </bnf-rule>
        <bnf-alt>
    
    
          <bnf-opt>nested-name-specifier<sub>opt</sub></bnf-opt>
          concept-name
          <bnf-terminal><code>{</code></bnf-terminal> introduction-list <bnf-terminal><code>}</code></bnf-terminal>
        
  </bnf-alt>

      <bnf-rule>
    
    introduction-list:
  </bnf-rule>
        <bnf-alt>
    
    introduced-parameter
  </bnf-alt>
        <bnf-alt>
    
    introduction-list<bnf-terminal><code>,</code></bnf-terminal> introduced-parameter
  </bnf-alt>

        <bnf-rule>
    
    introduced-parameter:
  </bnf-rule>
          <bnf-alt>
    
    <bnf-opt><bnf-terminal><code>...</code></bnf-terminal><sub>opt</sub></bnf-opt> identifier
  </bnf-alt>
      
    
  </bnf-grammar>

    A template introduction declares a sequence of 
    <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s, which are derived 
    from a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
    and the sequence of <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s in 
    its <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>.


    </p><p para_num="2" id="temp.intro.2"> The concept designated by the <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
    is selected by concept resolution 
    (<cxx-ref to="temp.concept.resolve"><a title="temp.concept.resolve" href="#temp.concept.resolve">14.9.5</a></cxx-ref>).

    </p><p para_num="3" id="temp.intro.3">
    For each 
    <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> <code>I</code> in an
    <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm>,
    and for its corresponding selected template parameter <code>P</code>
    from the designated concept, declare a new template 
    parameter using the rules for declaring a constrained parameter in
    <cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref> by using <code>I</code> as a
    <cxx-grammarterm><i>declarator-id</i></cxx-grammarterm> and <code>P</code>
    as the prototype parameter.

    If <code>I</code> contains an ellipsis, <code>P</code> declares a template 
    parameter pack.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N, typename... Xs&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;

C1{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;    // B <i>is declared as</i> int B
               // C <i>is declared as</i> typename... C

C1{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

C2{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

C2{...X}      // <i>error: the corresponding parameter is not a</i> 
  void bar(); // <i>template parameter pack</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="4" id="temp.intro.4">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    A concept referred to by a <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> 
    may have template parameters with default template arguments. An
    <cxx-grammarterm><i>introduction-list</i></cxx-grammarterm> may omit 
    <cxx-grammarterm><i>identifier</i></cxx-grammarterm>s for a corresponding template
    parameter if it has a default argument. However, only the
    <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>s are declared
    as template parameters. 
    
    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename A, typename B = bool&gt; 
  concept bool C() { return true; }

C{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                // <i>a single template type parameter</i> T</code></pre>
  
  There is no <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> 
  that corresponds to the template parameter <code>B</code> in the
  <code>C</code> concept, so <code>f(T)</code> is declared with only
  one template parameter.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    
    <span class="nowrap">— <em>end note</em> ]</span>
  
    <p></p>


    <p para_num="5" id="temp.intro.5"> An introduced template parameter does not have a default template 
    argument even if its corresponding template parameter does.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i></code></pre>
  
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

    <p para_num="6" id="temp.intro.6"> 
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    The introduction of a sequence of template parameters by a
    <cxx-grammarterm><i>concept-name</i></cxx-grammarterm> associates a constraint 
    with the <cxx-grammarterm><i>template-declaration</i></cxx-grammarterm>
    according to the rules described in Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>.
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

  
    </section>
  </cxx-section> <!-- temp.intro -->


  <!-- =================================
       Names of template specializations
       ================================= -->

  <cxx-section id="temp.names">
    

    <section>
      <header><span class="section-number">14.3</span> <h1 data-bookmark-label="14.3 Names of template specializations">Names of template specializations</h1> <span style="float:right"><a href="#temp.names">[temp.names]</a></span></header>
      
    

    <!-- NOTE: This is a core issue DR. -->
    <!--
    Add the following paragraph to require the implicit instantiation
    of default template arguments for non-function templates.

    <p number="8" class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> does 
    not name a function, a default 
    <cxx-grammarterm>template-argument</cxx-grammarterm> is implicitly
    instantiated (<cxx-ref to="temp.inst"></cxx-ref>) in a context that 
    requires the value of that default argument.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, typename U = int&gt; struct S { };

S&lt;bool&gt;* p; // <i>the type of</i> p <i>i</i>s S&lt;bool, int&gt;*
    </cxx-codeblock>
    The default argument for <code>U</code> is instantiated to form
    the type <code>S&lt;bool, int&gt;*</code>, but the definition of that
    class template specialization is not implicitly instantiated
    (<cxx-ref to="temp.inst"></cxx-ref>); it is not used in a 
    context that requires a complete type.
    </cxx-example>
    </p>
    -->

    Add this paragraph to require the satisfaction of associated constraints
    on the formation of the <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm>.

    <p para_num="1" id="temp.names.1" class="quoted">
    When a <cxx-grammarterm><i>simple-template-id</i></cxx-grammarterm> names
    a constrained non-template function or a template template parameter,
    but not a member template that is a member of an unknown specialization
    (<cxx-ref in="cxx" to="temp.res"><span title="temp.res">§14.6</span></cxx-ref>),
    and all <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>s in the
    <cxx-grammarterm><i>template-id</i></cxx-grammarterm> are non-dependent
    (<cxx-ref in="cxx" to="temp.dep.temp"><span title="temp.dep.temp">§14.6.2.4</span></cxx-ref>), the template
    arguments are substituted into the associated constraints
    (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>). 

    If, as a result of substitution, the associated constraints are not 
    satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>), the 
    <cxx-grammarterm><i>template-id</i></cxx-grammarterm> is ill-formed.

    <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
    <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = false;

template&lt;C T&gt; struct S1 { };
template&lt;C T&gt; using Ptr = T*;

S1&lt;int&gt;* p; // <i>error: constraints not satisfied</i>
Ptr&lt;int&gt; p; // <i>error: constraints not satisfied</i>

template&lt;typname T&gt;
  struct S2 { Ptr&lt;int&gt; x; }; // <i>error: constraints not satisfied</i>

template&lt;typename T&gt;
  struct S3 { Ptr&lt;T&gt; x; }    // <i>OK: satisfaction is not required</i>

S3&lt;int&gt; x;                   // <i>error: constraints not satisfied</i>

template&lt;template&lt;C T&gt; class X&gt;
  struct S3 {
    X&lt;int&gt; x; // <i>error: constraints not satisfied</i>

    using Type = T::template MT&lt;char&gt;;
  };</code></pre>
  
    The error in the instantiation of <code>S3&lt;int&gt;</code> is caused
    by the substitution into the type of the member <code>x</code>.

    Because there is no declaration for the template named by 
    <code>T::template MT&lt;char&gt;</code>, it cannot have associated
    constraints.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  
    <p></p>

  
    </section>
  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    

    <section>
      <header><span class="section-number">14.4</span> <h1 data-bookmark-label="14.4 Template arguments">Template arguments</h1> <span style="float:right"><a href="#temp.arg">[temp.arg]</a></span></header>
      
    

    <cxx-section number="3" id="temp.arg.template">
    

    <section>
      <header><span class="section-number">14.4.3</span> <h1 data-bookmark-label="14.4.3 Template template arguments">Template template arguments</h1> <span style="float:right"><a href="#temp.arg.template">[temp.arg.template]</a></span></header>
      
      

      Modify paragraph 3 to include rules for matching constrained template 
      <cxx-grammarterm><i>template parameter</i></cxx-grammarterm>s. Note that the 
      examples following this paragraph in
      the original document are omitted.

      <p para_num="3" id="temp.arg.template.3" number="3" class="quoted">
      A <cxx-grammarterm><i>template-argument</i></cxx-grammarterm> matches 
      a template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      the <cxx-grammarterm><i>template-argument</i></cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>P</code><ins>, and <code>P</code> is at least as constrained as
      <code>A</code> according to the rules in 
      <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref></ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>), and 
      for template <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s matches, recursively. 

      When <code>P</code>’s <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic"><span title="temp.variadic">§14.5.3</span></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <div class="quoted">
      <ins>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </ins>
      </div>

    
    </section>
  </cxx-section> <!-- temp.arg.template -->
  
    </section>
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    

    <section>
      <header><span class="section-number">14.5</span> <h1 data-bookmark-label="14.5 Template declarations">Template declarations</h1> <span style="float:right"><a href="#temp.decls">[temp.decls]</a></span></header>
      
    


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
    

    <section>
      <header><span class="section-number">14.5.1</span> <h1 data-bookmark-label="14.5.1 Class templates">Class templates</h1> <span style="float:right"><a href="#temp.class">[temp.class]</a></span></header>
      
      

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. 

      <p para_num="3" id="temp.class.3" number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.
      </p>

      Add the following example at the end of paragraph 3.

      <div class="quoted">
      <ins>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;typename T&gt; requires C&lt;T&gt; void S&lt;T&gt;::f() { } // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; D{U} struct S&lt;T&gt;::Inner { }; // <i>OK</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </ins>
      </div>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
    

    <section>
      <header><span class="section-number">14.5.1.1</span> <h1 data-bookmark-label="14.5.1.1 Member functions of class templates">Member functions of class templates</h1> <span style="float:right"><a href="#temp.mem.func">[temp.mem.func]</a></span></header>
      
        

        Add the following example to the end of paragraph 1.

        <p para_num="1" id="temp.mem.func.1" number="1" class="quoted">
        <ins>
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></ins></p><pre><code>template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g() { }               // <i>error: no matching function in</i> S&lt;T&gt;</code></pre>
  
        
    <span class="nowrap">— <em>end example</em> ]</span>
  
        
        <p></p>
      
    </section>
  </cxx-section> <!-- temp.mem.func -->
    
    </section>
  </cxx-section> <!-- temp.class -->

    <!-- ================
         Member templates
         ================ -->

    <cxx-section id="temp.mem">
    

    <section>
      <header><span class="section-number">14.5.2</span> <h1 data-bookmark-label="14.5.2 Member templates">Member templates</h1> <span style="float:right"><a href="#temp.mem">[temp.mem]</a></span></header>
      
      

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. 

      <p para_num="1" id="temp.mem.1" number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm><i>template-parameter</i></cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.
      </p>

      Add the following example at the end of paragraph 1.

      <div class="quoted">
      <ins>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) &lt;= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::f(U) requires C2&lt;U&gt; { } // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U) { } // <i>error: no matching function in</i> S&lt;T&gt;</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </ins>
      </div>
    
    </section>
  </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ -->

    <cxx-section id="temp.friend" number="4">
    

    <section>
      <header><span class="section-number">14.5.4</span> <h1 data-bookmark-label="14.5.4 Friends">Friends</h1> <span style="float:right"><a href="#temp.friend">[temp.friend]</a></span></header>
      
      


      Modify paragraph 9 to restrict constrained friend declarations.

      <p para_num="9" id="temp.friend.9" number="9" class="quoted">
	When a friend declaration refers to a specialization of a function
	template, the function parameter declarations shall not include
	default arguments, <ins>the declaration shall not be
	constrained,</ins> nor shall the inline specifier be used in such a
	declaration.</p>

	<p para_num="10" id="temp.friend.10" class="quoted">
	<cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Other friend declarations can be constrained.  In a
	constrained friend declaration that is not a definition, the
	constraints are used for declaration
	matching.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = false;

template&lt;C1 T&gt; g0(T);
template&lt;C1 T&gt; g1(T);
template&lt;C2 T&gt; g2(T);

template&lt;typename T&gt;
  struct S {
    friend void f1() requires true;  // <i>OK</i>
    friend void f2() requires C1&lt;T&gt;; // <i>OK</i>
    friend void g0&lt;T&gt;(T) requires C&lt;T&gt;; // <i>error: constrained friend specialization</i>
    friend void g1&lt;T&gt;(T);            // <i>OK</i>
    friend void g2&lt;T&gt;(T);            // <i>ill-formed, no diagnostic required</i>
  };

void f1() requires true; // <i>friend of all S&lt;T&gt;</i>
void f2() requires C1&lt;int&gt;; // <i>friend of S&lt;int&gt;</i></code></pre>
  
      The friend declaration of <code>g2</code> is ill-formed, no
      diagnostic required, because no valid instantiation of <code>S</code>
      is possible: for all <code>T</code> there is no <code>g2&lt;T&gt;</code>
      for which the constraints are satisfied, so template argument
      deduction (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>) fails.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>
      <p para_num="11" id="temp.friend.11" class="quoted">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      Within a class template, a friend may define a non-template function
      whose constraints specify requirements on template arguments.
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></cxx-note></p><pre><code>template&lt;typename T&gt; concept bool Eq = requires (T t) { t == t; };

template&lt;typename T&gt;
  struct S {
    friend bool operator==(S a, S b) requires Eq&lt;T&gt; { return a == b; } // OK
  };</code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      In the instantiation of such a class template, the template
      arguments are substituted into the constraints but not evaluated.
      Constraints are checked (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) only when
      that function is considered as a viable candidate for overload resolution
      (<cxx-ref to="over.match.viable"><a title="over.match.viable" href="#over.match.viable">13.3.2</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.friend -->



    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
    

    <section>
      <header><span class="section-number">14.5.5</span> <h1 data-bookmark-label="14.5.5 Class template partial specialization">Class template partial specialization</h1> <span style="float:right"><a href="#temp.class.spec">[temp.class.spec]</a></span></header>
      
      

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p para_num="4" id="temp.class.spec.4" number="4" class="quoted">
      A class template partial specialization may be constrained
      (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;int I&gt; concept bool N = I &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      Remove the 3rd item in the list of paragraph 8 to allow
      constrained class template partial specializations like #6, and
      because it is redundant with the 4th item.
      Note that all other items in that list are elided. 

      <p para_num="8" id="temp.class.spec.8" number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      </p><ul>
      <li>...</li>
      <li><del>The argument list of the specialization shall
	not be identical to the implicit argument list of the
	primary template.</del></li>
      <li>The specialization shall be more specialized than the primary
	template (<cxx-ref to="temp.class.order"><a title="temp.class.order" href="#temp.class.order">14.5.5.2</a></cxx-ref>).</li>
      <li>...</li>
      </ul>
 
      <cxx-section id="temp.class.spec.match">
    

    <section>
      <header><span class="section-number">14.5.5.1</span> <h1 data-bookmark-label="14.5.5.1 Matching of class template partial specializations">Matching of class template partial specializations</h1> <span style="float:right"><a href="#temp.class.spec.match">[temp.class.spec.match]</a></span></header>
      
        

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. 

        <p para_num="2" id="temp.class.spec.match.2" number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"><span title="temp.deduct">§14.8.2</span></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)</ins>.
        </p>

        Add the following example to the end of paragraph 2.

        <div class="quoted">
        <ins>
        <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i></code></pre>
  </cxx-codeblock>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        </div>
      
    </section>
  </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
    

    <section>
      <header><span class="section-number">14.5.5.2</span> <h1 data-bookmark-label="14.5.5.2 Partial ordering of class template specializations">Partial ordering of class template specializations</h1> <span style="float:right"><a href="#temp.class.order">[temp.class.order]</a></span></header>
      
        

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. 

        <p para_num="1" id="temp.class.order.1" number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"><span title="temp.func.order">§14.5.6.2</span></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization, and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization, and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>

        Add the following example to the end of paragraph 1.

        <div class="quoted">
        <ins>
        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i></code></pre>
  </cxx-codeblock>
        The partial specialization #2 is more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
        </ins>
        </div>

      
    </section>
  </cxx-section> <!-- temp.class.order -->
    
    </section>
  </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
    

    <section>
      <header><span class="section-number">14.5.6</span> <h1 data-bookmark-label="14.5.6 Function templates">Function templates</h1> <span style="float:right"><a href="#temp.fct">[temp.fct]</a></span></header>
      
      

      <cxx-section id="temp.over.link">
    

    <section>
      <header><span class="section-number">14.5.6.1</span> <h1 data-bookmark-label="14.5.6.1 Function template overloading">Function template overloading</h1> <span style="float:right"><a href="#temp.over.link">[temp.over.link]</a></span></header>
      
        

        Modify paragraph 6 to account for constraints on function
        templates.

        <p para_num="6" id="temp.over.link.6" number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        </p>
        <div class="quoted">
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they:
        <ul>
        <li> are declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints that are equivalent using the rules 
             in <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref> to
             compare <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s.</li>
        </ul>
        </ins>
        </div>

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that <del>one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters</del>
        <ins>
        <ul> 
        <li>one or more expressions that involve template parameters in the 
        return types and parameter lists are functionally equivalent using 
        the rules described above to compare expressions involving template 
        parameters; or</li>

        <li> both function templates have associated constraints that are
        functionally equivalent but not equivalent, using the rules in 
        <cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref> to compare 
        <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s.</li>
        </ul>
        </ins>

        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      
    </section>
  </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
    

    <section>
      <header><span class="section-number">14.5.6.2</span> <h1 data-bookmark-label="14.5.6.2 Partial ordering of function templates">Partial ordering of function templates</h1> <span style="float:right"><a href="#temp.func.order">[temp.func.order]</a></span></header>
      
        

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p para_num="2" id="temp.func.order.2" number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by the rules in
        <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>.</ins>
        </p>

      
    </section>
  </cxx-section> <!-- temp.func.order -->

    
    </section>
  </cxx-section> <!-- temp.fct -->

  
    </section>
  </cxx-section> <!-- temp.decls -->


  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    

    <section>
      <header><span class="section-number">14.7</span> <h1 data-bookmark-label="14.7 Template instantiation and specialization">Template instantiation and specialization</h1> <span style="float:right"><a href="#temp.spec">[temp.spec]</a></span></header>
      
    


    <cxx-section id="temp.inst">
    

    <section>
      <header><span class="section-number">14.7.1</span> <h1 data-bookmark-label="14.7.1 Implicit instantiation">Implicit instantiation</h1> <span style="float:right"><a href="#temp.inst">[temp.inst]</a></span></header>
      
      

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p para_num="2" id="temp.inst.2" number="2" class="quoted">
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <!-- TODO: There is a note to put this into 14.6p8??? -->
      If substitution into the associated constraints would always result in an
      invalid type or expression, the program is ill-formed, no diagnostic
      required.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The satisfaction of constraints is determined during lookup or overload
      resolution (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>


      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { } // <i>#1</i>
  S() requires D&lt;T&gt; { } // <i>#2</i>
};

S&lt;char&gt; s1;    // <i>error: no matching constructor</i>
S&lt;char[8]&gt; s2; // <i>OK: calls #2</i></code></pre>
  
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization. This also
      has the effect of suppressing the implicit generation of a default 
      constructor (<cxx-ref in="cxx" to="class.ctor"><span title="class.ctor">§12.1</span></cxx-ref>)

      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; struct S2 {
    void f() requires T::value == 1;
  };

S2&lt;int&gt; s; // <i>error: substitution failure in definition of</i> S2&lt;int&gt;</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; struct S1 {
  template&lt;typename U&gt; requires false struct Inner1; // <i>OK</i>
};

template&lt;typename T&gt; struct S2 {
  template&lt;typename U&gt; 
    requires sizeof(T[(int)-sizeof(T)]) &gt; 1 // <i>error: ill-formed, no diagnostic required</i>
      struct Inner2;
};</code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      Every instantiation of <code>S1</code> results in a valid type,
      although any use of its nested <code>Inner1</code> template is invalid.

      <code>S2</code> is ill-formed, no diagnostic required, since no
      substitution into the constraints of its <code>Inner2</code>
      template would result in a valid expression.
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.inst -->


    <!-- ======================
         Explicit instantiation
         ====================== -->

    <cxx-section id="temp.explicit">
    

    <section>
      <header><span class="section-number">14.7.2</span> <h1 data-bookmark-label="14.7.2 Explicit instantiation">Explicit instantiation</h1> <span style="float:right"><a href="#temp.explicit">[temp.explicit]</a></span></header>
      
      

      Modify paragraph 8 to ensure that only members whose constraints are 
      satisfied are explicitly instantiated during class template 
      specialization. The note in the original document is omitted.

      <p para_num="8" id="temp.explicit.8" number="8" class="quoted">
      An explicit instantiation that names a class template specialization is 
      also an explicit instantiation of the same kind (declaration or 
      definition) of each of its members (not including members inherited from 
      base classes and members that are templates) that has not been previously 
      explicitly specialized in the translation unit containing the explicit 
      instantiation, 
      <ins>
      and provided that the associated constraints (<cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>), 
      if any, of that member are satisfied (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)
      by the template arguments of the explicit instantiation,
      </ins> 
      except as described below.
      </p>

      Add the following paragraphs to this section. These require an explicit
      instantiation of a constrained template to satisfy the template's
      associated constraints.

      <p para_num="14" id="temp.explicit.14" number="14" class="quoted">
      If the explicit instantiation names a class template specialization
      or variable template specialization of a constrained template, then
      the <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> in the
      <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of the explicit
      instantiation shall satisfy the template's associated constraints
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template struct S&lt;char&gt;;    // <i>OK</i>
template struct S&lt;char[2]&gt;; // <i>error: constraints not satisfied</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  

      <p></p><p para_num="15" id="temp.explicit.15" class="quoted">
      When an explicit instantiation refers to a specialization of a
      function template (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>), that 
      template's associated constraints shall be satisfied by the template 
      arguments of the explicit instantiation.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T) { } // <i>#1</i>
template&lt;typename T&gt; void g(T) { } // <i>#2</i>
template&lt;C T&gt;        void g(T) { } // <i>#3</i>

template void f(int);   // <i>OK: refers to #1</i>
template void f(void*); // <i>error: no matching template</i>
template void g(int);   // <i>OK: refers to #3</i>
template void g(void*); // <i>OK: refers to #2</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.explicit -->


    <!-- =======================
         Explicit specialization
         ======================= -->

    <cxx-section id="temp.expl.spec">
    

    <section>
      <header><span class="section-number">14.7.3</span> <h1 data-bookmark-label="14.7.3 Explicit specialization">Explicit specialization</h1> <span style="float:right"><a href="#temp.expl.spec">[temp.expl.spec]</a></span></header>
      
      

      Insert the following paragraphs after paragraph 12. These require
      an explicit specialization to satisfy the constraints of the primary
      template.

      <p para_num="12" id="temp.expl.spec.12" number="12" class="quoted">
      The <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> in the
      <cxx-grammarterm><i>template-id</i></cxx-grammarterm> of an explicit 
      specialization of a constrained non-template function shall satisfy the 
      associated constraints of that template, if any 
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template&lt;&gt; struct S&lt;char&gt; { };    // <i>OK</i>
template&lt;&gt; struct S&lt;char[2]&gt; { }; // <i>error: constraints not satisfied</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="13" id="temp.expl.spec.13" class="quoted">
      When determining the function template referred to by an explicit 
      specialization of a function template 
      (<cxx-ref to="temp.deduct.decl"><a title="temp.deduct.decl" href="#temp.deduct.decl">14.8.2.6</a></cxx-ref>),
      the associated constraints of that template (if any) shall be satisfied 
      (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>) by the
      template arguments of the explicit specialization.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T); // <i>#1</i>
template&lt;typename T&gt; void g(T); // <i>#2</i>
template&lt;C T&gt;        void g(T); // <i>#3</i>

template&lt;&gt; void f(int);   // <i>OK: refers to #1</i>
template&lt;&gt; void f(void*); // <i>error: no matching template</i>
template&lt;&gt; void g(int);   // <i>OK: refers to #3</i>
template&lt;&gt; void g(void*); // <i>OK: refers to #2</i></code></pre>
  
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

    
    </section>
  </cxx-section> <!-- temp.expl.spec -->
  
    </section>
  </cxx-section> <!-- temp.spec -->


  <!-- =================================
       Function template specializations
       ================================= -->

  <cxx-section id="temp.fct.spec" number="8">
    

    <section>
      <header><span class="section-number">14.8</span> <h1 data-bookmark-label="14.8 Function template specializations">Function template specializations</h1> <span style="float:right"><a href="#temp.fct.spec">[temp.fct.spec]</a></span></header>
      
    

    <cxx-section id="temp.deduct" number="2">
    

    <section>
      <header><span class="section-number">14.8.2</span> <h1 data-bookmark-label="14.8.2 Template argument deduction">Template argument deduction</h1> <span style="float:right"><a href="#temp.deduct">[temp.deduct]</a></span></header>
      
      

      Add the following sentences to the end of paragraph 5. This defines
      the substitution of template arguments into a function template's
      associated constraints. Note that the last part of paragraph 5
      has been duplicated in order to provide context for the addition.

      <p para_num="5" id="temp.deduct.5" number="5" class="quoted">
      When all template arguments have been deduced or obtained from default 
      template arguments, all uses of template parameters in the template 
      parameter list of the template and the function type are replaced with
      the corresponding deduced or default argument values. 

      If the substitution results in an invalid type, as described above, type 
      deduction fails.

      <ins>
      If the function template has associated constraints
      (Clause <cxx-ref to="temp"><a title="temp" href="#temp">14</a></cxx-ref>),
      the template arguments are substituted into the associated constraints
      without evaluating the resulting expression. If this substitution
      results in an invalid type or expression, type deduction fails.

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      The satisfaction of constraints (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>)
      associated with the function template specialization is determined during 
      overload resolution (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>), and not at 
      the point of substitution.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </ins>
      </p>

      <cxx-section id="temp.deduct.decl" number="6">
    

    <section>
      <header><span class="section-number">14.8.2.6</span> <h1 data-bookmark-label="14.8.2.6 Deducing template arguments from a function declaration">Deducing template arguments from a function declaration</h1> <span style="float:right"><a href="#temp.deduct.decl">[temp.deduct.decl]</a></span></header>
      
        

        Add the following after paragraph 1 in order to require the
        satisfaction of constraints when matching a specialization to a
        template.

        <p para_num="2" id="temp.deduct.decl.2" number="2" class="quoted">
        Remove from the set of function templates considered all those
        whose associated constraints (if any) are not satisfied by the deduced
        template arguments (<cxx-ref to="temp.constr"><a title="temp.constr" href="#temp.constr">14.9</a></cxx-ref>).
        </p>

        Update paragraph 2 (now paragraph 3) to accommodate the new
        wording.

        <p para_num="3" id="temp.deduct.decl.3" class="quoted">
        If, 
        <del>for the set of function templates so considered</del>
        <ins>for the remaining function templates</ins>,
        there is either no match or more than one match after partial ordering 
        has been considered (<cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>), deduction fails 
        and, in the declaration cases, the program is ill-formed.
        </p>
      
    </section>
  </cxx-section> <!-- temp.deduct.decl -->

    
    </section>
  </cxx-section> <!-- temp.deduct -->

  
    </section>
  </cxx-section> <!-- temp.fct.spec -->


  <!-- ====================
       Template constraints
       ==================== -->

  <cxx-section id="temp.constr">
    

    <section>
      <header><span class="section-number">14.9</span> <h1 data-bookmark-label="14.9 Template constraints">Template constraints</h1> <span style="float:right"><a href="#temp.constr">[temp.constr]</a></span></header>
      
    

    Add this section after 14.8.

    <p para_num="1" id="temp.constr.1">
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    This section defines the meaning of constraints on template arguments, including
    the translation of <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s
    into constraints (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>),
    and also the abstract syntax, satisfaction, and subsumption of those 
    constraints
    (<cxx-ref to="temp.constr.op"><a title="temp.constr.op" href="#temp.constr.op">14.9.1</a></cxx-ref>, <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="2" id="temp.constr.2"> A <dfn>constraint</dfn> is a sequence of logical operations and 
    operands that specifies requirements on template arguments. 
    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The operands of a logical operation are constraints.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>


    <!-- NOTE: Satisfaction requires that the constraint has no
         dependent expressions or types -->
    <p para_num="3" id="temp.constr.3">
    After substitution, a constraint is <dfn>satisfied</dfn> if and only if 
    it and all of its operands are satisfied according to the evaluation 
    rules described in
    <cxx-ref to="temp.constr.op"><a title="temp.constr.op" href="#temp.constr.op">14.9.1</a></cxx-ref> and
    <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>.

    If the substitution of template arguments into a constraint fails, 
    that constraint is not satisfied.

    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Substitution into a constraint may yield a well-formed constraint that
    contains ill-formed expressions or types. This may happen, for
    example, in the substitution into expression constraints
    (<cxx-ref to="temp.constr.atom.expr"><a title="temp.constr.atom.expr" href="#temp.constr.atom.expr">14.9.2.2</a></cxx-ref>)
    and type constraints
    (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>).
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="4" id="temp.constr.4"> A constraint <code>P</code> is said to <dfn>subsume</dfn> another
    constraint <code>Q</code> if, informally, it can be determined that
    <code>P</code> implies <code>Q</code>, up to the equivalence of types
    and expressions in atomic constraints.
    <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>. 

    <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
    Subsumption does not determine, for example, if the predicate 
    constraint (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>) 
    <code>N % 2 == 1</code> subsumes <code>N &amp; 1</code> for 
    some integral template argument, <code>N</code>. 
    
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    
    The rules determining when one constraint subsumes another is given
    in <cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>, and subsumption
    rules for each kind of atomic constraint are given in
    <cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>.
    </p>

    <cxx-section id="temp.constr.op">
    

    <section>
      <header><span class="section-number">14.9.1</span> <h1 data-bookmark-label="14.9.1 Logical operations">Logical operations</h1> <span style="float:right"><a href="#temp.constr.op">[temp.constr.op]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.op.1"> There are two logical operations on constraints: conjunction
      and disjunction. </p>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
     
      These logical operations have no corresponding C++ syntax.
      For the purpose of exposition, conjunction is spelled
      using the symbol ∧, and disjunction is spelled using the 
      symbol ∨. Grouping of constraints is shown using parentheses.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>


      <!-- ===========
           Conjunction
           =========== -->

      <p para_num="2" id="temp.constr.op.2"> A <dfn>conjunction</dfn> is a logical operation taking two 
      operands. A conjunction of constraints is satisfied if and only 
      if both operands are satisfied. </p>

      <!-- ===========
           Disjunction
           =========== -->

      <p para_num="3" id="temp.constr.op.3"> A <dfn>disjunction</dfn> is a logical operation taking two 
      operands. A disjunction of constraints is satisfied if and only 
      if either operand is satisfied or both operands are satisfied. </p>

    
    </section>
  </cxx-section> <!-- temp.constr.op -->

    <!-- =================
         Atomic constraints
         ================== -->

    <cxx-section id="temp.constr.atom">
    

    <section>
      <header><span class="section-number">14.9.2</span> <h1 data-bookmark-label="14.9.2 Atomic constraints">Atomic constraints</h1> <span style="float:right"><a href="#temp.constr.atom">[temp.constr.atom]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.atom.1"> Any constraint that is not a conjunction or disjunction is an
      <dfn>atomic constraint</dfn>. </p>

        <!-- =====================
             Predicate constraints
             ===================== -->

        <cxx-section id="temp.constr.atom.pred">
    

    <section>
      <header><span class="section-number">14.9.2.1</span> <h1 data-bookmark-label="14.9.2.1 Predicate constraints">Predicate constraints</h1> <span style="float:right"><a href="#temp.constr.atom.pred">[temp.constr.atom.pred]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.pred.1"> A <dfn>predicate constraint</dfn> is an atomic constraint
          that evaluates a prvalue constant expression of type <code>bool</code>
          (<cxx-ref in="cxx" to="expr.const"><span title="expr.const">§5.19</span></cxx-ref>).
          The constraint is satisfied if and only if the expression 
          evaluates to <code>true</code>.
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Predicate constraints allow the definition of template requirements
          in terms of constant expressions. This allows the specification 
          constraints on non-type template arguments and template template 
          arguments.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = sizeof(T) == 4 &amp;&amp; !true;</code></pre>
  
          Here, <code>sizeof(T) == 4</code> and <code>!true</code> are 
          predicate constraints required by the concept, <code>C</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.pred.2">A predicate constraint <code>P</code> subsumes another
          predicate constraint <code>Q</code> if and only if
          <code>P</code> and <code>Q</code> are equivalent
          <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>s
          (<cxx-ref to="temp.constr.expr"><a title="temp.constr.expr" href="#temp.constr.expr">14.9.4</a></cxx-ref>).

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          The predicate <code>M &gt;= 0</code> does not subsume the predicate
          <code>M &gt; 0</code> because they are not equivalent
          <cxx-grammarterm><i>constraint-expressions</i></cxx-grammarterm>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
          </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.pred -->


        <!-- ======================
             Expression constraints
             ====================== -->

        <cxx-section id="temp.constr.atom.expr">
    

    <section>
      <header><span class="section-number">14.9.2.2</span> <h1 data-bookmark-label="14.9.2.2 Expression constraints">Expression constraints</h1> <span style="float:right"><a href="#temp.constr.atom.expr">[temp.constr.atom.expr]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.expr.1"> An <dfn>expression constraint</dfn> is an atomic constraint
          that specifies a requirement on the formation of an
          <cxx-grammarterm><i>expression</i></cxx-grammarterm> <code>E</code>
          through substitution of template arguments.

          An expression constraint is satisfied if substitution 
          yielding <code>E</code> did not fail. 
          
          Within an expression constraint, <code>E</code> is an unevaluated 
          operand (Clause <cxx-ref to="expr"><a title="expr" href="#expr">5</a></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          An expression constraint is introduced by the 
          <cxx-grammarterm><i>expression</i></cxx-grammarterm> in either a
          <cxx-grammarterm><i>simple-requirement</i></cxx-grammarterm> 
          (<cxx-ref to="expr.prim.req.simple"><a title="expr.prim.req.simple" href="#expr.prim.req.simple">5.1.3.1</a></cxx-ref>)
          or
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>)
          of a
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };</code></pre>
  
          The concept <code>C</code> introduces an expression constraint for 
          the expression <code>++t</code>.
          
          The type argument <code>int</code> satisfies this constraint because the
          the expression <code>++t</code> is valid after substituting <code>int</code>
          for <code>T</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.expr.2"> An expression constraint <code>P</code> subsumes another
          expression constraint <code>Q</code> if and only if
          the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.expr -->


        <!-- ================
             Type constraints
             ================ -->

        <cxx-section id="temp.constr.atom.type">
    

    <section>
      <header><span class="section-number">14.9.2.3</span> <h1 data-bookmark-label="14.9.2.3 Type constraints">Type constraints</h1> <span style="float:right"><a href="#temp.constr.atom.type">[temp.constr.atom.type]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.type.1"> A <dfn>type constraint</dfn> is an atomic constraint that
          specifies a requirement on the formation 
          of a type <code>T</code> through the substitution of
          template arguments.

          A type constraint is satisfied if and only 
          <code>T</code> is non-dependent, meaning that the substitution 
          yielding <code>T</code> did not fail.

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          A type constraint is introduced by the 
          <cxx-grammarterm><i>typename-specifier</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>type-requirement</i></cxx-grammarterm> of a
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.type"><a title="expr.prim.req.type" href="#expr.prim.req.type">5.1.3.2</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example example="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = requires () { typename T::type; };</code></pre>
  
          The concept <code>C</code> introduces a type constraint for the 
          type name <code>T::type</code>.

          The type <code>int</code> does not satisfy this constraint
          because substitution of that type into the constraint results in a
          substitution failure; <code>typename int::type</code> is ill-formed.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <p para_num="2" id="temp.constr.atom.type.2"> A type constraint that names a class template specialization 
          does not require that type to be complete 
          (<cxx-ref in="cxx" to="basic.types"><span title="basic.types">§3.9</span></cxx-ref>). </p>

          <p para_num="3" id="temp.constr.atom.type.3"> A type constraint <code>P</code> subsumes another type
          constraint <code>Q</code> if and only if the types in <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref in="cxx" to="temp.type"><span title="temp.type">§14.4</span></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.type -->


        <!-- ===============================
             Implicit conversion constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.conv">
    

    <section>
      <header><span class="section-number">14.9.2.4</span> <h1 data-bookmark-label="14.9.2.4 Implicit conversion constraints">Implicit conversion constraints</h1> <span style="float:right"><a href="#temp.constr.atom.conv">[temp.constr.atom.conv]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.conv.1"> An <dfn>implicit conversion constraint</dfn> is an atomic
          constraint that specifies a requirement 
          on the implicit conversion of an 
          <cxx-grammarterm><i>expression</i></cxx-grammarterm>
          <code>E</code> to a type <code>T</code>. 

          The constraint is satisfied if and
          only if <code>E</code> is implicitly convertible to <code>T</code>
          (Clause <cxx-ref in="cxx" to="conv"><span title="conv">§4</span></cxx-ref>).
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          A conversion constraint is introduced by a
          <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> when
          the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> contains 
          no placeholders (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C = 
requires (T a, T b) {
  { a == b } -&gt; bool;
};</code></pre>
  
          The <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in the
          <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> of <code>C</code>
          introduces two atomic constraints: an expression constraint
          for <code>a == b</code>, and the implicit conversion constraint that 
          the expression <code>a == b</code> is implicitly convertible to
          <code>bool</code>.
          
    <span class="nowrap">— <em>end example</em> ]</span>
  
          <p></p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          T1 is convertible to T2. -->

          <p para_num="2" id="temp.constr.atom.conv.2"> An implicit conversion constraint <code>P</code> subsumes 
          another implicit conversion constraint <code>Q</code> if and only if
          the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of 
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>) and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"><span title="temp.type">§14.4</span></cxx-ref>).</p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.conv -->


        <!-- ==============================
             Argument deduction constraints
             ============================== -->

        <cxx-section id="temp.constr.atom.deduct">
    

    <section>
      <header><span class="section-number">14.9.2.5</span> <h1 data-bookmark-label="14.9.2.5 Argument deduction constraints">Argument deduction constraints</h1> <span style="float:right"><a href="#temp.constr.atom.deduct">[temp.constr.atom.deduct]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.deduct.1"> An <dfn>argument deduction constraint</dfn> is an atomic
          constraint that specifies a requirement on 
          the usability of an <cxx-grammarterm><i>expression</i></cxx-grammarterm> 
          <code>E</code> as an argument to an invented abbreviated
          function template <code>F</code> (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>),
          where <code>F</code> has a single parameter formed from a type that 
          includes placeholders 
          (<cxx-ref to="dcl.spec.auto"><a title="dcl.spec.auto" href="#dcl.spec.auto">7.1.6.4</a></cxx-ref>, <cxx-ref to="dcl.spec.constr"><a title="dcl.spec.constr" href="#dcl.spec.constr">7.1.6.5</a></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          An argument deduction constraint is introduced by a
          <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> in a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> when the
          <cxx-grammarterm><i>trailing-type-specifier-seq</i></cxx-grammarterm>
          contains at least one placeholder
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
          <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt;
  concept bool C1() { return true; }

template&lt;typename T&gt;
  concept bool C2() { return requires(T t) { {*t} -&gt; const C1&amp; x; }; }</code></pre>
  
          The invented function template for the
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> in
          <code>C2</code> is:
          <cxx-codeblock>
    
    <pre><code>void F(const C1&amp; x);</code></pre>
  </cxx-codeblock>
          
    <span class="nowrap">— <em>end example</em> ]</span>
  

          The constraint is satisfied if and only if <code>F</code>
          is selected by overload resolution for the call <code>F(E)</code>
          (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>).

          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Overload resolution selects <code>F</code> only when template 
          argument deduction succeeds and <code>F</code>'s associated 
          constraints are satisfied.
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

          <!--
          <cxx-example>
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };
template&lt;typename T&gt; concept bool D = requires (T t) { *t -> const C&amp;; };
          </cxx-codeblock>
          The concept <code>D</code> introduces an argument deduction 
          constraint for the expression <code>*t</code>.

          When determining if <code>D</code> is satisfied, overload resolution
          is performed for the call <code>g(*t)</code> against the following 
          invented abbreviated function template:
          <cxx-codeblock>
void g(const C&);
          </cxx-codeblock>
          </cxx-example>
          -->
          <p></p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          f(T1) is more specialized than f(T2) where f is the corresponding
          invented function template. -->

          <p para_num="2" id="temp.constr.atom.deduct.2"> An argument deduction constraint <code>P</code> subsumes
          another argument deduction constraint <code>Q</code> if and only
          if the <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>), and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"><span title="temp.type">§14.4</span></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.deduct -->


        <!-- ===============================
             Exception constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.noexcept">
    

    <section>
      <header><span class="section-number">14.9.2.6</span> <h1 data-bookmark-label="14.9.2.6 Exception constraints">Exception constraints</h1> <span style="float:right"><a href="#temp.constr.atom.noexcept">[temp.constr.atom.noexcept]</a></span></header>
      
          

          <p para_num="1" id="temp.constr.atom.noexcept.1"> An <dfn>exception constraint</dfn> is an atomic constraint
          for an expression <code>E</code> that is satisfied if and only
          if the expression <code>noexcept(E)</code> is <code>true</code>
          (<cxx-ref in="cxx" to="expr.unary.noexcept"><span title="expr.unary.noexcept">§5.3.7</span></cxx-ref>).
          
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
          Constant expression constraints are introduced by a
          <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm> that
          includes the <code>noexcept</code> specifier
          (<cxx-ref to="expr.prim.req.compound"><a title="expr.prim.req.compound" href="#expr.prim.req.compound">5.1.3.3</a></cxx-ref>).
          
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
          </p>

          <p para_num="2" id="temp.constr.atom.noexcept.2"> An exception constraint <code>P</code> subsumes another
          exception constraint <code>Q</code> if and only if the
          <cxx-grammarterm><i>expression</i></cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"><a title="temp.over.link" href="#temp.over.link">14.5.6.1</a></cxx-ref>). </p>

        
    </section>
  </cxx-section> <!-- temp.constr.atom.noexcept -->

    
    </section>
  </cxx-section> <!-- temp.constr.atom -->


    <!-- ===============================
         Partial ordering of constraints
         =============================== -->

    <cxx-section id="temp.constr.order">
    

    <section>
      <header><span class="section-number">14.9.3</span> <h1 data-bookmark-label="14.9.3 Partial ordering by constraints">Partial ordering by constraints</h1> <span style="float:right"><a href="#temp.constr.order">[temp.constr.order]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.order.1">
      In order to determine if a constraint <code>P</code> subsumes a constraint
      <code>Q</code>, transform <code>P</code> into disjunctive normal
      form (a disjunction of clauses, each of which is a conjunction
      of atomic propositions), and transform <code>Q</code> into conjunctive
      normal form (a conjunction of clauses, each of which is a disjunction
      of atomic propositions).
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      Let <code>A</code>, <code>B</code>, and <code>C</code> be atomic
      constraints. 

      The constraint 
      <code>A</code> ∧ (<code>B</code> ∨ <code>C</code>) 
      is in conjunctive normal form.

      Its conjunctive clauses are <code>A</code> and
      (<code>B</code> ∨ <code>C</code>).
      
      The disjunctive normal form of the constraint
      <code>A</code> ∧ (<code>B</code> ∨ <code>C</code>) 
      is
      (<code>A</code> ∧ <code>B</code>) ∨ (<code>A</code> ∧ <code>C</code>).
      
      Its disjunctive clauses are 
      (<code>A</code> ∧ <code>B</code>) and
      (<code>A</code> ∧ <code>C</code>).
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      
      The disjunctive normal form of <code>P</code> subsumes the 
      conjunctive normal form of <code>Q</code>
      if and only if every disjunctive clause in 
      <code>P<sub><i>i</i></sub></code> subsumes each 
      conjunctive clause in <code>Q<sub><i>j</i></sub></code>. 

      A disjunctive clause
      <code>P<sub><i>i</i></sub></code> subsumes a conjunctive clause 
      <code>Q<sub><i>j</i></sub></code> when each atomic constraint in 
      <code>P<sub><i>i</i></sub></code> subsumes any atomic constraint in
      <code>Q<sub><i>j</i></sub></code>.

      The rules for determining whether one atomic constraint subsumes
      another are defined for each kind of atomic constraint
      (<cxx-ref to="temp.constr.atom"><a title="temp.constr.atom" href="#temp.constr.atom">14.9.2</a></cxx-ref>).

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      Let <code>A</code> and <code>B</code> be
      predicate constraints (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>).

      The constraint <code>A ∧ B</code> subsumes <code>A</code>, 
      but <code>A</code> does not subsume <code>A ∧ B</code>. 

      The constraint <code>A</code> subsumes <code>A ∨ B</code>, but
      <code>A ∨ B</code> does not subsume code <code>A</code>. 

      Also, any constraint <code>P</code> subsumes itself.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      </p>


      <p para_num="2" id="temp.constr.order.2">The subsumption relation defines a partial ordering on constraints. 
      This partial ordering is used to determine </p>

      <ul>
      <li> the best viable candidate of non-template functions
           (<cxx-ref to="over.match.best"><a title="over.match.best" href="#over.match.best">13.3.3</a></cxx-ref>), </li>
      <li> the address of a non-template function
           (<cxx-ref to="over.over"><a title="over.over" href="#over.over">13.4</a></cxx-ref>), </li>
      <li> the matching of template template arguments
           (<cxx-ref to="temp.arg.template"><a title="temp.arg.template" href="#temp.arg.template">14.4.3</a></cxx-ref>), </li>
      <li> the partial ordering of class template specializations
           (<cxx-ref to="temp.class.order"><a title="temp.class.order" href="#temp.class.order">14.5.5.2</a></cxx-ref>), and</li>
      <li> the partial ordering of function templates
           (<cxx-ref to="temp.func.order"><a title="temp.func.order" href="#temp.func.order">14.5.6.2</a></cxx-ref>).</li>
      </ul>

      <p para_num="3" id="temp.constr.order.3"> When two declarations <code>D1</code> and <code>D2</code> are
      partially ordered by their normalized constraints, <code>D1</code> is 
      <dfn>more constrained</dfn> than <code>D2</code> if

      </p><ul>
      <li> <code>D1</code> and <code>D2</code> are both constrained
      declarations and <code>D1</code>'s associated constraints subsume but 
      are not subsumed by those of <code>D2</code>; or</li>

      <li> <code>D1</code> is constrained and <code>D2</code> is
      unconstrained. </li>
      </ul>

      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1 = requires(T t) { --t; };
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt; &amp;&amp; requires(T t) { *t; };

template&lt;C1 T&gt; void f(T);       // <i>#1</i>
template&lt;C2 T&gt; void f(T);       // <i>#2</i>
template&lt;typename T&gt; void g(T); // <i>#3</i>
template&lt;C1 T&gt; void g(T);       // <i>#4</i>

f(0);       // <i>selects #1</i>
f((int*)0); // <i>selects #2</i>
g(true);    // <i>selects #3 because</i> C1&lt;bool&gt; <i>is not satisfied</i>
g(0);       // <i>selects #4</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

      <p para_num="4" id="temp.constr.order.4"> A declaration <code>D1</code> is <dfn>at least as constrained</dfn>
      as another declaration <code>D2</code> when <code>D1</code> is more
      constrained than <code>D2</code> and <code>D2</code> is not more
      constrained than <code>D1</code>. </p>

    
    </section>
  </cxx-section> <!-- temp.constr.order -->



    <!-- ======================
         Constraint expressions
         ====================== -->

    <cxx-section id="temp.constr.expr">
    

    <section>
      <header><span class="section-number">14.9.4</span> <h1 data-bookmark-label="14.9.4 Constraint expressions">Constraint expressions</h1> <span style="float:right"><a href="#temp.constr.expr">[temp.constr.expr]</a></span></header>
      
      

      <p para_num="1" id="temp.constr.expr.1">Certain contexts require expressions that can be transformed
      into constraints through the process of <dfn>normalization</dfn>.
      <bnf-grammar>
    
    
        <bnf-rule>
    
    constraint-expression:
  </bnf-rule>
          <bnf-alt>
    
    logical-or-expression
  </bnf-alt>
      
  </bnf-grammar>
      </p>

      <p para_num="2" id="temp.constr.expr.2"> A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm>
      is <dfn>normalized</dfn> by forming a constraint
      as follows.

      </p><ul>
      <li> The normalized form of <code>(P)</code> is the normalized form of 
      <code>P</code>.</li>

      <li> The normalized form of <code>P || Q</code> is
      the disjunction (<cxx-ref to="temp.constr.op.disj"><a title="temp.constr.op.disj" href="#temp.constr.op.disj"></a></cxx-ref>) of the 
      normalized form of <code>P</code> and the normalized form of 
      <code>Q</code>.</li>

      If, after substitution, overload resolution 
      (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>) selects a user-declared 
      <code>operator||</code>, the program is ill-formed.

      <li> The normalized form of <code>P &amp;&amp; Q</code> is
      the conjunction (<cxx-ref to="temp.constr.op.conj"><a title="temp.constr.op.conj" href="#temp.constr.op.conj"></a></cxx-ref>) of the 
      normalized form of <code>P</code> and the normalized form of
      <code>Q</code>.

      If, after substitution, overload resolution 
      (<cxx-ref to="over.match"><a title="over.match" href="#over.match">13.3</a></cxx-ref>) selects a user-declared 
      <code>operator&amp;&amp;</code>, the program is ill-formed.</li>

      <li> The normalized form of a function call of the form
      <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;()</code>,
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a function
      concept (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>), is the result of 
      substituting the template arguments into the expression
      returned by <code>C</code>.</li>

      <li> The normalized form of an <cxx-grammarterm><i>id-expression</i></cxx-grammarterm>
      of the form <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a variable
      concept (<cxx-ref to="dcl.spec.concept"><a title="dcl.spec.concept" href="#dcl.spec.concept">7.1.7</a></cxx-ref>) is the result of 
      substituting the template arguments into the initializer
      of <code>C</code>.</li>

      <li> The normalized form of a 
      <cxx-grammarterm><i>requires-expression</i></cxx-grammarterm> 
      (<cxx-ref to="expr.prim.req"><a title="expr.prim.req" href="#expr.prim.req">5.1.3</a></cxx-ref>) is
      the conjunction of constraints (<cxx-ref to="temp.constr.op.conj"><a title="temp.constr.op.conj" href="#temp.constr.op.conj"></a></cxx-ref>) 
      introduced by the body of that expression.
      </li>

      <li> Otherwise, <code>E</code> is a predicate constraint 
      (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>). 

      After substitution, <code>E</code> shall be a converted constant 
      expression of type <code>bool</code>.
      </li>
      </ul>

      <!-- TODO: Do we need a top-level conversion requirement for
           constraint expressions? -->

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
      A <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> 
      defines a subset of constant expressions over which certain 
      logical implications can be deduced during translation.

      The prohibition against user-defined logical operators is intended to
      prevent the subversion of the logic used to partially
      order constraints (<cxx-ref to="temp.constr.order"><a title="temp.constr.order" href="#temp.constr.order">14.9.3</a></cxx-ref>).
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>

      <!-- TODO: Make this a table -->
      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C1() { return sizeof(T) == 1; }
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt;() &amp;&amp; 1 == 2;
template&lt;typename T&gt; concept bool C3 = requires () { typename T::type; };

// <i>Expression</i>      // <i>Constraints</i>
C2&lt;char&gt;           sizeof(char) == 1 /* <i>and</i> */ 1 == 2
C3&lt;int&gt;            /* <i>type constraint for</i> int::type */
3 + 4              // <i>error: not a constraint</i>
(bool)(3 + 4)      (bool)(3 + 4)</code></pre>
  </cxx-codeblock>
      In the normalized constraints, the expressions <code>sizeof(char) == 1</code>, 
      <code>1 == 2</code>, and <code>(bool)(3 + 4)</code> are predicate 
      constraints (<cxx-ref to="temp.constr.atom.pred"><a title="temp.constr.atom.pred" href="#temp.constr.atom.pred">14.9.2.1</a></cxx-ref>). 

      The concept <code>C3</code> is normalized to a single type constraint
      (<cxx-ref to="temp.constr.atom.type"><a title="temp.constr.atom.type" href="#temp.constr.atom.type">14.9.2.3</a></cxx-ref>) for the (ill-formed) 
      type <code>int::type</code>.

      The expression <code>3 + 4</code> is not a 
      <cxx-grammarterm><i>constraint-expression</i></cxx-grammarterm> because it does
      not satisfy the requirements for being normalized into a predicate 
      constraint.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

    
    </section>
  </cxx-section> <!-- temp.constr.expr -->


    <!-- ==================
         Concept resolution
         ================== -->

    <cxx-section id="temp.concept.resolve">
    

    <section>
      <header><span class="section-number">14.9.5</span> <h1 data-bookmark-label="14.9.5 Concept resolution">Concept resolution</h1> <span style="float:right"><a href="#temp.concept.resolve">[temp.concept.resolve]</a></span></header>
      
      

      <p para_num="1" id="temp.concept.resolve.1"> Whenever a <cxx-grammarterm><i>identifier</i></cxx-grammarterm> is a
      <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>, it is necessary to
      determine a single concept referred to by the use of that name.

      </p><p para_num="2" id="temp.concept.resolve.2"> <dfn>Concept resolution</dfn> is the process of selecting a concept 
      from a set of concept definitions referred to by a concept name.
      
      Concept resolution is performed when a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> appears in
      the declaration of an abbreviated function (<cxx-ref to="dcl.fct"><a title="dcl.fct" href="#dcl.fct">8.3.5</a></cxx-ref>)
      or generic lambda (<cxx-ref to="expr.prim.lambda"><a title="expr.prim.lambda" href="#expr.prim.lambda">5.1.2</a></cxx-ref>),
      in the <cxx-grammarterm><i>trailing-return-type</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>compound-requirement</i></cxx-grammarterm>, the
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> of a
      <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm>, or
      in a <cxx-grammarterm><i>template-introduction</i></cxx-grammarterm>.
      </p>

      <p para_num="3" id="temp.concept.resolve.3"> A concept is selected from a set of concepts based on a sequence
      of <dfn>pending template arguments</dfn> and a sequence of explicit
      template arguments. 

      A pending template argument is a placeholder used to deduce the type 
      and form of a template parameter from a concept definition. A pending 
      template argument can be a pack expansion.

      A concept is selected from the set by matching the designated and
      explicit template arguments against the template parameters of that
      concept. 
      </p>

      <p para_num="4" id="temp.concept.resolve.4">
      When selecting a concept for a 
      <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      there is a single pending template argument. 
      
      If, the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm> 
      appears in the declaration of a
      <cxx-grammarterm><i>constrained-parameter</i></cxx-grammarterm> 
      (<cxx-ref to="temp.param"><a title="temp.param" href="#temp.param">14.1</a></cxx-ref>) and is
      followed by an ellipsis, the pending template argument is a pack
      expansion.

      If the <cxx-grammarterm><i>constrained-type-specifier</i></cxx-grammarterm>
      is a <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm> the
      <cxx-grammarterm><i>template-arguments</i></cxx-grammarterm> are those in
      the <cxx-grammarterm><i>partial-concept-id</i></cxx-grammarterm>.

      When selecting a concept for a 
      <cxx-grammarterm><i>concept-name</i></cxx-grammarterm>
      in a <cxx-grammarterm><i>template-introduction</i></cxx-grammarterm>, there
      is one pending template argument for each 
      <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm>.

      If an <cxx-grammarterm><i>introduced-parameter</i></cxx-grammarterm> is
      preceded by an ellipsis, its corresponding pending template argument
      is a pack expansion.

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    </cxx-codeblock></cxx-example></p><pre><code>template&lt;typename T&gt; concept bool C1() { return true; }
template&lt;typename T, typename U&gt; concept bool C1() { return true; }
template&lt;typename... T&gt; concept bool C2() { return true; }

void f(1C1); 
void f2(C1&lt;int&gt;);</code></pre>
  
      In the resolution of required by the declaration of <code>f1</code>, 
      there is a single pending template argument and no explicit template 
      arguments.

      For <code>f2</code> there is a single pending template argument and the 
      single explicit template argument, <code>int</code>.
      <cxx-codeblock>
    
    <pre><code>C1{T} void f3(T);
C1{T, U} void f4(T);</code></pre>
  </cxx-codeblock>
      In the resolution required by the declaration of <code>f3</code>, there
      is a single pending template argument. There are two in the resolution
      required by <code>f2</code>.
      <cxx-codeblock>
    
    <pre><code>C2{...T} void f5();</code></pre>
  </cxx-codeblock>
      There is a single pending template argument in the resolution of
      <code>f2</code> and it is a pack expansion.
      
    <span class="nowrap">— <em>end example</em> ]</span>
  
      <p></p>

      <p para_num="5" id="temp.concept.resolve.5">
      For each concept <code>C</code> in the concept set, each template 
      argument in the combined sequence of pending and explicit template 
      arguments is matched against the corresponding template parameter
      in the <cxx-grammarterm><i>template-parameter-list</i></cxx-grammarterm> of 
      <code>C</code> as follows.

      A pending template argument that is not a parameter pack matches a 
      non-pack template parameter of any type and form. A pending template
      argument that is a parameter pack matches a template parameter pack
      whose pattern is any form.

      The remaining explicit arguments are matched against parameters
      according in the usual way (<cxx-ref to="temp.arg"><a title="temp.arg" href="#temp.arg">14.4</a></cxx-ref>).

      If any pending or template arguments do not match the corresponding
      parameter, <code>C</code> is removed from the set.
      </p>

      <p para_num="6" id="temp.concept.resolve.6">If a single concept remains, that concept is the one selected
      by concept resolution. Otherwise, the program is ill-formed. </p>

      <cxx-example class="inline">
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      <cxx-codeblock>
    
    <pre><code>template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }
template&lt;&lt;typename... Ts&gt; concept bool Q = true;

void f1(const C*);  // <i>OK:</i> C <i>selects #1</i>
void f2(C&lt;char&gt;);   // <i>OK:</i> C&lt;char&gt; <i>selects #2</i>
void f3(C&lt;3&gt;);      // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);         // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i>
Q{...Ts} void q1(); // <i>OK: selects</i> Q
Q{T} void q2();     // <i>error: no matching concept (mismatched template arguments)</i></code></pre>
  </cxx-codeblock>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      <p para_num="7" id="temp.concept.resolve.7"></p>

      <p para_num="8" id="temp.concept.resolve.8">
      For the selected template, the set of template parameters corresponding
      to the matched pending template arguments are called the
      <dfn>selected template parameters</dfn>. In 
      <cxx-grammarterm><i>template-introductions</i></cxx-grammarterm>, these
      are used to derive the declarations of introduced parameters.
      </p>
    
    </section>
  </cxx-section> <!-- temp.concept.resolve -->

  
    </section>
  </cxx-section> <!-- temp.constr -->


    </section>
  </cxx-clause> <!-- temp -->








</body></html>