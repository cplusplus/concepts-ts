{"version":3,"file":"build/polymer.js","sources":["src/polymer.js","src/boot.js","src/lib/lang.js","src/lib/job.js","src/lib/dom.js","src/lib/super.js","src/lib/deserialize.js","src/api.js","src/instance/utils.js","src/instance/events.js","src/instance/attributes.js","src/instance/properties.js","src/instance/mdv.js","src/instance/base.js","src/instance/styles.js","src/declaration/path.js","src/declaration/styles.js","src/declaration/events.js","src/declaration/properties.js","src/declaration/attributes.js","src/declaration/prototype.js","src/declaration/polymer-element.js"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\nPolymer = {};\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n\n// TODO(sorvell): this ensures Polymer is an object and not a function\n// Platform is currently defining it as a function to allow for async loading\n// of polymer; once we refine the loading process this likely goes away.\nif (typeof window.Polymer === 'function') {\n  Polymer = {};\n}","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // copy own properties from 'api' to 'prototype, with name hinting for 'super'\n  function extend(prototype, api) {\n    if (prototype && api) {\n      // use only own properties of 'api'\n      Object.getOwnPropertyNames(api).forEach(function(n) {\n        // acquire property descriptor\n        var pd = Object.getOwnPropertyDescriptor(api, n);\n        if (pd) {\n          // clone property via descriptor\n          Object.defineProperty(prototype, n, pd);\n          // cache name-of-method for 'super' engine\n          if (typeof pd.value == 'function') {\n            // hint the 'super' engine\n            pd.value.nom = n;\n          }\n        }\n      });\n    }\n    return prototype;\n  }\n  \n  // exports\n\n  scope.extend = extend;\n\n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n  \n  // usage\n  \n  // invoke cb.call(this) in 100ms, unless the job is re-registered,\n  // which resets the timer\n  // \n  // this.myJob = this.job(this.myJob, cb, 100)\n  //\n  // returns a job handle which can be used to re-register a job\n\n  var Job = function(inContext) {\n    this.context = inContext;\n  };\n  Job.prototype = {\n    go: function(callback, wait) {\n      this.callback = callback;\n      this.handle = setTimeout(this.complete.bind(this), wait);\n    },\n    stop: function() {\n      if (this.handle) {\n        clearTimeout(this.handle);\n        this.handle = null;\n      }\n    },\n    complete: function() {\n      if (this.handle) {\n        this.stop();\n        this.callback.call(this.context);\n      }\n    }\n  };\n  \n  function job(job, callback, wait) {\n    if (job) {\n      job.stop();\n    } else {\n      job = new Job(this);\n    }\n    job.go(callback, wait);\n    return job;\n  }\n  \n  // exports \n\n  scope.job = job;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var registry = {};\n\n  HTMLElement.register = function(tag, prototype) {\n    registry[tag] = prototype;\n  }\n\n  // get prototype mapped to node <tag>\n  HTMLElement.getPrototypeForTag = function(tag) {\n    var prototype = !tag ? HTMLElement.prototype : registry[tag];\n    // TODO(sjmiles): creating <tag> is likely to have wasteful side-effects\n    return prototype || Object.getPrototypeOf(document.createElement(tag));\n  };\n\n  // we have to flag propagation stoppage for the event dispatcher\n  var originalStopPropagation = Event.prototype.stopPropagation;\n  Event.prototype.stopPropagation = function() {\n    this.cancelBubble = true;\n    originalStopPropagation.apply(this, arguments);\n  };\n  \n  HTMLImports.importer.preloadSelectors += \n      ', polymer-element link[rel=stylesheet]';\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n (function(scope) {\n    // super\n\n    // `arrayOfArgs` is an optional array of args like one might pass\n    // to `Function.apply`\n\n    // TODO(sjmiles):\n    //    $super must be installed on an instance or prototype chain\n    //    as `super`, and invoked via `this`, e.g.\n    //      `this.super();`\n     \n    //    will not work if function objects are not unique, for example,\n    //    when using mixins.\n    //    The memoization strategy assumes each function exists on only one \n    //    prototype chain i.e. we use the function object for memoizing)\n    //    perhaps we can bookkeep on the prototype itself instead\n    function $super(arrayOfArgs) {\n      // since we are thunking a method call, performance is important here: \n      // memoize all lookups, once memoized the fast path calls no other \n      // functions\n      //\n      // find the caller (cannot be `strict` because of 'caller')\n      var caller = $super.caller;\n      // memoized 'name of method' \n      var nom = caller.nom;\n      // memoized next implementation prototype\n      var _super = caller._super;\n      if (!_super) {\n        if (!nom) {\n          nom = caller.nom = nameInThis.call(this, caller);\n        }\n        if (!nom) {\n          console.warn('called super() on a method not installed declaratively (has no .nom property)');\n        }\n        // super prototype is either cached or we have to find it\n        // by searching __proto__ (at the 'top')\n        _super = memoizeSuper(caller, nom, getPrototypeOf(this));\n      }\n      if (!_super) {\n        // if _super is falsey, there is no super implementation\n        //console.warn('called $super(' + nom + ') where there is no super implementation');\n      } else {\n        // our super function\n        var fn = _super[nom];\n        // memoize information so 'fn' can call 'super'\n        if (!fn._super) {\n          memoizeSuper(fn, nom, _super);\n        }\n        // invoke the inherited method\n        // if 'fn' is not function valued, this will throw\n        return fn.apply(this, arrayOfArgs || []);\n      }\n    }\n\n    function nextSuper(proto, name, caller) {\n      // look for an inherited prototype that implements name\n      while (proto) {\n        if ((proto[name] !== caller) && proto[name]) {\n          return proto;\n        }\n        proto = getPrototypeOf(proto);\n      }\n    }\n\n    function memoizeSuper(method, name, proto) {\n      // find and cache next prototype containing `name`\n      // we need the prototype so we can do another lookup\n      // from here\n      method._super = nextSuper(proto, name, method);\n      if (method._super) {\n        // _super is a prototype, the actual method is _super[name]\n        // tag super method with it's name for further lookups\n        method._super[name].nom = name;\n      }\n      return method._super;\n    }\n\n    function nameInThis(value) {\n      var p = this.__proto__;\n      while (p && p !== HTMLElement.prototype) {\n        // TODO(sjmiles): getOwnPropertyNames is absurdly expensive\n        var n$ = Object.getOwnPropertyNames(p);\n        for (var i=0, l=n$.length, n; i<l && (n=n$[i]); i++) {\n          var d = Object.getOwnPropertyDescriptor(p, n);\n          if (typeof d.value === 'function' && d.value === value) {\n            return n;\n          }\n        }\n        p = p.__proto__;\n      }\n    }\n\n    // NOTE: In some platforms (IE10) the prototype chain is faked via \n    // __proto__. Therefore, always get prototype via __proto__ instead of\n    // the more standard Object.getPrototypeOf.\n    function getPrototypeOf(prototype) {\n      return prototype.__proto__;\n    }\n\n    // utility function to precompute name tags for functions\n    // in a (unchained) prototype\n    function hintSuper(prototype) {\n      // tag functions with their prototype name to optimize\n      // super call invocations\n      for (var n in prototype) {\n        var pd = Object.getOwnPropertyDescriptor(prototype, n);\n        if (pd && typeof pd.value === 'function') {\n          pd.value.nom = n;\n        }\n      }\n    }\n\n    // exports\n\n    scope.super = $super;\n\n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  var typeHandlers = {\n    string: function(value) {\n      return value;\n    },\n    date: function(value) {\n      return new Date(Date.parse(value) || Date.now());\n    },\n    boolean: function(value) {\n      if (value === '') {\n        return true;\n      }\n      return value === 'false' ? false : !!value;\n    },\n    number: function(value) {\n      var floatVal = parseFloat(value);\n      return (String(floatVal) === value) ? floatVal : value;\n    },\n    object: function(value, currentValue) {\n      if (currentValue === null) {\n        return value;\n      }\n      try {\n        // If the string is an object, we can parse is with the JSON library.\n        // include convenience replace for single-quotes. If the author omits\n        // quotes altogether, parse will fail.\n        return JSON.parse(value.replace(/'/g, '\"'));\n      } catch(e) {\n        // The object isn't valid JSON, return the raw value\n        return value;\n      }\n    },\n    // avoid deserialization of functions\n    'function': function(value, currentValue) {\n      return currentValue;\n    }\n  };\n\n  function deserializeValue(value, currentValue) {\n    // attempt to infer type from default value\n    var inferredType = typeof currentValue;\n    // invent 'date' type value for Date\n    if (currentValue instanceof Date) {\n      inferredType = 'date';\n    }\n    // delegate deserialization via type string\n    return typeHandlers[inferredType](value, currentValue);\n  }\n\n  // exports\n\n  scope.deserializeValue = deserializeValue;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var api = {};\n\n  api.declaration = {};\n  api.instance = {};\n\n  // exports\n\n  scope.api = api;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  var utils = {\n    /**\n      * Invokes a function asynchronously. The context of the callback\n      * function is bound to 'this' automatically.\n      * @method async\n      * @param {Function|String} method\n      * @param {any|Array} args\n      * @param {number} timeout\n      */\n    async: function(method, args, timeout) {\n      // when polyfilling Object.observe, ensure changes \n      // propagate before executing the async method\n      Platform.flush();\n      // second argument to `apply` must be an array\n      args = (args && args.length) ? args : [args];\n      // function to invoke\n      var fn = function() {\n        (this[method] || method).apply(this, args);\n      }.bind(this);\n      // execute `fn` sooner or later\n      return timeout ? setTimeout(fn, timeout) : requestAnimationFrame(fn);\n    },    \n    /**\n      * Fire an event.\n      * @method fire\n      * @param {string} type An event name.\n      * @param detail\n      * @param {Node} toNode Target node.\n      */\n    fire: function(type, detail, toNode, bubbles) {\n      var node = toNode || this;\n      //log.events && console.log('[%s]: sending [%s]', node.localName, inType);\n      node.dispatchEvent(\n        new CustomEvent(type, {\n          bubbles: (bubbles !== undefined ? bubbles : true), \n          detail: detail\n        }));\n      return detail;\n    },\n    /**\n      * Fire an event asynchronously.\n      * @method asyncFire\n      * @param {string} type An event name.\n      * @param detail\n      * @param {Node} toNode Target node.\n      */\n    asyncFire: function(/*inType, inDetail*/) {\n      this.async(\"fire\", arguments);\n    },\n    /**\n      * Remove class from old, add class to anew, if they exist\n      * @param classFollows\n      * @param anew A node.\n      * @param old A node\n      * @param className\n      */\n    classFollows: function(anew, old, className) {\n      if (old) {\n        old.classList.remove(className);\n      }\n      if (anew) {\n        anew.classList.add(className);\n      }\n    }\n  };\n\n  // deprecated\n\n  utils.asyncMethod = utils.async;\n\n  // exports\n\n  scope.api.instance.utils = utils;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n\n  // magic words\n\n  var EVENT_PREFIX = 'on-';\n  var HANDLED_LIST = '__eventHandledList__';\n\n  // instance events api\n\n  var events = {\n    // read-only\n    EVENT_PREFIX: EVENT_PREFIX,\n    // event name utilities\n    hasEventPrefix: function (n) {\n      return n && (n[0] === 'o') && (n[1] === 'n') && (n[2] === '-');\n    },\n    removeEventPrefix: function(n) {\n      return n.slice(prefixLength);\n    },\n    // event listeners on host\n    addHostListeners: function() {\n      var events = this.eventDelegates;\n      log.events && (Object.keys(events).length > 0) && console.log('[%s] addHostListeners:', this.localName, events);\n      this.addNodeListeners(this, events, this.hostEventListener);\n    },\n    addNodeListeners: function(node, events, listener) {\n      // note: conditional inside loop as optimization\n      // for empty 'events' object\n      var fn;\n      for (var n in events) {\n        if (!fn) {\n          fn = listener.bind(this);\n        }\n        this.addNodeListener(node, n, fn);\n      }\n    },\n    addNodeListener: function(node, event, listener) {\n      node.addEventListener(event, listener);\n    },\n    hostEventListener: function(event) {\n      if (!event.cancelBubble) {\n        log.events && console.group(\"[%s]: hostEventListener(%s)\", this.localName, event.type);\n        var h = this.findEventDelegate(event);\n        if (h) {\n          log.events && console.log('[%s] found host handler name [%s]', this.localName, h);\n          this.dispatchMethod(this, h, [event, event.detail, this]);\n        }\n        log.events && console.groupEnd();\n      }\n    },  \n    // find the method name in delegates mapped to event.type\n    findEventDelegate: function(event) {\n      return this.eventDelegates[event.type];\n    },\n    // call 'method' or function method on 'obj' with 'args', if the method exists\n    dispatchMethod: function(obj, method, args) {\n      if (obj) {\n        log.events && console.group('[%s] dispatch [%s]', obj.localName, method);\n        var fn = typeof method === 'function' ? method : obj[method];\n        if (fn) {\n          fn[args ? 'apply' : 'call'](obj, args);\n        }\n        log.events && console.groupEnd();\n        Platform.flush();\n      }\n    },\n    /*\n      Bind events via attributes of the form on-eventName.\n      This method hooks into the model syntax and does adds event listeners as\n      needed. By default, binding paths are always method names on the root\n      model, the custom element in which the node exists. Adding a '@' in the\n      path directs the event binding to use the model path as the event listener.\n      In both cases, the actual listener is attached to a generic method which\n      evaluates the bound path at event execution time. \n    */\n    prepareBinding: function(path, name, node) {\n      // if lhs an event prefix,\n      if (events.hasEventPrefix(name)) {\n        // provide an event-binding callback\n        return function(model, node) {\n          log.events && console.log('event: [%s].%s => [%s].%s()\"', node.localName, model.localName, path);\n          var listener = function(event) {\n            var ctrlr = findController(node);\n            if (ctrlr && ctrlr.dispatchMethod) {\n              var obj = ctrlr, method = path;\n              if (path[0] == '@') {\n                obj = model;\n                method = Path.get(path.slice(1)).getValueFrom(model);\n              }\n              ctrlr.dispatchMethod(obj, method, [event, event.detail, node]);\n            }\n          };\n          var eventName = events.removeEventPrefix(name);\n          node.addEventListener(eventName, listener, false);\n          return {\n            close: function() {\n              log.events && console.log('event.remove: [%s].%s => [%s].%s()\"', node.localName, name, model.localName, path);\n              node.removeEventListener(eventName, listener, false);\n            }\n          }\n        };\n      }\n    }\n  };\n\n  var prefixLength = EVENT_PREFIX.length;\n\n  function findController(node) {\n    while (node.parentNode) {\n      node = node.parentNode;\n    }\n    return node.host;\n  };\n\n  // exports\n\n  scope.api.instance.events = events;\n\n})(Polymer);\n","/*\r\n * Copyright 2013 The Polymer Authors. All rights reserved.\r\n * Use of this source code is governed by a BSD-style\r\n * license that can be found in the LICENSE file.\r\n */\r\n(function(scope) {\r\n\r\n  // instance api for attributes\r\n\r\n  var attributes = {\r\n    copyInstanceAttributes: function () {\r\n      var a$ = this._instanceAttributes;\r\n      for (var k in a$) {\r\n        if (!this.hasAttribute(k)) {\r\n          this.setAttribute(k, a$[k]);\r\n        }\r\n      }\r\n    },\r\n    // for each attribute on this, deserialize value to property as needed\r\n    takeAttributes: function() {\r\n      // if we have no publish lookup table, we have no attributes to take\r\n      // TODO(sjmiles): ad hoc\r\n      if (this._publishLC) {\r\n        for (var i=0, a$=this.attributes, l=a$.length, a; (a=a$[i]) && i<l; i++) {\r\n          this.attributeToProperty(a.name, a.value);\r\n        }\r\n      }\r\n    },\r\n    // if attribute 'name' is mapped to a property, deserialize\r\n    // 'value' into that property\r\n    attributeToProperty: function(name, value) {\r\n      // try to match this attribute to a property (attributes are\r\n      // all lower-case, so this is case-insensitive search)\r\n      var name = this.propertyForAttribute(name);\r\n      if (name) {\r\n        // filter out 'mustached' values, these are to be\r\n        // replaced with bound-data and are not yet values\r\n        // themselves\r\n        if (value && value.search(scope.bindPattern) >= 0) {\r\n          return;\r\n        }\r\n        // get original value\r\n        var currentValue = this[name];\r\n        // deserialize Boolean or Number values from attribute\r\n        var value = this.deserializeValue(value, currentValue);\r\n        // only act if the value has changed\r\n        if (value !== currentValue) {\r\n          // install new value (has side-effects)\r\n          this[name] = value;\r\n        }\r\n      }\r\n    },\r\n    // return the published property matching name, or undefined\r\n    propertyForAttribute: function(name) {\r\n      var match = this._publishLC && this._publishLC[name];\r\n      //console.log('propertyForAttribute:', name, 'matches', match);\r\n      return match;\r\n    },\r\n    // convert representation of 'stringValue' based on type of 'currentValue'\r\n    deserializeValue: function(stringValue, currentValue) {\r\n      return scope.deserializeValue(stringValue, currentValue);\r\n    },\r\n    serializeValue: function(value, inferredType) {\r\n      if (inferredType === 'boolean') {\r\n        return value ? '' : undefined;\r\n      } else if (inferredType !== 'object' && inferredType !== 'function'\r\n          && value !== undefined) {\r\n        return value;\r\n      }\r\n    },\r\n    reflectPropertyToAttribute: function(name) {\r\n      var inferredType = typeof this[name];\r\n      // try to intelligently serialize property value\r\n      var serializedValue = this.serializeValue(this[name], inferredType);\r\n      // boolean properties must reflect as boolean attributes\r\n      if (serializedValue !== undefined) {\r\n        this.setAttribute(name, serializedValue);\r\n        // TODO(sorvell): we should remove attr for all properties\r\n        // that have undefined serialization; however, we will need to\r\n        // refine the attr reflection system to achieve this; pica, for example,\r\n        // relies on having inferredType object properties not removed as\r\n        // attrs.\r\n      } else if (inferredType === 'boolean') {\r\n        this.removeAttribute(name);\r\n      }\r\n    }\r\n  };\r\n\r\n  // exports\r\n\r\n  scope.api.instance.attributes = attributes;\r\n\r\n})(Polymer);\r\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n\n  // magic words\n\n  var OBSERVE_SUFFIX = 'Changed';\n\n  // element api\n\n  var empty = [];\n\n  var properties = {\n    observeProperties: function() {\n      var n$ = this._observeNames, pn$ = this._publishNames;\n      if ((n$ && n$.length) || (pn$ && pn$.length)) {\n        var self = this;\n        var o = this._propertyObserver = generateCompoundPathObserver(this);\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          o.addPath(this, n);\n          // observer array properties\n          var pd = Object.getOwnPropertyDescriptor(this.__proto__, n);\n          if (pd && pd.value) {\n            this.observeArrayValue(n, pd.value, null);\n          }\n        }\n        for (var i=0, l=pn$.length, n; (i<l) && (n=pn$[i]); i++) {\n          if (!this.observe || (this.observe[n] === undefined)) {\n            o.addPath(this, n);\n          }\n        }\n        o.start();\n      }\n    },\n    notifyPropertyChanges: function(newValues, oldValues, changedBits, paths) {\n      var called = {};\n      for (var i=0, l=changedBits.length, name, method; i<l; i++) {\n        if (changedBits[i]) {\n          // note: paths is of form [object, path, object, path]\n          name = paths[2 * i + 1];\n          if (this.publish[name] !== undefined) {\n            this.reflectPropertyToAttribute(name);\n          }\n          method = this.observe[name];\n          if (method) {\n            this.observeArrayValue(name, newValues[i], oldValues[i]);\n            if (!called[method]) {\n              called[method] = true;\n              // observes the value if it is an array\n              this.invokeMethod(method, [oldValues[i], newValues[i], arguments]);\n            }\n          }\n        }\n      }\n    },\n    observeArrayValue: function(name, value, old) {\n      // we only care if there are registered side-effects\n      var callbackName = this.observe[name];\n      if (callbackName) {\n        // if we are observing the previous value, stop\n        if (Array.isArray(old)) {\n          log.observe && console.log('[%s] observeArrayValue: unregister observer [%s]', this.localName, name);\n          this.unregisterObserver(name + '__array');\n        }\n        // if the new value is an array, being observing it\n        if (Array.isArray(value)) {\n          log.observe && console.log('[%s] observeArrayValue: register observer [%s]', this.localName, name, value);\n          var self = this;\n          var observer = new ArrayObserver(value, function(value, old) {\n            self.invokeMethod(callbackName, [old]);\n          });\n          this.registerObserver(name + '__array', observer);\n        }\n      }\n    },\n    bindProperty: function(property, model, path) {\n      // apply Polymer two-way reference binding\n      return bindProperties(this, property, model, path);\n    },\n    unbindAllProperties: function() {\n      if (this._propertyObserver) {\n        this._propertyObserver.close();\n      }\n      this.unregisterObservers();\n    },\n    unbindProperty: function(name) {\n      return this.unregisterObserver(name);\n    },\n    invokeMethod: function(method, args) {\n      var fn = this[method] || method;\n      if (typeof fn === 'function') {\n        fn.apply(this, args);\n      }\n    },\n    // bookkeeping observers for memory management\n    registerObserver: function(name, observer) {\n      var o$ = this._observers || (this._observers = {});\n      o$[name] = observer;\n    },\n    unregisterObserver: function(name) {\n      var o$ = this._observers;\n      if (o$ && o$[name]) {\n        o$[name].close();\n        o$[name] = null;\n        return true;\n      }\n    },\n    unregisterObservers: function() {\n      if (this._observers) {\n        var keys=Object.keys(this._observers);\n        for (var i=0, l=keys.length, k, o; (i < l) && (k=keys[i]); i++) {\n          o = this._observers[k];\n          o.close();\n        }\n        this._observers = {};\n      }\n    }\n  };\n\n  // compound path observer\n  function generateCompoundPathObserver(element) {\n    return new CompoundPathObserver(element.notifyPropertyChanges, element);\n  }\n\n  // property binding\n  // bind a property in A to a path in B by converting A[property] to a\n  // getter/setter pair that accesses B[...path...]\n  function bindProperties(inA, inProperty, inB, inPath) {\n    log.bind && console.log(LOG_BIND_PROPS, inB.localName || 'object', inPath, inA.localName, inProperty);\n    // capture A's value if B's value is null or undefined,\n    // otherwise use B's value\n    var path = Path.get(inPath);\n    var v = path.getValueFrom(inB);\n    if (v === null || v === undefined) {\n      path.setValueFrom(inB, inA[inProperty]);\n    }\n    return PathObserver.defineProperty(inA, inProperty, inB, inPath);\n  }\n\n  // logging\n  var LOG_OBSERVE = '[%s] watching [%s]';\n  var LOG_OBSERVED = '[%s#%s] watch: [%s] now [%s] was [%s]';\n  var LOG_CHANGED = '[%s#%s] propertyChanged: [%s] now [%s] was [%s]';\n  var LOG_BIND_PROPS = \"[%s]: bindProperties: [%s] to [%s].[%s]\";\n\n  // exports\n\n  scope.api.instance.properties = properties;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || 0;\n  var events = scope.api.instance.events;\n\n  // expressionista\n\n  // TODO(sorvell): we're patching the syntax while evaluating\n  // event bindings. we'll move this to a better spot when that's done.\n  var _prepareBinding = PolymerExpressions.prototype.prepareBinding;\n  // <[node] [name] = {{path}}>\n  PolymerExpressions.prototype.prepareBinding = function(path, name, node) {\n    // if not an event, delegate to the standard syntax\n    return events.prepareBinding(path, name, node)\n        || _prepareBinding.call(this, path, name, node);\n  };\n\n  var syntax = new PolymerExpressions();\n\n  // element api supporting mdv\n\n  var mdv = {\n    syntax: syntax,\n    instanceTemplate: function(template) {\n      template.bindingDelegate = this.syntax;\n      return template.createInstance(this);\n    },\n    bind: function(name, model, path) {\n      // note: binding is a prepare signal. This allows us to be sure that any\n      // property changes that occur as a result of binding will be observed.\n      if (!this._elementPrepared) {\n        this.prepareElement();\n      }\n      var property = this.propertyForAttribute(name);\n      if (!property) {\n        return this.super(arguments);\n      } else {\n        // clean out the closets\n        this.unbind(name);\n        // use n-way Polymer binding\n        var observer = this.bindProperty(property, model, path);\n        // stick path on observer so it's available via this.bindings\n        observer.path = path;\n        // reflect bound property to attribute when binding\n        // to ensure binding is not left on attribute if property\n        // does not update due to not changing.\n        this.reflectPropertyToAttribute(property);\n        return this.bindings[name] = observer;\n      }\n    },\n    asyncUnbindAll: function() {\n      if (!this._unbound) {\n        log.unbind && console.log('[%s] asyncUnbindAll', this.localName);\n        this._unbindAllJob = this.job(this._unbindAllJob, this.unbindAll, 0);\n      }\n    },\n    unbindAll: function() {\n      if (!this._unbound) {\n        this.unbindAllProperties();\n        this.super();\n        // unbind shadowRoot\n        var root = this.shadowRoot;\n        while (root) {\n          unbindNodeTree(root);\n          root = root.olderShadowRoot;\n        }\n        this._unbound = true;\n      }\n    },\n    cancelUnbindAll: function(preventCascade) {\n      if (this._unbound) {\n        log.unbind && console.warn('[%s] already unbound, cannot cancel unbindAll', this.localName);\n        return;\n      }\n      log.unbind && console.log('[%s] cancelUnbindAll', this.localName);\n      if (this._unbindAllJob) {\n        this._unbindAllJob = this._unbindAllJob.stop();\n      }\n      // cancel unbinding our shadow tree iff we're not in the process of\n      // cascading our tree (as we do, for example, when the element is inserted).\n      if (!preventCascade) {\n        forNodeTree(this.shadowRoot, function(n) {\n          if (n.cancelUnbindAll) {\n            n.cancelUnbindAll();\n          }\n        });\n      }\n    }\n  };\n\n  function unbindNodeTree(node) {\n    forNodeTree(node, _nodeUnbindAll);\n  }\n\n  function _nodeUnbindAll(node) {\n    node.unbindAll();\n  }\n\n  function forNodeTree(node, callback) {\n    if (node) {\n      callback(node);\n      for (var child = node.firstChild; child; child = child.nextSibling) {\n        forNodeTree(child, callback);\n      }\n    }\n  }\n\n  var mustachePattern = /\\{\\{([^{}]*)}}/;\n\n  // exports\n\n  scope.bindPattern = mustachePattern;\n  scope.api.instance.mdv = mdv;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n  var preparingElements = 0;\n\n  var base = {\n    PolymerBase: true,\n    job: Polymer.job,\n    super: Polymer.super,\n    // user entry point for element has had its createdCallback called\n    created: function() {\n    },\n    // user entry point for element has shadowRoot and is ready for\n    // api interaction\n    ready: function() {\n    },\n    createdCallback: function() {\n      this.created();\n      if (this.ownerDocument.defaultView || this.alwaysPrepare ||\n          preparingElements > 0) {\n        this.prepareElement();\n      }\n    },\n    // system entry point, do not override\n    prepareElement: function() {\n      this._elementPrepared = true;\n      // install property observers\n      this.observeProperties();\n      // install boilerplate attributes\n      this.copyInstanceAttributes();\n      // process input attributes\n      this.takeAttributes();\n      // add event listeners\n      this.addHostListeners();\n      // guarantees that while preparing, any\n      // sub-elements are also prepared\n      preparingElements++;\n      // process declarative resources\n      this.parseDeclarations(this.__proto__);\n      // decrement semaphore\n      preparingElements--;\n      // user entry point\n      this.ready();\n    },\n    enteredViewCallback: function() {\n      if (!this._elementPrepared) {\n        this.prepareElement();\n      }\n      this.cancelUnbindAll(true);\n      // invoke user action\n      if (this.enteredView) {\n        this.enteredView();\n      }\n    },\n    leftViewCallback: function() {\n      if (!this.preventDispose) {\n        this.asyncUnbindAll();\n      }\n      // invoke user action\n      if (this.leftView) {\n        this.leftView();\n      }\n    },\n    // TODO(sorvell): bc\n    enteredDocumentCallback: function() {\n      this.enteredViewCallback();\n    },\n    // TODO(sorvell): bc\n    leftDocumentCallback: function() {\n      this.leftViewCallback();\n    },\n    // recursive ancestral <element> initialization, oldest first\n    parseDeclarations: function(p) {\n      if (p && p.element) {\n        this.parseDeclarations(p.__proto__);\n        p.parseDeclaration.call(this, p.element);\n      }\n    },\n    // parse input <element> as needed, override for custom behavior\n    parseDeclaration: function(elementElement) {\n      var template = this.fetchTemplate(elementElement);\n      if (template) {\n        if (this.element.hasAttribute('lightdom')) {\n          this.lightFromTemplate(template);\n        } else {\n          this.shadowFromTemplate(template);\n        }\n      }\n    },\n    // return a shadow-root template (if desired), override for custom behavior\n    fetchTemplate: function(elementElement) {\n      return elementElement.querySelector('template');\n    },\n    // utility function that creates a shadow root from a <template>\n    shadowFromTemplate: function(template) {\n      if (template) {\n        // cache elder shadow root (if any)\n        var elderRoot = this.shadowRoot;\n        // make a shadow root\n        var root = this.createShadowRoot();\n        // migrate flag(s)\n        root.applyAuthorStyles = this.applyAuthorStyles;\n        root.resetStyleInheritance = this.resetStyleInheritance;\n        // stamp template\n        // which includes parsing and applying MDV bindings before being \n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        root.appendChild(dom);\n        // perform post-construction initialization tasks on shadow root\n        this.shadowRootReady(root, template);\n        // return the created shadow root\n        return root;\n      }\n    },\n    // utility function that stamps a <template> into light-dom\n    lightFromTemplate: function(template) {\n      if (template) {\n        // stamp template\n        // which includes parsing and applying MDV bindings before being \n        // inserted (to avoid {{}} in attribute values)\n        // e.g. to prevent <img src=\"images/{{icon}}\"> from generating a 404.\n        var dom = this.instanceTemplate(template);\n        // append to shadow dom\n        this.appendChild(dom);\n        // perform post-construction initialization tasks on ahem, light root\n        this.shadowRootReady(this, template);\n        // return the created shadow root\n        return dom;\n      }\n    },\n    shadowRootReady: function(root, template) {\n      // locate nodes with id and store references to them in this.$ hash\n      this.marshalNodeReferences(root);\n      // set up pointer gestures\n      PointerGestures.register(root);\n    },\n    // locate nodes with id and store references to them in this.$ hash\n    marshalNodeReferences: function(root) {\n      // establish $ instance variable\n      var $ = this.$ = this.$ || {};\n      // populate $ from nodes with ID from the LOCAL tree\n      if (root) {\n        var n$ = root.querySelectorAll(\"[id]\");\n        for (var i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n          $[n.id] = n;\n        };\n      }\n    },\n    attributeChangedCallback: function(name, oldValue) {\n      // TODO(sjmiles): adhoc filter\n      if (name !== 'class' && name !== 'style') {\n        this.attributeToProperty(name, this.getAttribute(name));\n      }\n      if (this.attributeChanged) {\n        this.attributeChanged.apply(this, arguments);\n      }\n    },\n    onMutation: function(node, listener) {\n      var observer = new MutationObserver(function(mutations) {\n        listener.call(this, observer, mutations);\n        observer.disconnect();\n      }.bind(this));\n      observer.observe(node, {childList: true, subtree: true});\n    }\n  };\n\n  // true if object has own PolymerBase api\n  function isBase(object) {\n    return object.hasOwnProperty('PolymerBase') \n  }\n\n  // name a base constructor for dev tools\n\n  function PolymerBase() {};\n  PolymerBase.prototype = base;\n  base.constructor = PolymerBase;\n  \n  // exports\n\n  scope.Base = PolymerBase;\n  scope.isBase = isBase;\n  scope.api.instance.base = base;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  \n  // magic words\n  \n  var STYLE_SCOPE_ATTRIBUTE = 'element';\n  var STYLE_CONTROLLER_SCOPE = 'controller';\n  \n  var styles = {\n    STYLE_SCOPE_ATTRIBUTE: STYLE_SCOPE_ATTRIBUTE,\n    /**\n     * Installs external stylesheets and <style> elements with the attribute \n     * polymer-scope='controller' into the scope of element. This is intended\n     * to be a called during custom element construction. Note, this incurs a \n     * per instance cost and should be used sparingly.\n     *\n     * The need for this type of styling should go away when the shadowDOM spec\n     * addresses these issues:\n     * \n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21391\n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21390\n     * https://www.w3.org/Bugs/Public/show_bug.cgi?id=21389\n     * \n     * @param element The custom element instance into whose controller (parent)\n     * scope styles will be installed.\n     * @param elementElement The <element> containing controller styles.\n    */\n    // TODO(sorvell): remove when spec issues are addressed\n    installControllerStyles: function() {\n      // apply controller styles, but only if they are not yet applied\n      var scope = this.findStyleController();\n      if (scope && !this.scopeHasElementStyle(scope, STYLE_CONTROLLER_SCOPE)) {\n        // allow inherited controller styles\n        var proto = getPrototypeOf(this), cssText = '';\n        while (proto && proto.element) {\n          cssText += proto.element.cssTextForScope(STYLE_CONTROLLER_SCOPE);\n          proto = getPrototypeOf(proto);\n        }\n        if (cssText) {\n          var style = this.element.cssTextToScopeStyle(cssText,\n              STYLE_CONTROLLER_SCOPE);\n          // TODO(sorvell): for now these styles are not shimmed\n          // but we may need to shim them\n          Polymer.applyStyleToScope(style, scope);\n        }\n      }\n    },\n    findStyleController: function() {\n      if (window.ShadowDOMPolyfill) {\n        return wrap(document.head);\n      } else {\n        // find the shadow root that contains this element\n        var n = this;\n        while (n.parentNode) {\n          n = n.parentNode;\n        }\n        return n === document ? document.head : n;\n      }\n    },\n    scopeHasElementStyle: function(scope, descriptor) {\n      var rule = STYLE_SCOPE_ATTRIBUTE + '=' + this.localName + '-' + descriptor;\n      return scope.querySelector('style[' + rule + ']');\n    }\n  };\n  \n  // NOTE: use raw prototype traversal so that we ensure correct traversal\n  // on platforms where the protoype chain is simulated via __proto__ (IE10)\n  function getPrototypeOf(prototype) {\n    return prototype.__proto__;\n  }\n\n  // exports\n\n  scope.api.instance.styles = styles;\n  \n})(Polymer);\n","/* \n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  var path = {\n    addResolvePathApi: function() {\n      var root = this.elementPath();\n      // let assetpath attribute modify the resolve path\n      var assetPath = this.getAttribute('assetpath') || '';\n      var relPath = this.relPath;\n      this.prototype.resolvePath = function(inPath) {\n        var to = inPath;\n        if (assetPath) {\n          // assetPath is always a folder, drop the trailing '/'\n          var from = assetPath.slice(0, -1);\n          to = relPath(from, to);\n        }\n\n        return root + assetPath + to;\n      };\n    },\n    elementPath: function() {\n      return this.urlToPath(HTMLImports.getDocumentUrl(this.ownerDocument));\n    },\n    relPath: function(from, to) {\n      var fromParts = from.split('/');\n      var toParts = to.split('/');\n\n      // chop to common length\n      var common = false;\n      while(fromParts.length && toParts.length && fromParts[0] === toParts[0]) {\n        fromParts.shift();\n        toParts.shift();\n        common = true;\n      }\n\n      // if there were some commonalities, add '../' for differences\n      if (common) {\n        for (var i = 0; i < fromParts.length; i++) {\n          toParts.unshift('..');\n        }\n      }\n      return toParts.join('/');\n    },\n    urlToPath: function(url) {\n      if (!url) {\n        return '';\n      } else {\n        var parts = url.split('/');\n        parts.pop();\n        parts.push('');\n        return parts.join('/');\n      }\n    }\n  };\n\n  // exports\n  scope.api.declaration.path = path;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var log = window.logFlags || {};\n  var api = scope.api.instance.styles;\n  var STYLE_SCOPE_ATTRIBUTE = api.STYLE_SCOPE_ATTRIBUTE;\n\n  // magic words\n\n  var STYLE_SELECTOR = 'style';\n  var SHEET_SELECTOR = '[rel=stylesheet]';\n  var STYLE_GLOBAL_SCOPE = 'global';\n  var SCOPE_ATTR = 'polymer-scope';\n\n  var styles = {\n    /**\n     * Install external stylesheets loaded in <element> elements into the \n     * element's template.\n     * @param elementElement The <element> element to style.\n     */\n    installSheets: function() {\n      this.cacheSheets();\n      this.cacheStyles();\n      this.installLocalSheets();\n      this.installGlobalStyles();\n    },\n    /**\n     * Remove all sheets from element and store for later use.\n     */\n    cacheSheets: function() {\n      this.sheets = this.findNodes(SHEET_SELECTOR);\n      this.sheets.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    cacheStyles: function() {\n      this.styles = this.findNodes(STYLE_SELECTOR + '[' + SCOPE_ATTR + ']');\n      this.styles.forEach(function(s) {\n        if (s.parentNode) {\n          s.parentNode.removeChild(s);\n        }\n      });\n    },\n    /**\n     * Takes external stylesheets loaded in an <element> element and moves\n     * their content into a <style> element inside the <element>'s template.\n     * The sheet is then removed from the <element>. This is done only so \n     * that if the element is loaded in the main document, the sheet does\n     * not become active.\n     * Note, ignores sheets with the attribute 'polymer-scope'.\n     * @param elementElement The <element> element to style.\n     */\n    installLocalSheets: function () {\n      var sheets = this.sheets.filter(function(s) {\n        return !s.hasAttribute(SCOPE_ATTR);\n      });\n      var content = this.templateContent();\n      if (content) {\n        var cssText = '';\n        sheets.forEach(function(sheet) {\n          cssText += cssTextFromSheet(sheet) + '\\n';\n        });\n        if (cssText) {\n          content.insertBefore(createStyleElement(cssText), content.firstChild);\n        }\n      }\n    },\n    findNodes: function(selector, matcher) {\n      var nodes = this.querySelectorAll(selector).array();\n      var content = this.templateContent();\n      if (content) {\n        var templateNodes = content.querySelectorAll(selector).array();\n        nodes = nodes.concat(templateNodes);\n      }\n      return matcher ? nodes.filter(matcher) : nodes;\n    },\n    templateContent: function() {\n      var template = this.querySelector('template');\n      return template && templateContent(template);\n    },\n    /**\n     * Promotes external stylesheets and <style> elements with the attribute \n     * polymer-scope='global' into global scope.\n     * This is particularly useful for defining @keyframe rules which \n     * currently do not function in scoped or shadow style elements.\n     * (See wkb.ug/72462)\n     * @param elementElement The <element> element to style.\n    */\n    // TODO(sorvell): remove when wkb.ug/72462 is addressed.\n    installGlobalStyles: function() {\n      var style = this.styleForScope(STYLE_GLOBAL_SCOPE);\n      applyStyleToScope(style, document.head);\n    },\n    cssTextForScope: function(scopeDescriptor) {\n      var cssText = '';\n      // handle stylesheets\n      var selector = '[' + SCOPE_ATTR + '=' + scopeDescriptor + ']';\n      var matcher = function(s) {\n        return matchesSelector(s, selector);\n      };\n      var sheets = this.sheets.filter(matcher);\n      sheets.forEach(function(sheet) {\n        cssText += cssTextFromSheet(sheet) + '\\n\\n';\n      });\n      // handle cached style elements\n      var styles = this.styles.filter(matcher);\n      styles.forEach(function(style) {\n        cssText += style.textContent + '\\n\\n';\n      });\n      return cssText;\n    },\n    styleForScope: function(scopeDescriptor) {\n      var cssText = this.cssTextForScope(scopeDescriptor);\n      return this.cssTextToScopeStyle(cssText, scopeDescriptor);\n    },\n    cssTextToScopeStyle: function(cssText, scopeDescriptor) {\n      if (cssText) {\n        var style = createStyleElement(cssText);\n        style.setAttribute(STYLE_SCOPE_ATTRIBUTE, this.getAttribute('name') +\n            '-' + scopeDescriptor);\n        return style;\n      }\n    }\n  };\n\n  function applyStyleToScope(style, scope) {\n    if (style) {\n      // TODO(sorvell): necessary for IE\n      // see https://connect.microsoft.com/IE/feedback/details/790212/\n      // cloning-a-style-element-and-adding-to-document-produces\n      // -unexpected-result#details\n      // var clone = style.cloneNode(true);\n      var clone = createStyleElement(style.textContent);\n      var attr = style.getAttribute(STYLE_SCOPE_ATTRIBUTE);\n      if (attr) {\n        clone.setAttribute(STYLE_SCOPE_ATTRIBUTE, attr);\n      }\n      scope.appendChild(clone);\n    }\n  }\n\n  function createStyleElement(cssText) {\n    var style = document.createElement('style');\n    style.textContent = cssText;\n    return style;\n  }\n\n  function cssTextFromSheet(sheet) {\n    return (sheet && sheet.__resource) || '';\n  }\n\n  function matchesSelector(node, inSelector) {\n    if (matches) {\n      return matches.call(node, inSelector);\n    }\n  }\n  var p = HTMLElement.prototype;\n  var matches = p.matches || p.matchesSelector || p.webkitMatchesSelector \n      || p.mozMatchesSelector;\n  \n  // exports\n\n  scope.api.declaration.styles = styles;\n  scope.applyStyleToScope = applyStyleToScope;\n  \n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n\n(function(scope) {\n\n  // imports\n\n  var api = scope.api.instance.events;\n  var log = window.logFlags || {};\n\n  // polymer-element declarative api: events feature\n\n  var events = { \n    parseHostEvents: function() {\n      // our delegates map\n      var delegates = this.prototype.eventDelegates;\n      // extract data from attributes into delegates\n      this.addAttributeDelegates(delegates);\n    },\n    addAttributeDelegates: function(delegates) {\n      // for each attribute\n      for (var i=0, a; a=this.attributes[i]; i++) {\n        // does it have magic marker identifying it as an event delegate?\n        if (api.hasEventPrefix(a.name)) {\n          // if so, add the info to delegates\n          delegates[api.removeEventPrefix(a.name)] = a.value.replace('{{', '')\n              .replace('}}', '').trim();\n        }\n      }\n    },\n    event_translations: {\n      webkitanimationstart: 'webkitAnimationStart',\n      webkitanimationend: 'webkitAnimationEnd',\n      webkittransitionend: 'webkitTransitionEnd',\n      domfocusout: 'DOMFocusOut',\n      domfocusin: 'DOMFocusIn'\n    }\n  };\n\n  // exports\n\n  scope.api.declaration.events = events;\n\n})(Polymer);","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // element api\n\n  var properties = {\n    inferObservers: function(prototype) {\n      var observe = prototype.observe, property;\n      for (var n in prototype) {\n        if (n.slice(-7) === 'Changed') {\n          if (!observe) {\n            observe  = (prototype.observe = {});\n          }\n          property = n.slice(0, -7)\n          observe[property] = observe[property] || n;\n        }\n      }\n    },\n    optimizePropertyMaps: function(prototype) {\n      if (prototype.observe) {\n        // construct name list\n        var a = prototype._observeNames = [];\n        for (var n in prototype.observe) {\n          a.push(n);\n        }\n      }\n      if (prototype.publish) {\n        // construct name list\n        var a = prototype._publishNames = [];\n        for (var n in prototype.publish) {\n          a.push(n);\n        }\n      }\n    },\n    publishProperties: function(prototype, base) {\n      // if we have any properties to publish\n      var publish = prototype.publish;\n      if (publish) {\n        // transcribe `publish` entries onto own prototype\n        this.requireProperties(publish, prototype, base);\n        // construct map of lower-cased property names\n        prototype._publishLC = this.lowerCaseMap(publish);\n      }\n    },\n    requireProperties: function(properties, prototype, base) {\n      // ensure a prototype value for each property\n      for (var n in properties) {\n        if (prototype[n] === undefined && base[n] === undefined) {\n          prototype[n] = properties[n];\n        }\n      }\n    },\n    lowerCaseMap: function(properties) {\n      var map = {};\n      for (var n in properties) {\n        map[n.toLowerCase()] = n;\n      }\n      return map;\n    }\n  };\n\n  // exports\n\n  scope.api.declaration.properties = properties;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // magic words\n\n  var ATTRIBUTES_ATTRIBUTE = 'attributes';\n\n  // attributes api\n\n  var attributes = {\n    inheritAttributesObjects: function(prototype) {\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject(prototype, 'publishLC');\n      // chain our instance attributes map to the inherited version\n      this.inheritObject(prototype, '_instanceAttributes');\n    },\n    publishAttributes: function(prototype, base) {\n      // merge names from 'attributes' attribute\n      var attributes = this.getAttribute(ATTRIBUTES_ATTRIBUTE);\n      if (attributes) {\n        // get properties to publish\n        var publish = prototype.publish || (prototype.publish = {});\n        // names='a b c' or names='a,b,c'\n        var names = attributes.split(attributes.indexOf(',') >= 0 ? ',' : ' ');\n        // record each name for publishing\n        for (var i=0, l=names.length, n; i<l; i++) {\n          // remove excess ws\n          n = names[i].trim();\n          // do not override explicit entries\n          if (n && publish[n] === undefined && base[n] === undefined) {\n            publish[n] = null;\n          }\n        }\n      }\n    },\n    // record clonable attributes from <element>\n    accumulateInstanceAttributes: function() {\n      // inherit instance attributes\n      var clonable = this.prototype._instanceAttributes;\n      // merge attributes from element\n      var a$ = this.attributes;\n      for (var i=0, l=a$.length, a; (i<l) && (a=a$[i]); i++) {  \n        if (this.isInstanceAttribute(a.name)) {\n          clonable[a.name] = a.value;\n        }\n      }\n    },\n    isInstanceAttribute: function(name) {\n      return !this.blackList[name] && name.slice(0,3) !== 'on-';\n    },\n    // do not clone these attributes onto instances\n    blackList: {name: 1, 'extends': 1, constructor: 1, noscript: 1}\n  };\n\n  // add ATTRIBUTES_ATTRIBUTE to the blacklist\n  attributes.blackList[ATTRIBUTES_ATTRIBUTE] = 1;\n\n  // exports\n\n  scope.api.declaration.attributes = attributes;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n  \n  var api = scope.api;\n  var isBase = scope.isBase;\n  var extend = scope.extend;\n\n  // prototype api\n\n  var prototype = {\n    register: function(name, extendee) {\n      // build prototype combining extendee, Polymer base, and named api\n      this.prototype = this.buildPrototype(name, extendee);\n      // back reference declaration element\n      // TODO(sjmiles): replace `element` with `elementElement` or `declaration`\n      this.prototype.element = this;\n      // more declarative features\n      this.desugar(name, extendee);\n      // register our custom element with the platform\n      this.registerPrototype(name, extendee);\n      // reference constructor in a global named by 'constructor' attribute\n      this.publishConstructor();\n    },\n    buildPrototype: function(name, extendee) {\n      // get our custom prototype (before chaining)\n      var prototype = scope.getRegisteredPrototype(name);\n      // get basal prototype\n      var base = this.generateBasePrototype(extendee);\n      // transcribe `attributes` declarations onto own prototype's `publish`\n      this.publishAttributes(prototype, base);\n      // `publish` properties to the prototype and to attribute watch\n      this.publishProperties(prototype, base);\n      // infer observers for `observe` list based on method names\n      this.inferObservers(prototype);\n      // chain various meta-data objects to inherited versions\n      this.inheritMetaData(prototype, base);\n      // chain custom api to inherited\n      prototype = this.chainObject(prototype, base);\n      // build side-chained lists to optimize iterations\n      this.optimizePropertyMaps(prototype);\n      // x-platform fixup\n      ensurePrototypeTraversal(prototype);\n      return prototype;\n    },\n    inheritMetaData: function(prototype, base) {\n      // chain observe object to inherited\n      this.inheritObject('observe', prototype, base);\n      // chain publish object to inherited\n      this.inheritObject('publish', prototype, base);\n      // chain our lower-cased publish map to the inherited version\n      this.inheritObject('_publishLC', prototype, base);\n      // chain our instance attributes map to the inherited version\n      this.inheritObject('_instanceAttributes', prototype, base);\n      // chain our event delegates map to the inherited version\n      this.inheritObject('eventDelegates', prototype, base);\n    },\n    // implement various declarative features\n    desugar: function(name, extendee) {\n      // compile list of attributes to copy to instances\n      this.accumulateInstanceAttributes();\n      // parse on-* delegates declared on `this` element\n      this.parseHostEvents();\n      // install external stylesheets as if they are inline\n      this.installSheets();\n      //\n      this.adjustShadowElement();\n      //\n      // TODO(sorvell): install a helper method this.resolvePath to aid in \n      // setting resource paths. e.g.\n      // this.$.image.src = this.resolvePath('images/foo.png')\n      // Potentially remove when spec bug is addressed.\n      // https://www.w3.org/Bugs/Public/show_bug.cgi?id=21407\n      this.addResolvePathApi();\n      // under ShadowDOMPolyfill, transforms to approximate missing CSS features\n      if (window.ShadowDOMPolyfill) {\n        Platform.ShadowCSS.shimStyling(this.templateContent(), name, extendee);\n      }\n      // allow custom element access to the declarative context\n      if (this.prototype.registerCallback) {\n        this.prototype.registerCallback(this);\n      }\n    },\n    // TODO(sorvell): remove when spec addressed:\n    // https://www.w3.org/Bugs/Public/show_bug.cgi?id=22460\n    // make <shadow></shadow> be <shadow><content></content></shadow>\n    adjustShadowElement: function() {\n      // TODO(sorvell): avoid under SD polyfill until this bug is addressed:\n      // https://github.com/Polymer/ShadowDOM/issues/297\n      if (!window.ShadowDOMPolyfill) {\n        var content = this.templateContent();\n        if (content) {\n          var s$ = content.querySelectorAll('shadow');\n          for (var i=0, l=s$.length, s; (i<l) && (s=s$[i]); i++) {\n            if (!s.children.length) {\n              s.appendChild(document.createElement('content'));\n            }\n          }\n        }\n      }\n    },\n    // if a named constructor is requested in element, map a reference\n    // to the constructor to the given symbol\n    publishConstructor: function() {\n      var symbol = this.getAttribute('constructor');\n      if (symbol) {\n        window[symbol] = this.ctor;\n      }\n    },\n    // build prototype combining extendee, Polymer base, and named api\n    generateBasePrototype: function(extnds) {\n      var prototype = this.findBasePrototype(extnds);\n      if (!prototype) {\n        // create a prototype based on tag-name extension\n        var prototype = HTMLElement.getPrototypeForTag(extnds);\n        // insert base api in inheritance chain (if needed)\n        prototype = this.ensureBaseApi(prototype);\n        // memoize this base\n        memoizedBases[extnds] = prototype;\n      }\n      return prototype;\n    },\n    findBasePrototype: function(name) {\n      return memoizedBases[name];\n    },\n    // install Polymer instance api into prototype chain, as needed \n    ensureBaseApi: function(prototype) {\n      if (!prototype.PolymerBase) {\n       prototype = Object.create(prototype);\n       // we need a unique copy of base api for each base prototype\n       // therefore we 'extend' here instead of simply chaining\n       // we could memoize instead, especially for the common cases,\n       // in particular, for base === HTMLElement.prototype\n       for (var n in api.instance) {\n         extend(prototype, api.instance[n]);\n       }\n      }\n      // return buffed-up prototype\n      return prototype;\n    },\n    // ensure prototype[name] inherits from a prototype.prototype[name]\n    inheritObject: function(name, prototype, base) {\n      // require an object\n      var source = prototype[name] || {};\n      // chain inherited properties onto a new object\n      prototype[name] = this.chainObject(source, base[name]);\n    },\n    // register 'prototype' to custom element 'name', store constructor \n    registerPrototype: function(name, extendee) { \n      var info = {\n        prototype: this.prototype\n      }\n      // native element must be specified in extends\n      var typeExtension = this.findTypeExtension(extendee);\n      if (typeExtension) {\n        info.extends = typeExtension;\n      }\n      // register the custom type\n      this.ctor = document.register(name, info);\n      // constructor shenanigans\n      this.prototype.constructor = this.ctor;\n      // register the prototype with HTMLElement for name lookup\n      HTMLElement.register(name, this.prototype);\n    }, \n    findTypeExtension: function(name) {\n      if (name && name.indexOf('-') < 0) {\n        return name;\n      } else {\n        var p = this.findBasePrototype(name);\n        if (p.element) {\n          return this.findTypeExtension(p.element.extends);\n        }\n      }\n    }\n  };\n\n  if (Object.__proto__) {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        object.__proto__ = inherited;\n      }\n      return object;\n    }\n  } else {\n    prototype.chainObject = function(object, inherited) {\n      if (object && inherited && object !== inherited) {\n        var chained = Object.create(inherited);\n        object = extend(chained, object);\n      }\n      return object;\n    }\n  }\n\n  // memoize base prototypes\n  memoizedBases = {};\n\n  // On platforms that do not support __proto__ (version of IE), the prototype\n  // chain of a custom element is simulated via installation of __proto__.\n  // Although custom elements manages this, we install it here so it's\n  // available during desugaring.\n  function ensurePrototypeTraversal(prototype) {\n    if (!Object.__proto__) {\n      var ancestor = Object.getPrototypeOf(prototype);\n      prototype.__proto__ = ancestor;\n      if (isBase(ancestor)) {\n        ancestor.__proto__ = Object.getPrototypeOf(ancestor);\n      }\n    }\n  }\n\n  // exports\n\n  api.declaration.prototype = prototype;\n\n})(Polymer);\n","/*\n * Copyright 2013 The Polymer Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style\n * license that can be found in the LICENSE file.\n */\n(function(scope) {\n\n  // imports\n\n  var extend = scope.extend;\n  var apis = scope.api.declaration;\n\n  // imperative implementation: Polymer()\n\n  // specify an 'own' prototype for tag `name`\n  function element(name, prototype) {\n    //console.log('registering [' + name + ']');\n    // cache the prototype\n    prototypesByName[name] = prototype || {};\n    // notify the registrar waiting for 'name', if any\n    notifyPrototype(name);\n  }\n\n  // declarative implementation: <polymer-element>\n\n  var prototype = extend(Object.create(HTMLElement.prototype), {\n    createdCallback: function() {\n      // fetch the element name\n      this.name = this.getAttribute('name');\n      // fetch our extendee name\n      this.extends = this.getAttribute('extends');\n      // install element definition, if ready\n      this.registerWhenReady();\n    },\n    registerWhenReady: function() {\n      // if we have no prototype, wait\n      if (this.waitingForPrototype(this.name)) {\n        return;\n      }\n      var extendee = this.extends;\n      if (this.waitingForExtendee(extendee)) {\n        //console.warn(this.name + ': waitingForExtendee:' + extendee);\n        return;\n      }\n      // TODO(sjmiles): HTMLImports polyfill awareness:\n      // elements in the main document are likely to parse\n      // in advance of elements in imports because the\n      // polyfill parser is simulated\n      // therefore, wait for imports loaded before\n      // finalizing elements in the main document\n      if (document.contains(this)) {\n        whenImportsLoaded(function() {\n          this._register(extendee);\n        }.bind(this));\n      } else {\n        this._register(extendee);\n      }\n    },\n    _register: function(extendee) {\n      //console.group('registering', this.name);\n      this.register(this.name, extendee);\n      //console.groupEnd();\n      // subclasses may now register themselves\n      notifySuper(this.name);\n    },\n    waitingForPrototype: function(name) {\n      if (!getRegisteredPrototype(name)) {\n        // then wait for a prototype\n        waitPrototype[name] = this;\n        // if explicitly marked as 'noscript'\n        if (this.hasAttribute('noscript')) {\n          // TODO(sorvell): CustomElements polyfill awareness:\n          // noscript elements should upgrade in logical order\n          // script injection ensures this under native custom elements;\n          // under imports + ce polyfills, scripts run before upgrades.\n          // dependencies should be ready at upgrade time so register\n          // prototype at this time.\n          if (window.CustomElements && !CustomElements.useNative) {\n            element(name);\n          } else {\n            var script = document.createElement('script');\n            script.textContent = 'Polymer(\\'' + name + '\\');';\n            this.appendChild(script);\n          }\n        }\n        return true;\n      }\n    },\n    waitingForExtendee: function(extendee) {\n      // if extending a custom element...\n      if (extendee && extendee.indexOf('-') >= 0) {\n        // wait for the extendee to be registered first\n        if (!isRegistered(extendee)) {\n          (waitSuper[extendee] = (waitSuper[extendee] || [])).push(this);\n          return true;\n        }\n      }\n    }\n  });\n\n  // semi-pluggable APIs \n  // TODO(sjmiles): should be fully pluggable (aka decoupled, currently\n  // the various plugins are allowed to depend on each other directly)\n  Object.keys(apis).forEach(function(n) {\n    extend(prototype, apis[n]);\n  });\n\n  // utility and bookkeeping\n  \n  // maps tag names to prototypes\n  var prototypesByName = {};\n\n  function getRegisteredPrototype(name) {\n    return prototypesByName[name];\n  }\n\n  // elements waiting for prototype, by name\n  var waitPrototype = {};\n\n  function notifyPrototype(name) {\n    if (waitPrototype[name]) {\n      waitPrototype[name].registerWhenReady();\n      delete waitPrototype[name];\n    }\n  }\n\n  // elements waiting for super, by name\n  var waitSuper = {};\n\n  function notifySuper(name) {\n    registered[name] = true;\n    var waiting = waitSuper[name];\n    if (waiting) {\n      waiting.forEach(function(w) {\n        w.registerWhenReady();\n      });\n      delete waitSuper[name];\n    }\n  }\n\n  // track document.register'ed tag names\n\n  var registered = {};\n\n  function isRegistered(name) {\n    return registered[name];\n  }\n\n  function whenImportsLoaded(doThis) {\n    if (window.HTMLImports && !HTMLImports.readyTime) {\n      addEventListener('HTMLImportsLoaded', doThis);\n    } else {\n      doThis();\n    }\n  }\n\n  // exports\n  \n  scope.getRegisteredPrototype = getRegisteredPrototype;\n  \n  // namespace shenanigans so we can expose our scope on the registration \n  // function\n\n  // TODO(sjmiles): find a way to do this that is less terrible\n  // copy window.Polymer properties onto `element()`\n  extend(element, scope);\n  // make window.Polymer reference `element()`\n  window.Polymer = element;\n\n  // register polymer-element with document\n  document.register('polymer-element', {prototype: prototype});\n})(Polymer);\n"]}