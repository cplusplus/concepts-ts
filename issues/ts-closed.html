<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Concepts Closed Issues List</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<table>
<tr>
  <td align="left">Date:</td>
  <td align="left">2016-01-30</td>
</tr>
<tr>
  <td align="left">Project:</td>
  <td align="left">C++ Extensions for Concepts</td>
</tr>
<tr>
  <td align="left">Reply to:</td>
  <td align="left">Andrew Sutton &lt;<a href="mailto:asutton@uakron.ed">asutton@uakron.ed</a>&gt;</td>
</tr>
</table>
<h1>C++ Concepts Closed Issues List (Revision 1)</h1>
<p>Revised 2016-01-30 at 13:01:36 UTC</p>

  <p>Reference ISO/IEC TS 19217</p>
  <p>Also see:</p>
    <ul>
      <li><a href="ts-toc.html">Table of Contents</a> for all concepts issues.</li>
      <li><a href="ts-index.html">Index by Section</a> for all concepts issues.</li>
      <li><a href="ts-status.html">Index by Status</a> for all concepts issues.</li>
      <li><a href="ts-active.html">Concepts Active Issues List</a></li>
      <li><a href="ts-complete.html">Concepts Complete Issues List</a></li>
    </ul>

  <p>This document contains only concepts issues which have been closed
  by the Core Working Group as duplicates or not defects. That is,
  issues which have a status of <a href="ts-active.html#Dup">Dup</a> or
  <a href="ts-active.html#NAD">NAD</a>. See the <a href="ts-active.html">Concepts Active Issues List</a> active issues and more
  information. See the <a href="ts-complete.html">Concepts Complete Issues List</a> for issues considered
  accepted extensions.  The introductory material in that document also applies to
  this document.</p>

<h2>Revision History</h2>
<ul>
<li>R12: 2015-05-22 post-Lenexa mailing<ul>
<li><b>Summary:</b><ul>
<li>16 open issues, up by 16.</li>
<li>12 closed issues, up by 12.</li>
<li>28 issues total, up by 28.</li>
</ul></li>
<li><b>Details:</b><ul>
<li>Added the following CWG issue: <a href="ts-closed.html#1">1</a>.</li>
<li>Added the following 11 EWG issues: <a href="ts-closed.html#2">2</a>, <a href="ts-closed.html#3">3</a>, <a href="ts-closed.html#4">4</a>, <a href="ts-closed.html#5">5</a>, <a href="ts-closed.html#6">6</a>, <a href="ts-closed.html#7">7</a>, <a href="ts-closed.html#8">8</a>, <a href="ts-closed.html#9">9</a>, <a href="ts-closed.html#10">10</a>, <a href="ts-closed.html#11">11</a>, <a href="ts-closed.html#12">12</a>.</li>
<li>Added the following 16 New issues: <a href="ts-active.html#13">13</a>, <a href="ts-active.html#14">14</a>, <a href="ts-active.html#15">15</a>, <a href="ts-active.html#16">16</a>, <a href="ts-active.html#17">17</a>, <a href="ts-active.html#18">18</a>, <a href="ts-active.html#19">19</a>, <a href="ts-active.html#20">20</a>, <a href="ts-active.html#21">21</a>, <a href="ts-active.html#22">22</a>, <a href="ts-active.html#23">23</a>, <a href="ts-active.html#24">24</a>, <a href="ts-active.html#25">25</a>, <a href="ts-active.html#26">26</a>, <a href="ts-active.html#27">27</a>, <a href="ts-active.html#28">28</a>.</li>
</ul></li>
</ul>
</li>
</ul>

<h2>Closed Issues</h2>
<hr>
<h3><a name="1"></a>1. Relationship of implicit conversion constraints to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 14.10.1.1 [temp.constr.conv] <b>Status:</b> <a href="ts-active.html#CWG">CWG</a>
 <b>Submitter:</b> CA <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.conv">issues</a> in [temp.constr.conv].</p>
<p><b>Discussion:</b></p>
<p>
More a suggestion than a comment: would a convertible-to-type example 
like the following be appropriate?

<pre>
<code>
template &lt;typename T&gt; concept bool D =
requires (T a) {
  { a } -&gt; int; // std::is_convertible&lt;T,int&gt;::value ?
};
</code>
</pre>

It could be here or in 14.10.1.6, but I get the feeling it would follow the
<code>a==b</code> example  nicely. There is something similar in the  middle of the page,
with concept C2, but it is more involved and contributes something else to
reader comprehension.
</p>

During discussion in the July telecon, it was determined that there
is a CWG issue related to this request. In particular, it is not
obvious whether access checking was always applied or whether it
depending on the context in which the constraint was evaluated.
Unfortunately, the minutes did not capture which issue.





<hr>
<h3><a name="2"></a>2. Allow concepts as class members</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> FI <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems unfortunate that concepts cannot be declared as members of class
templates. This seemingly makes it impossible to define concepts for
constraining multiple template parameter packs (if concepts as static member
functions were possible, one could provide e.g. two packs so that the class
template gets the first pack and the member function template gets the
second. That can't be done with a namespace scope concept because multiple
packs in function templates require deduction, and concepts  don't take
arguments that could be deduced.). As an example, practical needs for such
constraining arise in standard library implementations, when constraining
the variadic converting constructors of  <code>std::tuple</code>.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="3"></a>3. Allow requires-expressions in more contexts</h3>
<p><b>Section:</b> 5.1.4 [expr.prim.req] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req">issues</a> in [expr.prim.req].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following requirement seems overly restrictive, as it can be fairly 
easily (but tediously) be worked around: "A <i>requires-expression</i> shall
appear only within a concept definition (7.1.7), or within the 
<i>requires-clause</i> of a template declaration (Clause 14) or function declaration
(8.3.5)."

(The tedious workaround for each concept C is to define an overload set 
consisting of two function templates, one unconstrained and returning false, 
the other constrained by C and returning true.)
</p>

<p>
Proposed change: Eliminate the requirement, thereby permitting 
other uses for this new kind of expression of type <code>bool</code>. (For example, 
requires足-expressions might replace many or all of the Boolean type traits.)
Additionally, in any context where a bool value is permitted, allow a 
concept's name plus suitable arguments to denote the truth value of the claim
that "this combination of arguments satisfy this concept." (This syntax is 
currently valid in only certain contexts such as requires足expressions.)
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="4"></a>4. Exception constraints</h3>
<p><b>Section:</b> 5.1.4.3 [expr.prim.req.compound] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req.compound">issues</a> in [expr.prim.req.compound].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We believe that (generally speaking) the non throwing of exceptions is a 
part of the runtime contract of a function, not something that should be
advertised in the type system outside a few very specific cases related to 
move operations. As a <code>requires</code> expression is always free to invoke the
<code>noexcept</code> operator to produce a predicate, we believe that is sufficient 
support for exception constraints in the language, and directly
supporting this additional term in the grammar would be harmful, encouraging 
compile-time contracts taking away an important library implementer freedom. 
As the TS is intended to provide feedback, we believe it would be better to
proceed without this, and see how much demand arises from using the 
alternate form, and whether that alternate form alone is too cumbersome for 
real world use.
</p>

<p>
Simplify the <i>compound-requirement</i>: term in 5.1.4.3:

<pre>
<code>
    { expression } <del>[noexcept]</del> [trailing-足return足-type]
</code>
</pre>

Strike 14.10.1.7.
</p>

<p>
Also see <a href="ts-closed.html#5">5</a> as it relates.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="5"></a>5. Extending exception constraints</h3>
<p><b>Section:</b> 5.1.4.3 [expr.prim.req.compound] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req.compound">issues</a> in [expr.prim.req.compound].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
If we retain exception constraints, the optional `noexcept` specifier 
should support the full range of the noexcept grammar.

Amend <i>compound-requirement</i>:
<pre>
<code>
    { expression } <del>[noexcept]</del> <ins>[noexcept-specification]</ins> [trailing-return-type]
</code>
</pre>
</p>

<p>
Also see <a href="ts-closed.html#4">4</a> as it relates.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="6"></a>6. Simplify concept definitions</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Using <code>concept</code> as a <i>decl-specifer</i>, rather than forming a first class 
entity like a type or template, makes the feature appear more complex than 
it needs to be. Concepts would be simpler (for user and [we believe]
the specification) if there was only one kind, rather than both function 
and variable syntax; the <code>bool</code> keyword would become redundant and the 
set of restrictions on concepts based on them being functions or variables 
would disappear.

We will provide a paper in time for the Lenexa pre meeting mailing 
proposing a grammar that would give all concepts the form:

<pre>
<code>
    template &lt;typename T&gt;
    concept C = predicate;
</code>
</pre>
</p>

<p>
Also see issues <a href="ts-closed.html#7">7</a> and <a href="ts-closed.html#8">8</a> as they relate.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="7"></a>7. Remove function concepts</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The syntactic distinction between a function concept  and a variable concept
seems to serve no useful  purpose. A single concept syntax seems sufficient,
and especially so once redundant elements are removed.

Merge the two concept forms into one, streamlining the syntax by eliminating 
at least the following redundant elements: explicit bool (see comment below), 
explicit return, and the always empty parentheses constituting the function
parameter list.
</p>

<p>
Also see issues <a href="ts-closed.html#6">6</a> and <a href="ts-closed.html#8">8</a> as they relate.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="8"></a>8. Implicit bool for concepts</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Since a concept's type always must be <code>bool</code>, there seems little reason to
require the source code to say  so explicitly. Typing concept should be
sufficient without also typing bool immediately afterward.

Allow the compiler to supply bool (a) as the implicit return type for a
function concept and (b) as the implicit type for a variable concept. (Note:
this comment is implicitly accepted if issue <a href="ts-closed.html#7">7</a> is accepted.)
</p>

<p>
Also see issues <a href="ts-closed.html#6">6</a> and <a href="ts-closed.html#7">7</a> as they relate.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="9"></a>9. Concern about terse notation</h3>
<p><b>Section:</b> 7.1.6.4.2 [dcl.spec.auto.constr] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have a broad concern that the ambiguity for a reader between a
constrained function template without a template-introducer and a "regular"
function will make the language unnecessarily difficult to teach, read, and
maintain code. We note that a TS is the perfect vehicle to have an experiment 
to establish if these concerns are real, but want to exercise caution as we 
proceed, and be sure that there is a real feedback plan in place before 
considering moving this feature from a TS and into a future standard.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="10"></a>10. Redundant expressions of constraints</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are too many redundant ways to express the same set of requirements.
While each presents a reasonable use-case in isolation, the combined effect is
overwhelming.

Proposed solution: Review the overlapping syntaxes, and eliminate those
that add least value, or are least frequently used. This may mean shipping 
the TS in close to its current form to obtain such feedback though.
</p>

<p>
Suggest opening an EWG issue.
</p>





<hr>
<h3><a name="11"></a>11. Concerns about subsumption and equivalence rules</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have a broad concern that it is hard to understand the feature purely 
from the specification, especially the subsumption rules, and equivalence 
rules to know when two signatures declare the same function or
are ambiguous equally constrained overloads, yet there is a lack of readily
available implementations to test our understanding against. While the feature
set of the TS looks good, we think one more iteration on the specification 
would be useful.

Proposed solution: Recast the rules for subsumption as a mini grammar
(distinct from the C++ grammar) as the English text appears to be trying to 
describe a grammar, but less formally, which leads to a potential lack of 
precision, and more confusion for the reader. We are not highlighting specific 
lack of precision at this time, as we have not emerged from confusion in 
time to file appropriate comments.
</p>

<p>
These concerns are better addressed in EWG.
</p>





<hr>
<h3><a name="12"></a>12. Add same-type constraints for expressions</h3>
<p><b>Section:</b> 14.10.1.1 [temp.constr.conv] <b>Status:</b> <a href="ts-active.html#EWG">EWG</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-01-30</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.conv">issues</a> in [temp.constr.conv].</p>
<p><b>View all issues with</b> <a href="ts-status.html#EWG">EWG</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This paragraph introduces implicit conversion constraints to specify (via the
trailing-return-type notation <code>-></code>) that a constraint is satisfied iff an 
expression <code>E</code> is convertible to a type <code>T</code>. It would be very useful to have 
similar constraints that are satisfied iff <code>decltype(E)</code> is exactly the type
<code>T</code>.

Introduce new notation (e.g., <code>E => T</code>) to denote a constraint that is 
satisfied iff the expression <code>E</code> has precisely the type <code>T</code>. Here is a 
practical example of the utility of such a feature: 

<pre>
<code>
    template &lt;typename T&gt;
    concept bool CopyAssignable = requires (T a, T b) { 
      { a = b } => T const&amp;;
    };
</code>
</pre>
</p>

<p>
This is a proposal for an extension and is better addressed in EWG.
</p>





</body>
</html>
