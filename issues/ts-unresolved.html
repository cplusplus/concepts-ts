<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Concepts Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2016-06-19 at 12:06:34 UTC</p>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="1"></a>1. Relationship of implicit conversion constraints to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 14.10.1.1 [temp.constr.conv] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> CA <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-06-16</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.conv">issues</a> in [temp.constr.conv].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
More a suggestion than a comment: would a convertible-to-type example
like the following be appropriate?

<pre>
<code>
template &lt;typename T&gt; concept bool D =
requires (T a) {
  { a } -&gt; int; // equivalent to std::is_convertible&lt;T,int&gt;::value ?
};
</code>
</pre>

It could be here or in 14.10.1.6, but I get the feeling it would follow the
<code>a==b</code> example  nicely. There is something similar in the  middle of the page,
with concept C2, but it is more involved and contributes something else to
reader comprehension.
</p>

During discussion in the July telecon, it was determined that there
is a CWG issue related to this request. In particular, it is not
obvious whether access checking was always applied or whether it
depending on the context in which the constraint was evaluated.
Unfortunately, the minutes did not capture which issue.





<hr>
<h3><a name="3"></a>3. Allow requires-expressions in more contexts</h3>
<p><b>Section:</b> 5.1.4 [expr.prim.req] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#expr.prim.req">active issues</a> in [expr.prim.req].</p>
<p><b>View all other</b> <a href="ts-index.html#expr.prim.req">issues</a> in [expr.prim.req].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following requirement seems overly restrictive, as it can be fairly
easily (but tediously) be worked around: "A <i>requires-expression</i> shall
appear only within a concept definition (7.1.7), or within the
<i>requires-clause</i> of a template declaration (Clause 14) or function declaration
(8.3.5)."

(The tedious workaround for each concept C is to define an overload set
consisting of two function templates, one unconstrained and returning false,
the other constrained by C and returning true.)
</p>

<p>
Proposed change: Eliminate the requirement, thereby permitting
other uses for this new kind of expression of type <code>bool</code>. (For example,
requires­-expressions might replace many or all of the Boolean type traits.)
Additionally, in any context where a bool value is permitted, allow a
concept’s name plus suitable arguments to denote the truth value of the claim
that "this combination of arguments satisfy this concept." (This syntax is
currently valid in only certain contexts such as requires­expressions.)
</p>

<p>
There is a paper addressing the <i>requires-expression</i> portion of this
discussion.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0266r0.pdf"></a>.
</p>

<p>
Issue <a href="ts-active.html#29">29</a> was created to specifically address the inability to
evaluate concepts outside of SFINAE contexts.
</p>





<hr>
<h3><a name="11"></a>11. Concerns about subsumption and equivalence rules</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> US <b>Opened:</b> 2015-05-18 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.decl">active issues</a> in [temp.constr.decl].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We have a broad concern that it is hard to understand the feature purely
from the specification, especially the subsumption rules, and equivalence
rules to know when two signatures declare the same function or
are ambiguous equally constrained overloads, yet there is a lack of readily
available implementations to test our understanding against. While the feature
set of the TS looks good, we think one more iteration on the specification
would be useful.

Proposed solution: Recast the rules for subsumption as a mini grammar
(distinct from the C++ grammar) as the English text appears to be trying to
describe a grammar, but less formally, which leads to a potential lack of
precision, and more confusion for the reader. We are not highlighting specific
lack of precision at this time, as we have not emerged from confusion in
time to file appropriate comments.
</p>

<p>
EWG believes this is strictly a wording issue. Returned to CWG.
</p>






<hr>
<h3><a name="15"></a>15. Partial specialization of non-concept variable template as a concept definition</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-10-02 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Partial specialization of a concept definition is prohibited by
7.1.7 [dcl.spec.concept]p7; however, there appears to be no
prohibition on a concept definition which is a partial specialization.

e.g.,

<pre>
<code>
template &lt;typename T, typename U&gt; bool C = true;
template &lt;typename U&gt; concept bool C&lt;int, U&gt; = false;
</code>
</pre>
</p>





<hr>
<h3><a name="16"></a>16. Concept and non-concept declarations of the same variable template</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-07-09 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It seems this is valid, and it is not clear if that is the intent.
<pre>
<code>
namespace A {
  template &lt;typename T&gt; extern const bool C;
};
template &lt;typename T&gt; concept bool A::C = true;
</code>
</pre>
</p>

<p>
Note: The C++14 restriction (removed in DR 1712) that the constexpr specifier be
present on every declaration of a variable template if any declaration has the
constexpr specifier applies to the "physical" presence of the specifier.
</p>

<p>
Note: The first declaration of A::C is not a "variable concept". There is no
restriction that a variable concept (i.e., "[a] variable template definition
having the concept specifier") is the only declaration of the entity that it
defines.
</p>

<p>
This seems to be a more general problem that being a "concept" is not a property
of the entity, but of its definition.
</p>

<p>
Andrew Sutton: This should not be a valid definition.
</p>





<hr>
<h3><a name="17"></a>17. Wording for subsumption</h3>
<p><b>Section:</b> 14.10.3 [temp.constr.order] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-25 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.order">active issues</a> in [temp.constr.order].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.order">issues</a> in [temp.constr.order].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording in N4377 subclause 14.10.3 [temp.constr.order] bullet 2.2 reads:
<ul>
<li>a disjunctive clause Pi subsumes a conjunctive clause Qj if and only if each atomic constraint in Pi subsumes any atomic constraint Qj, where</li>
<li>...</li>
</ul>
Firstly, as a conjunctive clause of a constraint in CNF, Qj may be a disjunction
as opposed to an atomic constraint. Adding "in" to give "any atomic constraint
in Qj" might be an editorial fix, but it does not fix the issue below.
</p>

<p>
Given "A and B" as P0, and "A" as Q0; then my reading of the "each subsumes any"
wording is that P0 subsumes Q0 if and only if each atomic constraint in P0 (that
is, A and B) subsumes A. That is: (A subsumes A) <i>and</i> (B subsumes A).
</p>

<p>
I believe the intent is that Pi subsumes Qj if and only if there exists an
atomic constraint, Pia, in Pi for which there exists an atomic constraint, Qjb,
in Qj such that Pia subsumes Qjb. I am not seeing a way to reconcile the current
wording of bullet 2.2 with what I believe the intent is.
</p>

<p>
Also see issue <a href="ts-active.html#30">30</a>. Addressing that issue will also close this one.
</p>






<hr>
<h3><a name="18"></a>18. Predicate constraints that are not constant expressions</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-05-26 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The word "constant" only appears once in normative text in N4377. It is unclear
to me whether a predicate constraint that is not a constant-expression is
ill-formed (which would require a diagnostic for a non-temploid function with a
requires-clause whose expression is not constant), or merely not satisfied.
</p>

<p>
It is useful to note that the "ill-formed" position leads to further issues
where constant-expressions of the form <code>P || Q</code> may be written such that
normalization of constraints will form <i>P or Q</i> where <i>Q</i> is a
predicate constraint whose expression is not a constant-expression.
</p>

<p>
Faisal Vali, Andrew Sutton, and Gabriel Dos Reis agree that
predicate constraints containing non-constant expressions should
be ill-formed.
</p>

<p>
Andrew Sutton suggests: If Q is not dependent and not a constant expression,
then the program would be ill-formed. Otherwise if, as a result of substituting
during satisfaction, Q is not a constant expression the program is
ill-formed.
</p>

<p>
However, if Q is dependent but never evaluated (because P is
satisfied), the program is well-formed. This would be the same if
substitution into Q would result in substitution failures (e.g., if Q
is <code>X&lt;T&gt;::value</code>).
</p>





<hr>
<h3><a name="19"></a>19. Wording makes all constrained function definitions ill-formed</h3>
<p><b>Section:</b> 8.4.1 [dcl.fct.def.general] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-04 <b>Last modified:</b> 2016-06-16</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In N4141 (C++14) subclause [dcl.fct.def.general] paragraph 2:
The declarator in a function-definition shall have the form

<blockquote>
<i>
  D1 ( parameter-declaration-clause ) cv-qualifier-seq<sub>opt</sub>
  ref-qualifier<sub>opt</sub>
  exception-specification<sub>opt</sub>
  attribute-specifier-seq<sub>opt</sub>
  trailing-return-type<sub>opt</sub>
</i>
</blockquote>
as described in 8.3.5. A function shall be defined only in namespace or class scope.
</p>

<p>
The issue also occurs in N4141 subclause 12.1 [class.ctor] paragraph 1 and
subclause 12.4 [class.dtor] paragraph 1.
</p>





<hr>
<h3><a name="21"></a>21. Disambiguation rules for <i>requires-clause</i>s</h3>
<p><b>Section:</b> 8.3.5 [dcl.fct] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-08 <b>Last modified:</b> 2016-06-16</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There is no disambiguation rule in C++14 PDTS 19217 which requires a
<i>type-specifier-seq</i> to consume as many <i>type-specifier</i>s as is
available and avoid backtracking.
</p>

<p>
Given either
<pre>
<code>
template &lt;typename T&gt; requires (bool)&T::operator short
unsigned int foo();
</code>
</pre>
or
<pre>
<code>
template &lt;typename T&gt; requires (bool)sizeof new (T::f()) short
unsigned int bar();
</code>
</pre>

there is more than one successful parse and it is unclear whether the return
type is <code>unsigned int</code> or <code>int</code>.
</p>

<p>
The after-the-function-declarator form of the <i>requires-clause</i> is also
ambiguous:

<pre>
<code>
struct X {};
template&lt;typename T&gt; void f() requires (bool)sizeof new X
{
  // might be the function body, might be a brace-or-equal-init for X
};
</code>
</pre>

A 'max munch' rule would probably do the wrong thing for the above case,
and likewise here:

<pre>
<code>
template&lt;typename T&gt; requires (bool)sizeof new unsigned
struct X { };
</code>
</pre>
</p>

<p>
Proposed resolutions have been to:
<ul>
  <li>require parens</li>,
  <li>specify rules to make this unambiguous</li>
  <li>specify the operand of a <i>requires-clause</i> as a new grammar.</li>
</ul>
No concensus has been reached.
</p>





<hr>
<h3><a name="22"></a>22. Initializers are never <i>constraint-expression</i>s</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-19 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Initializers [dcl.init] are not expressions. However bullet 6.3 in
[dcl.spec.concept] has a requirement where an "initializer shall be a
constraint-expression".
</p>

<p>
Presumably the constraint is that the initializer shall have exactly one full-
expression (that is,
<pre>
<code>
template &lt;typename T&gt; concept bool C{};
</code>
</pre>
is ill-formed), and that said full-expression is valid where a
<i>constraint-expression</i> is required.
</p>

<p>
It also seems that C++14 subclause 8.5 [dcl.init] paragraph 2 should be removed
or updated to exclude objects declared with the concept specifier in a manner
similar to how it excludes objects declared with the constexpr specifier.
</p>





<hr>
<h3><a name="23"></a>23. Associated constraints is a term defined for templates only</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-27 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.decl">active issues</a> in [temp.constr.decl].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The definition of "associated constraints" is in 14.10.2 [temp.constr.decl]
paragraph 2 of N4377. Said definition only applies to templates, thus the
"associated constraints" being referred to by N4377 subclause 1.3.1
[defns.signature] appears to be undefined.
</p>





<hr>
<h3><a name="24"></a>24. Expression equivalence outside of declaration matching is novel</h3>
<p><b>Section:</b> 14.10.3 [temp.constr.order] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-27 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.order">active issues</a> in [temp.constr.order].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.order">issues</a> in [temp.constr.order].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Consider the following case:

<pre>
<code>
template &lt;typename T&gt; constexpr bool P = true;
constexpr bool Q = true;

template &lt;typename T = int&gt; requires P&lt;T&gt;
void foo(int = 0, T = 0);

template &lt;typename U = int&gt; requires P&lt;U&gt; && Q
void foo(U = 0, int = 0);

void bar() { foo(); }
</code>
</pre>

It seems that <code>&lt;T&gt;</code> in the first declaration of
<code>foo()</code> may be considered equivalent to P&lt;U&gt; in
the second declaration of <code>foo()</code>; however, I would find it surprising if the call
to <code>foo()</code> is unambiguous. Note that <code>T</code> and <code>U</code>
are not involved in the partial ordering in this case aside from the determination
of the more constrained template.
</p>






<hr>
<h3><a name="25"></a>25. Block scope template declarations</h3>
<p><b>Section:</b> 14.10.3 [temp.constr.order] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2015-06-03 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.order">active issues</a> in [temp.constr.order].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.order">issues</a> in [temp.constr.order].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The following constraint in Clause 14 [temp] is insufficient to prevent
the declaration of an abbreviated function template at block scope:

<blockquote>
A <i>template-declaration</i> can appear only as a namespace scope or class scope
declaration.
</blockquote>
</p>





<hr>
<h3><a name="27"></a>27. Redundant restriction on function specifiers for concepts</h3>
<p><b>Section:</b> 7.1.7 [dcl.spec.concept] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Nathan Wilson <b>Opened:</b> 2015-10-17 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#dcl.spec.concept">active issues</a> in [dcl.spec.concept].</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.concept">issues</a> in [dcl.spec.concept].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
According to subclause 7.1.7 [dcl.spec.concept] paragraph 5:

<blockquote>
A function concept has the following restrictions: (5.1):
<ul>
  <li>No function-specifiers shall appear in its declaration (7.1.2).</li>
  <li>...</li>
</ul>
</blockquote>

Would that be redundant because of the restriction on function-specifiers being
covered by subsection [dcl.spec.concept]p2 and the result of
[dcl.spec.concept]p1, specifically, "The concept specifier shall be applied
only to the definition of a function or variable template, declared in
namespace scope"?
</p>


<p><b>Wording available:</b></p>
Strike the first bullet in [dcl.spec.concept]p5.
<blockquote>
<ul>
  <li><del>No function-specifiers shall appear in its declaration (7.1.2).</del></li>
  <li>...</li>
</ul>
</blockquote>





<hr>
<h3><a name="28"></a>28. Ordering of constraints involving fold expressions</h3>
<p><b>Section:</b> 14.10.3 [temp.constr.order] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Robert Haberlach <b>Opened:</b> 2016-01-23 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.order">active issues</a> in [temp.constr.order].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.order">issues</a> in [temp.constr.order].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
Partial ordering by constraints doesn't regard fold expressions.

<code>
<pre>
template &lt;class T&gt; concept bool A = std::is_move_constructible&lt;T&gt;::value;
template &lt;class T&gt; concept bool B = std::is_copy_constructible&lt;T&gt;::value;
template &lt;class T&gt; concept bool C = A&lt;T&gt; &amp;&amp; B&lt;T&gt;;

template &lt;class... _tx&gt;
  requires (A&lt;_tx&gt; && ...)
void g(_tx... tx) {
  std::cout &lt;&lt; "a\n";
}

template &lt;class... _tx&gt;
  requires (C&lt;_tx&gt; && ...)
void g(_tx... tx) {
  std::cout &lt;&lt; "c\n";
}
</pre>
</code>

<p>
Andrew Sutton: this is logically valid and seems like a reasonable extension.
As a general rule, there may be many ways in which we can extend the constraint
language to support these kinds of resolutions. Of course, this means that
each such change potentially breaks changes.
</p>

<p>
This needs to apply to expansions of disjunctions also. This is done
by inverting the subsumption (i.e., when Q subsumes P).
</p>


<p><b>Wording available:</b></p>
Augment 14.10.3 [temp.constr.order]p(2.3) thusly:

an atomic constraint A subsumes another atomic constraint B if and only
if either <del>the</del> A and B are equivalent using the rules
described in 14.10.1 to compare constraints<ins>, or A is of the form
<tt>P && ...</tt> and B is of the form <tt>Q && ...</tt> or <tt>Q ||
...</tt>, where P subsumes Q.</ins>.





<hr>
<h3><a name="29"></a>29. Allow concepts to be evaluated in any context</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Andrew Sutton <b>Opened:</b> 2016-02-27 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.decl">active issues</a> in [temp.constr.decl].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Currently, concepts are only guaranteed to be evaluable within the context
of a requires-expression. Among other things, this guarantees that the following
will not work:

<code>
static_assert(C&lt;X&gt;(), ""); // for some concrete X
</code>
</p>

<p>
Evaluating a concept in any context effectively requires that it be evaluated
as if in a SFINAE context. The original design of concepts did not require
this because it was not clear how easy this would be for all implementers.
Based on EWG discussions in Kona, this appears to no longer be the case.
</p>

<p>
This issue is submitted as a result of an EWG straw poll taken during discussion
of issue <a href="ts-active.html#3">3</a>. 
</p>


<p><b>Wording available:</b></p>





<hr>
<h3><a name="30"></a>30. Normalization wording guarantees worst case performance for subsumption</h3>
<p><b>Section:</b> 14.10.2 [temp.constr.decl] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Andrew Sutton <b>Opened:</b> 2016-02-27 <b>Last modified:</b> 2016-06-16</p>
<p><b>View other</b> <a href="ts-index-open.html#temp.constr.decl">active issues</a> in [temp.constr.decl].</p>
<p><b>View all other</b> <a href="ts-index.html#temp.constr.decl">issues</a> in [temp.constr.decl].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current wording for normalization guarantees exponential performance
during subsumption.
</p>

<p>
Addressing this issue first requires that we address issue <a href="ts-active.html#29">29</a>.
If concepts can be safely evaluated in any context, then we do not need to
lift the entire constraint into the current instantiation.
</p>

<p>
The current phrasing also prohibits certain compiler optimizations by requiring
a full expansion to atomic constraints. In particular, this does not admit
early termination of the algorithm or memoization of comparisons.
</p>

<p>
Prior to the Skillman concepts meeting, there was a much more abstract wording
for the subsumption algorithm. One resolution would be to revert the current
wording to the older version.
</p>


<p><b>Wording available:</b></p>





<hr>
<h3><a name="31"></a>31. Constrained-type-specifiers introduce non-type placeholders</h3>
<p><b>Section:</b> 7.1.6.4.2 [dcl.spec.auto.constr] <b>Status:</b> <a href="ts-active.html#Open">Open</a>
 <b>Submitter:</b> Jason Merrill <b>Opened:</b> 2016-03-03 <b>Last modified:</b> 2016-06-19</p>
<p><b>View all other</b> <a href="ts-index.html#dcl.spec.auto.constr">issues</a> in [dcl.spec.auto.constr].</p>
<p><b>View all issues with</b> <a href="ts-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A <i>constrained-type-specifier</i> also denotes non-type constraints. The
production name should reflect that.
</p>





<hr>
<h3><a name="33"></a>33. Undefined behavior of <i>partial-concept-id</i>s in <i>template-introductions</i></h3>
<p><b>Section:</b> 14.2 [temp.intro] <b>Status:</b> <a href="ts-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-04 <b>Last modified:</b> 2016-06-19</p>
<p><b>View all issues with</b> <a href="ts-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There appear to be no semantics applied to the use of a partial-concept-id as
the qualified-concept-name in a template-introduction. In particular, N4552
subclause 14.2 [temp.intro] refers to subclause 14.10.4 [temp.constr.resolve],
which in turn does not specify what the concept argument list is in such a case.
</p> 

<p>
Andrew Sutton: "disallowing this seems reasonable".
</p>


<p><b>Wording available:</b></p>
<p>
</p>





<hr>
<h3><a name="34"></a>34. Premature substitution into associated constraints</h3>
<p><b>Section:</b> 14.6.4 [temp.friend] <b>Status:</b> <a href="ts-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-06 <b>Last modified:</b> 2016-06-19</p>
<p><b>View all issues with</b> <a href="ts-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Given:

<pre>
<code>
template &lt;typename T&gt;
    requires true || T::happy
void foo(T &amp;&amp;) { }

template &lt;typename T&gt;
struct A {
  friend void bar(A &amp;&amp;)
      requires true || T::happy {
  }
};

int main(void) {
  foo(0);
  bar(A&lt;int&gt;());
}
</code>
</pre>

there appears to be wording (normative and otherwise), which would render the
program ill-formed. I assume that is not the intent.
</p>

<p>
The wording involved is as follows: N4553 subclause 14.6.4 [temp.friend]
paragraph 11: In the instantiation of such a class template (14.8), the template
arguments are substituted into the constraints but not evaluated. [ ... ] If
substitution fails, the program is ill-formed.
</p>

<p>
N4553 subclause 14.9.2 [temp.deduct] paragraph 5: If the function template has
associated constraints (14.10.2), the template arguments are substituted into
the associated constraints without evaluating the resulting expression. If this
substitution results in an invalid type or expression, type deduction fails.
</p> 


<p><b>Wording available:</b></p>
<p>
</p>





<hr>
<h3><a name="35"></a>35. Handwaving around instantiation of constraining elements</h3>
<p><b>Section:</b> 14.10.1 [temp.constr.constr] <b>Status:</b> <a href="ts-active.html#New">New</a>
 <b>Submitter:</b> Hubert Tong <b>Opened:</b> 2016-05-06 <b>Last modified:</b> 2016-06-19</p>
<p><b>View all issues with</b> <a href="ts-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>

The TS often refers to substitution or instantiation of associated constraints;
however, associated constraints are a derived property of what might be called
"constraining elements", i.e., constrained-type-specifiers, constrained-
parameters, template-introductions and constraint-expressions.

It appears that the wording in N4553 subclause 14.10.1 [temp.constr.constr]
is attempting to achieve "partial substitution" is trumped in many cases by
substitution into constraining elements.

For example, the associated constraints would evaluate false (or in a more
realistic case, a check that <code>T::type</code> is a type) prior to 
considering <code>C&lt;placeholder, typename T::type&gt;()</code>, but it is unclear 
whether instantiating <code>A&lt;int&gt;</code> causes an error from the use of 
<code>T::type</code>:

<pre>
<code>
template &lt;typename T, typename U&gt;
concept bool C() { return true; }

template &lt;typename T&gt;
struct A {
  template &lt;typename U&gt; requires false
  void foo(C&lt;typename T::type&gt;) { }
};

int main(void) { A&lt;int&gt; a; }
</code>
</pre>

</p> 


<p><b>Wording available:</b></p>
<p>
</p>





</body>
</html>
