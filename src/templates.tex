
%%
%% Templates
%%
\setcounter{chapter}{13}
\rSec0[temp]{Templates}

Modify the \grammarterm{template-declaration} grammar in paragraph 1 to 
allow a template declaration introduced by a concept.

\begin{quote}
\pnum

\begin{bnf}
\nontermdef{template-declaration}\br
  \terminal{template} \terminal{<} template-parameter-list \terminal{>}
    \added{requires-clause\opt} declaration\br
  \added{template-introduction declaration}

\begin{addedblock}
\nontermdef{requires-clause}\br
  \terminal{requires} constraint-expression
\end{addedblock}
\end{bnf}

\end{quote}
  
Add the following paragraphs after paragraph 6.

\begin{quote}
\setcounter{Paras}{6}
\pnum
A \grammarterm{template-declaration} is written in terms of its template 
parameters. These parameters are declared explicitly in a 
\grammarterm{template-parameter-list} (\ref{temp.param}), or they are
introduced by a \grammarterm{template-introduction} (\ref{temp.intro}).
%
The optional \grammarterm{requires-clause} following a
\grammarterm{template-parameter-list} allows the specification of
constraints (\ref{temp.constr.decl}) on template arguments (\ref{temp.arg}).
\end{quote}


%%
%% Template parameters
%%
\rSec1[temp.param]{Template parameters}

In paragraph 1, extend the grammar for template parameters to 
constrained template parameters.

\begin{quote}
\pnum

\begin{bnf}
\nontermdef{template-parameter}\br
  \added{constrained-parameter}

\begin{addedblock}
\nontermdef{constrained-parameter}\br
  qualified-concept-name ...\opt identifier\opt default-template-argument\opt

\nontermdef{default-template-argument}\br
  \terminal{=} type-id\br
  \terminal{=} id-expression\br
  \terminal{=} initializer-clause
\end{addedblock}
\end{bnf}
\end{quote}

Insert a new paragraph after paragraph 1.

\begin{quote}
\pnum
There is an ambiguity in the syntax of a template parameter between the
declaration of a \grammarterm{constrained-parameter} and a
\grammarterm{parameter-declaration}.
% 
If the \grammarterm{type-specifier-seq} of a \grammarterm{parameter-declaration} 
is a \grammarterm{constrained-type-specifier} (\ref{dcl.spec.auto.constr}), 
then the \grammarterm{template-parameter} is a \grammarterm{constrained-parameter}.
\end{quote}

Insert the following paragraphs after paragraph 8. These paragraphs
define the meaning of a constrained template parameter.

\begin{quote}
\setcounter{Paras}{8}
\pnum
A \grammarterm{constrained-parameter} declares a template parameter whose 
kind (type, non-type, template) and type match that of the prototype parameter 
of the concept designated by the \grammarterm{qualified-concept-name} 
(\ref{dcl.spec.auto.constr}) in the \grammarterm{constrained-parameter}.
% 
The designated concept is selected by the rules for concept resolution 
described in \ref{temp.constr.resolve}.
% 
Let \tcode{X} be the prototype parameter of the designated concept.
% 
The declared template parameter is determined by the kind of \tcode{X} 
(type, non-type, template) and the optional ellipsis in the
\grammarterm{constrained-parameter} as follows.
% 
\begin{itemize}
\item If \tcode{X} is a type \grammarterm{template-parameter}, the declared
parameter is a type \grammarterm{template-parameter}. 

\item If \tcode{X} is a non-type \grammarterm{template-parameter}, the declared
parameter is a non-type \grammarterm{template-parameter} having the same 
type as \tcode{X}.

\item If \tcode{X} is a template \grammarterm{template-parameter}, the declared
parameter is a template \grammarterm{template-parameter} having the same 
\grammarterm{template-parameter-list} as \tcode{X}, excluding default template 
arguments.

\item If the \grammarterm{qualified-concept-name} is followed by an ellipsis,
then the declared parameter is a template parameter pack (\ref{temp.variadic}).
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;
template<int N> concept bool C3 = true;
template<typename... Ts> concept bool C4 = true;
template<char... Cs> concept bool C5 = true;

template<C1 T> void f1();     // OK: \tcode{T} is a type template-parameter
template<C2 X> void f2();     // OK: \tcode{X} is a template with one type-parameter
template<C3 N> void f3();     // OK: \tcode{N} has type int
template<C4... Ts> void f4(); // OK: \tcode{Ts} is a template parameter pack of types
template<C4 T> void f5();     // OK: \tcode{T} is a type template-parameter
template<C5... Cs> f6();      // OK: \tcode{Cs} is a template parameter pack of \tcode{char}{}s
\end{codeblock}
\exitexample

\pnum
A \grammarterm{constrained-parameter} associates a predicate
constraint (\ref{temp.constr.pred}) with its \grammarterm{template-declaration}. 
% 
The constraint is derived from the \grammarterm{qualified-concept-name} 
\tcode{Q} in the \grammarterm{constrained-parameter}, its designated concept 
\tcode{C}, and the declared template parameter \tcode{P}.
% 
\begin{itemize}
\item First, form a template argument \tcode{A} from \tcode{P}. If \tcode{P} 
declares a template parameter pack (\ref{temp.variadic})
and \tcode{C} is a variadic concept (\ref{dcl.spec.concept}), then \tcode{A} is 
the pack expansion \tcode{P...}. Otherwise, \tcode{A} is the 
\grammarterm{id-expression} \tcode{P}.

\item Then, form a \grammarterm{template-id} \tcode{TT} based on the 
\grammarterm{qualified-concept-name} \tcode{Q}. If \tcode{Q} is 
a \grammarterm{concept-name}, then \tcode{TT} is \tcode{C<A>}. Otherwise, 
\tcode{Q} is a \grammarterm{partial-concept-id} of the form
\tcode{C<A1, A2, ..., A$N$>}, and \tcode{TT} is \tcode{C<A, A1, A2, ..., A$N$}>.

\item Then, form an \grammarterm{expression} \tcode{E} as follows. 
If \tcode{C} is variable concept (\ref{dcl.spec.concept}), then \tcode{E} is the 
\grammarterm{id-expression} \tcode{TT}. Otherwise, \tcode{C} is a function 
concept and \tcode{E} is the function call \tcode{TT()}.

\item Finally, If \tcode{P} declares a template parameter pack and 
\tcode{C} is not a variadic concept, \tcode{E} is adjusted to be the
\grammarterm{fold-expression} \tcode{E \&\& ...} (\ref{expr.prim.fold}).
\end{itemize}
% 
\tcode{E} is the expression of the associated predicate constraint.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename... Ts> concept bool C2() { return true; }
template<typename T, typename U> concept bool C3 = true;

template<C1 T> struct s1;      // associates \tcode{C1<T>}
template<C1... T> struct s2;   // associates \tcode{C1<T>...}
template<C2... T> struct s3;   // associates \tcode{C2<T...>()}
template<C3<int> T> struct s4; // associates \tcode{C3<T, int>}
\end{codeblock}
\exitexample

\end{quote}

Insert the following paragraph after paragraph 9 to require that the
kind of a \grammarterm{default-argument} matches the kind of its
\grammarterm{constrained-parameter}.

\begin{quote}
\setcounter{Paras}{11}
\pnum
The default \grammarterm{template-argument} of
a \grammarterm{constrained-parameter} shall match
the kind (type, non-type, template) of the declared template parameter.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<int N> concept bool C2 = true;
template<template<typename> class X> concept bool C3 = true;

template<typename T> struct S0;

template<C1 T = int> struct S1; // OK
template<C2 N = 0> struct S2;   // OK
template<C3 X = S0> struct S3;  // OK
template<C1 T = 0> struct S4;   // error: default argument is not a type
\end{codeblock}
\exitexample
\end{quote}


%%
%% Introduction of template parameters
%%
\rSec1[temp.intro]{Introduction of template parameters}

Add this section after \ref{temp.param}.

\begin{quote}

\pnum
A \grammarterm{template-introduction} provides a concise way of declaring
templates.

\begin{bnf}
\nontermdef{template-introduction}\br
   qualified-concept-name \terminal{\{} introduction-list \terminal{\}}

\nontermdef{introduction-list}\br
  introduced-parameter\br
  introduction-list \terminal{,} introduced-parameter

\nontermdef{introduced-parameter}\br
    \terminal{...}\opt identifier
\end{bnf}

A \grammarterm{template-introduction} declares a template whose
sequence of \grammarterm{template-parameter}{s} are derived from a
\grammarterm{qualified-concept-name} (\ref{dcl.spec.auto.constr}) and the 
sequence of \grammarterm{introduced-parameter}{s} in its 
\grammarterm{introduction-list}.

\pnum
The concept designated by the \grammarterm{qualified-concept-name} is selected 
by the concept resolution rules described in \ref{temp.constr.resolve}. Let
\tcode{C} be the designated concept.
% 
The template parameters declared by a \grammarterm{template-introduction}
are derived from its \grammarterm{introduced-parameter}{s} and the
template parameter declarations of \tcode{C} to which those
\grammarterm{introduced-parameter}{s} are matched as wildcards according to 
the rules in \ref{temp.constr.resolve}.
% 
For each \grammarterm{introduced-parameter} \tcode{I}, declare a template
parameter using the following rules:
\begin{itemize}
\item Let \tcode{P} be the template parameter declaration in \tcode{C} 
      corresponding to \tcode{I}. If \tcode{P} does not declare a template 
      parameter pack (\ref{temp.variadic}), \tcode{I} shall not include 
      an ellipsis.

\item If \tcode{P} declares a template parameter pack, adjust \tcode{P} 
      to be the pattern of that pack.

\item Declare a template parameter according to the rules for declaring a
      \grammarterm{constrained-parameter} in \ref{temp.param}, using
      \tcode{P} as the prototype parameter and with no ellipsis.

\item If \tcode{I} includes an ellipsis, then the declared template parameter 
      is a template parameter pack.
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T, int N, typename... Xs> concept bool C1 = true;
template<template<typename> class X> concept bool C2 = true;
template<typename... Ts> concept bool C3 = true;

C1{A, B, ...C} // OK: \tcode{A} is declared as \tcode{typename A},
  struct S1;   // \tcode{B} is declared as \tcode{int B}, and
               // \tcode{C} is declared as \tcode{typename ... C}

C2{T} void f();    // OK: \tcode{T} is declared as \tcode{template<typename> class T}
C2{...Ts} void g(); // error: the template parameter corresponding to \tcode{Ts}
                    // is not a template parameter pack

C3{T} struct S2;     // OK: \tcode{T} is declared as \tcode{typename T}
C3{...Ts} struct S2; // OK: \tcode{Ts} is declared as \tcode{typename ... Ts}
\end{codeblock}
\exitexample


\pnum
A concept referred to by a \grammarterm{qualified-concept-name} may have 
template parameters with default template arguments. An 
\grammarterm{introduction-list} may omit \grammarterm{identifier}{}s for a 
corresponding template parameter if it has a default argument.
% 
Only the \grammarterm{introduced-parameter}{}s are declared as template 
parameters.
% 
\enterexample
\begin{codeblock}
template<typename A, typename B = bool> concept bool C() { return true; }

C{T} void f(T); // OK: \tcode{f(T)} is a function template with
                // a single template type parameter \tcode{T}
\end{codeblock}
\exitexample

\pnum
An introduced template parameter does not have a default template argument 
even if its corresponding template parameter does.
% 
\enterexample
\begin{codeblock}
template<typename T, int N = -1> concept bool P() { return true; }

P{T, N} struct Array { };

Array<double, 0> s1; // OK
Array<double> s2;    // error: \tcode{Array} takes two template arguments
\end{codeblock}
\exitexample

\pnum
A \grammarterm{template-introduction} associates a predicate constraint with 
its \grammarterm{template-declaration}. This constraint is derived from
the \grammarterm{qualified-concept-name} \tcode{C} in the 
\grammarterm{template-introduction} and the sequence of 
\grammarterm{introduced-parameter}{s}.

\begin{itemize}
\item First, form a sequence of template arguments \tcode{A1, A2, ..., A$N$} 
corresponding to the \grammarterm{introduced-parameter}{s}
\tcode{P1, P2, ..., P$N$}.
% 
For each \grammarterm{introduced-parameter} \tcode{P}, form a corresponding 
template argument \tcode{A} as follows. If \tcode{P} includes an ellipsis,
then \tcode{A} is the pack expansion \tcode{P...} (\ref{temp.variadic}). 
Otherwise, \tcode{A} is the \grammarterm{id-expression} \tcode{P}.

\item Then, form an expression \tcode{E} as follows. If \tcode{C} designates
a variable concept (\ref{dcl.spec.concept}), then \tcode{E} is the
\grammarterm{id-expression}
\tcode{C<A1, ..., A$N$>}. Otherwise, \tcode{C} designates a function concept and
\tcode{E} is the function call \tcode{C<A1, ..., A$N$>()}.
\end{itemize}
% 
\tcode{E} is the expression of the associated predicate constraint.
% 
\enterexample
\begin{codeblock}
template<typename T, typename U> concept bool C1 = true;
template<typename T, typename U> concept bool C2() { return true; }
template<typename... Ts> concept bool C3 = true;

C1{A, B} struct s1;    // associates \tcode{C1<A, B>}
C2{A, B} struct s2;    // associates \tcode{C2<A, B>()}
C3{...Ts} struct s3;   // associates \tcode{C3<Ts...>}
C3{X, ...Y} struct s4; // associates \tcode{C3<X, Y...>}
\end{codeblock}
\exitexample

\pnum
A template declared by a \grammarterm{template-introduction} can also be 
an abbreviated function template (\ref{dcl.fct}). 
% 
The invented template parameters introduced by the placeholders in the 
abbreviated function template are appended to the list of template parameters 
declared by the \grammarterm{template-introduction}.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;

C1{T} void f(T, auto);
template<C1 T, typename U> void f(T, U); // OK: redeclaration of \tcode{f(T, auto)}
\end{codeblock}
% 
\exitexample
\end{quote}


%%
%% Names of template specializations
%%
\rSec1[temp.names]{Names of template specializations}

Add this paragraph at the end of the section to require the satisfaction of 
associated constraints on the formation of the \grammarterm{simple-template-id}.

\begin{quote}
\setcounter{Paras}{7}
\pnum
When the \grammarterm{template-name} of a \grammarterm{simple-template-id} names
a constrained non-function template or a constrained template 
\grammarterm{template-parameter}, but not a member template that is a member 
of an unknown specialization (\ref{temp.res}), and all 
\grammarterm{template-argument}{s} in the \grammarterm{simple-template-id} 
are non-dependent \cxxref{temp.dep.temp}, the associated constraints of the 
constrained template shall be satisfied. (\ref{temp.constr}).
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = false;

template<C1 T> struct S1 { };
template<C1 T> using Ptr = T*;

S1<int>* p; // error: constraints not satisfied
Ptr<int> p; // error: constraints not satisfied

template<typename T>
  struct S2 { Ptr<int> x; }; // error: constraints not satisfied

template<typename T>
  struct S3 { Ptr<T> x; };   // OK: satisfaction is not required

S3<int> x;                   // error: constraints not satisfied

template<template<C1 T> class X>
  struct S4 {
    X<int> x; // error: constraints not satisfied (\#1)
  };

template<typename T>
  struct S5 {
    using Type = typename T::template MT<char>; // \#2
  };

template<typename T> concept bool C2 = sizeof(T) == 1;

template<C2 T> struct S { };

template struct S<char[2]>;       // error: constraints not satisfied
template<> struct S<char[2]> { }; // error: constraints not satisfied
\end{codeblock}
In \#1, the error is caused by the substitution of \tcode{int} into 
the associated constraints of the template parameter \tcode{X}.
% 
In \#2, no constraints can be checked for \tcode{typename T::template MT<char>} 
because \tcode{MT} is a member of an unknown specialization.
\exitexample
\end{quote}

%%
%% Template arguments
%%
\rSec1[temp.arg]{Template arguments}

%%
%% Template template arguments
%%
\rSec2[temp.arg.template]{Template template arguments}

Modify paragraph 3 to include rules for matching constrained template 
\grammarterm{template-parameter}{s}. Note that the examples following this 
paragraph in the \Cpp Standard are omitted.

\begin{quote}
\setcounter{Paras}{2}
\pnum
A \grammarterm{template-argument} matches  a template 
\grammarterm{template-parameter}  (call it \tcode{P}) when each of the 
template parameters in the \grammarterm{template-parameter-list} of the 
\grammarterm{template-argument}'s corresponding class template or alias 
template (call it  \tcode{A}) matches the corresponding template parameter in 
the \grammarterm{template-parameter-list} of \tcode{P}\added{, and \tcode{P} is 
at least as constrained as \tcode{A} according to the rules in 
\ref{temp.constr.order}}.
% 
Two template parameters match if they are of the same kind (type, non-type, 
template), for non-type \grammarterm{template-parameter}{}s, their types are 
equivalent (\ref{temp.over.link}), and for template 
\grammarterm{template-parameter}{}s, each of their corresponding
\grammarterm{template-parameter}{}s matches, recursively. 
% 
When \tcode{P}'s \grammarterm{template-parameter-list} 
contains a template parameter pack (\ref{temp.variadic}), the template 
parameter pack will match zero or more template parameters or template 
parameter packs in the \grammarterm{template-parameter-list} of
\tcode{A} with the same kind (type, non-type, template) and type as the template 
parameter pack in \tcode{P} (ignoring whether those template parameters are
template parameter packs).
\end{quote}

Add the following example to the end of paragraph 3, after the
examples given in the \Cpp Standard.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.g(); };

template<template<C> class P>
  struct S { };

template<C> struct X { };
template<D> struct Y { };
template<typename T> struct Z { };

S<X> s1; // OK: \tcode{X} and \tcode{P} have equivalent constraints
S<Y> s2; // error: \tcode{P} is not at least as constrained \tcode{Y} (\tcode{Y} is more constrained than \tcode{P})
S<Z> s3; // OK: \tcode{P} is at least as constrained as \tcode{Z}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Template declarations
%%
\setcounter{section}{5}
\rSec1[temp.decls]{Template declarations}

Modify paragraph 2 to indicate that associated constraints are
instantiated separately from the template they are associated with.

\begin{quote}
\setcounter{Paras}{1}
For purposes of name lookup and instantiation, default 
arguments\added{, associated constraints (\ref{temp.constr.decl}),} and
\grammarterm{exception-specification}{}s of function templates and default
arguments\added{, associated constraints,} and 
\grammarterm{exception-specification}{}s of member functions of class
templates are considered definitions; each default 
argument\added{, associated constraint,} or 
\grammarterm{exception-specification} is a separate definition which is 
unrelated to the function template definition or to any other default 
arguments\added{, associated constraints,} or 
\grammarterm{exception-specification}{}s.
\end{quote}


%%
%% Class templates
%%
\rSec2[temp.class]{Class templates}

Modify paragraph 3 to require template constraints for out-of-class
definitions of members of constrained templates. 

\begin{quote}
\setcounter{Paras}{2}
\pnum
When a member function, a member class, a member enumeration, a static 
data member or a member template of a class template is defined outside 
of the class template definition, the member definition is defined as a 
template definition in which the \grammarterm{template-parameter}{s}
\added{and associated constraints} (\ref{temp.constr.decl}) are those of 
the class template.
% 
The names of the template parameters used in the definition of the 
member may be different from the template parameter names used in the 
class template definition. The template argument list following the class
template name in the member definition shall name the parameters in the 
same order as the one used in the template parameter list of the member. 
% 
Each template parameter pack shall be expanded with an ellipsis in the 
template argument list.
\end{quote}

Add the following example at the end of paragraph 3.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = true;
template<typename T> concept bool D = true;

template<C T> struct S {
    void f();
    void g();
    template<D U> struct Inner;
  }

template<typename T> requires C<T> void S<T>::f() { } // OK: parameters and constraints match
template<typename T> void S<T>::g() { } // error: no matching declaration for \tcode{S<T>}

template<C T> D{U} struct S<T>::Inner { }; // OK
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Member functions of class templates
%%
\rSec3[temp.mem.func]{Member functions of class templates}

Add the following example to the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> struct S {
  void f() requires true;
  void g() requires true;
};

template<typename T> 
  void S<T>::f() requires true { } // OK
template<typename T> 
  void S<T>::g() { }               // error: no matching function in \tcode{S<T>}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Member templates
%%
\rSec2[temp.mem]{Member templates}


Modify paragraph 1 in order to account for constrained member templates
of (possibly) constrained class templates. 

\begin{quote}
\pnum
A template can be declared within a class or class template; such a 
template is called a member template. 
% 
A member template can be defined within or outside its class definition 
or class template definition. 
% 
A member template of a class template that is defined outside of its 
class template definition shall be specified with the 
\grammarterm{template-parameter}{s} \added{and associated constraints}
(\ref{temp.constr.decl}) of the class template followed by the 
\grammarterm{template-parameter}{s}
\added{and associated constraints} of the member template.
\end{quote}


Add the following example at the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = sizeof(T) <= 4;

template<C1 T>
  struct S {
    template<C2 U> void f(U);
    template<C2 U> void g(U);
  };

template<C1 T> template<typename U> 
  void S<T>::f(U) requires C2<U> { } // OK
template<C1 T> template<typename U> 
  void S<T>::g(U) { }                // error: no matching function in \tcode{S<T>}
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Variadic templates
%%
\rSec2[temp.variadic]{Variadic templates}

Add \grammarterm{fold-expression}{s} to the list of contexts in which
pack expansion can occur. 

\begin{quote}
\begin{itemize}
\item ...

\item \added{In a \grammarterm{fold-expression} (\ref{expr.prim.fold});
the pattern is the \grammarterm{cast-expression}
that contains an unexpanded parameter pack.}
\end{itemize}
\end{quote}

Modify paragraph 7 to exclude \grammarterm{fold-expression}{s} from
producing a comma-separated list of elements.

\begin{quote}
The instantiation of a pack expansion
\removed{that is not a \tcode{sizeof...} expression}
\added{that is neither a \tcode{sizeof...} expression nor a \grammarterm{fold-expression}}
produces a list
$\mathtt{E}_1, \mathtt{E}_2, ..., \mathtt{E}_N$,
where $N$ is the number of 
elements in the pack expansion parameters. 
% 
Each \tcode{E$_i$} is generated by instantiating 
the pattern and replacing each pack expansion 
parameter with its $i$th element.
\end{quote}


Add the following paragraphs at the end of this section.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{8}
\pnum
The instantiation of a \grammarterm{fold-expression} produces:

\begin{itemize}
\item
\tcode{((}$\mathtt{E}_1$
           \placeholder{op} $\mathtt{E}_2$\tcode{)}
           \placeholder{op} $\cdots$\tcode{)}
           \placeholder{op} $\mathtt{E}_N$
for a unary left fold,
\item
         $\mathtt{E}_1$     \placeholder{op}
\tcode{(}$\cdots$           \placeholder{op}
\tcode{(}$\mathtt{E}_{N-1}$ \placeholder{op}
         $\mathtt{E}_N$\tcode{))}
for a unary right fold,
\item
\tcode{(((}$\mathtt{E}$
            \placeholder{op} $\mathtt{E}_1$\tcode{)}
            \placeholder{op} $\mathtt{E}_2$\tcode{)}
            \placeholder{op} $\cdots$\tcode{)}
            \placeholder{op} $\mathtt{E}_N$
for a binary left fold, and
\item
         $\mathtt{E}_1$     \placeholder{op}
\tcode{(}$\cdots$           \placeholder{op}
\tcode{(}$\mathtt{E}_{N-1}$ \placeholder{op}
\tcode{(}$\mathtt{E}_{N}$   \placeholder{op}
         $\mathtt{E}$\tcode{)))}
for a binary right fold.
\end{itemize}

In each case,
\placeholder{op} is the \grammarterm{fold-operator},
$N$ is the number of elements in the pack expansion parameters,
and each $\mathtt{E}_i$ is generated by instantiating the pattern
and replacing each pack expansion parameter with its $i$th element.
For a binary fold-expression,
$\mathtt{E}$ is generated
by instantiating the \grammarterm{cast-expression}
that did not contain an unexpanded parameter pack.
\enterexample
\begin{codeblock}
template<typename ...Args>
  bool all(Args ...args) { return (... && args); }

bool b = all(true, true, true, false);
\end{codeblock}
Within the instantiation of \tcode{all},
the returned expression expands to
\tcode{((true \&\& true) \&\& true) \&\& false},
which evalutes to \tcode{false}.
\exitexample
If $N$ is zero for a unary fold-expression,
the value of the expression is shown in Table~\ref{tab:fold.empty};
if the operator is not listed in Table~\ref{tab:fold.empty},
the instantiation is ill-formed.

\begin{floattable}{Value of folding empty sequences}{tab:fold.empty}
{ll}
\topline
\lhdr{Operator} & \rhdr{Value when parameter pack is empty} \\
\capsep
\tcode{*}       & \tcode{1}      \\
\tcode{+}       & \tcode{int()}  \\
\tcode{\&}      & \tcode{-1}     \\
\tcode{|}       & \tcode{int()}  \\
\tcode{\&\&}    & \tcode{true}   \\
\tcode{||}      & \tcode{false}  \\
\tcode{,}       & \tcode{void()} \\
\end{floattable}
\end{addedblock}
\end{quote}


%%
%% Friends
%%
\rSec2[temp.friend]{Friends}

Modify paragraph 9 to restrict constrained friend declarations.

\begin{quote}
\setcounter{Paras}{8}
\pnum
When a friend declaration refers to a specialization of a function
template, the function parameter declarations shall not include
default arguments, \added{the declaration shall not have associated constraints
(\ref{temp.constr.decl}),} nor shall the inline specifier be used in such a
declaration.
\end{quote}

Add examples following that paragraph.

\begin{quote}
\begin{addedblock}
\pnum
\enternote
Other friend declarations can be constrained. In a constrained friend 
declaration that is not a definition, the constraints are used for declaration.
\exitnote
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T> concept bool C2 = false;

template<C1 T> g0(T);
template<C1 T> g1(T);
template<C2 T> g2(T);

template<typename T>
  struct S {
    friend void f1() requires true;      // OK
    friend void f2() requires C1<T>;     // OK
    friend void g0<T>(T) requires C1<T>; // error: constrained friend specialization
    friend void g1<T>(T);                // OK
    friend void g2<T>(T);                // error: constraint can never be satisfied, 
                                         // no diagnostic required
  };

void f1() requires true;    // friend of all S<T>
void f2() requires C1<int>; // friend of only S<int>
\end{codeblock}
The friend declaration of \tcode{g2} is ill-formed, no
diagnostic required, because no valid specialization of \tcode{S}
can be generated: the constraint on \tcode{g2} can never
be satisfied, so template argument deduction
(\ref{temp.deduct.decl}) will always fail.
\exitexample

\pnum
\enternote
Within a class template, a friend may define a non-template function
whose constraints specify requirements on template arguments.
\enterexample
\begin{codeblock}
template<typename T> concept bool Eq = requires (T t) { t == t; };

template<typename T>
  struct S {
    friend bool operator==(S a, S b) requires Eq<T> { return a == b; } // OK
  };
\end{codeblock}
\exitexample
In the instantiation of such a class template (\ref{temp.spec}), the 
template arguments are substituted into the constraints but not evaluated.
Constraints are checked (\ref{temp.constr}) only when
that function is considered as a viable candidate for overload resolution
(\ref{over.match.viable}). If substitution fails, the program is ill-formed.
\exitnote
\end{addedblock}
\end{quote}


%%
%% Class template partial specializations
%%
\rSec2[temp.class.spec]{Class template partial specialization}

After paragraph 3, insert the following, which explains constrained partial 
specializations.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{3}
\pnum
A class template partial specialization may be constrained
(Clause~\ref{temp}).
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<int I> concept bool N = I > 0;

template<C T1, C T2, N I> class A<T1, T2, I>;  // \#6
template<C T, N I>        class A<int, T*, I>; // \#7
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}

Remove the 3rd item in the list of paragraph 8 to allow constrained class 
template partial specializations like \#6, and because it is redundant with 
the 4th item. Note that all other items in that list are elided.

\begin{quote}
\setcounter{Paras}{7}
\pnum
Within the argument list of a class template partial specialization, 
the following restrictions apply:
\begin{itemize}
\item ...

\item \removed{The argument list of the specialization shall
not be identical to the implicit argument list of the
primary template.}

\item The specialization shall be more specialized than the primary
template (\ref{temp.class.order}).

\item ...
\end{itemize}
\end{quote}
 
%%
%% Matching of class template partial specializations
%%
\rSec3[temp.class.spec.match]{Matching of class template partial specializations}

Modify paragraph 2; constraints must be satisfied in order
to match a partial specialization. 

\begin{quote}
\setcounter{Paras}{1}
\pnum
A partial specialization matches a given actual template argument list if 
the template arguments of the partial specialization can be deduced from the 
actual template argument list (\ref{temp.deduct}) \added{, and the deduced 
template arguments satisfy the constraints of the partial specialization, if 
any (\ref{temp.constr})}.
\end{quote}

Add the following example to the end of paragraph 2.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
struct S { void f(); };

A<S, S, 1>    a6; // uses \#6
A<int, S*, 3> a8; // uses \#7
\end{codeblock}
\exitexample
\end{addedblock}
\end{quote}


%%
%% Partial ordering of class template specializations
%%
\rSec3[temp.class.order]{Partial ordering of class template specializations}

Modify paragraph 1 so that constraints are considered in the
partial ordering of class template specializations. 

\begin{quote}
\pnum
For two class template partial specializations, the first is 
at least as specialized as the second if, given the following 
rewrite to two function templates, the first function template 
is at least as specialized as the second according to the ordering 
rules for function templates 
(\ref{temp.func.order}):
% 
\begin{itemize}
\item the first function template has the same template 
parameters \added{and associated constraints (\ref{temp.constr.decl})} 
as the first partial specialization, and has a single function parameter 
whose type is a class template specialization with the template
arguments of the first partial specialization, and

\item the second function template has the same template 
parameters \added{and associated constraints (\ref{temp.constr.decl})} 
as the second partial specialization, and has a single function parameter 
whose type is a class template specialization with the template
arguments of the second partial specialization.
\end{itemize}
\end{quote}

Add the following example to the end of paragraph 1.

\begin{quote}
\begin{addedblock}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { t.f(); };
template<typename T> concept bool D = C<T> && requires (T t) { t.f(); };


template<typename T> class S { };
template<C T> class S<T> { }; // \#1
template<D T> class S<T> { }; // \#2

template<C T> void f(S<T>); // A
template<D T> void f(S<T>); // B
\end{codeblock}
The partial specialization \#2 is more specialized than 
\#1 because \tcode{B} is more specialized than \tcode{A}.
\exitexample
\end{addedblock}
\end{quote}


%%
%% Function templates
%%
\rSec2[temp.fct]{Function templates}

%%
%% Function template overloading
%%
\rSec3[temp.over.link]{Function template overloading}

Modify paragraph 6 to account for constraints on function templates.

\begin{quote}
\setcounter{Paras}{5}
\pnum

\removed{ Two function templates are \defn{equivalent} if they are 
declared in the same scope, have the same name, have identical template 
parameter lists, and have return types and parameter lists that are 
equivalent using the rules described above to compare expressions 
involving template parameters.}
% 
\begin{addedblock}
Two function templates are \defn{equivalent} if they:
\begin{itemize}
\item are declared in the same scope,

\item have the same name,

\item have identical template parameter lists,

\item have return types and parameter lists that are equivalent using the 
rules described above to compare expressions involving template parameters, and

\item have associated constraints that are equivalent using the rules 
described in \ref{temp.constr.decl} to compare constraints.
\end{itemize}
\end{addedblock}
% 
Two function templates are \defn{functionally equivalent} if they 
are equivalent except that \removed{one or more expressions that involve 
template parameters in the return types and parameter lists are functionally 
equivalent using the rules described above to compare expressions involving 
template parameters.}
\begin{addedblock}
\begin{itemize}
\item one or more expressions that involve template parameters in the return 
      types and parameter lists are functionally equivalent using the rules 
      described above to compare expressions involving template parameters, or
\item the associated constraints are functionally equivalent using the rules 
      described in \ref{temp.constr.decl} to compare constraints.
\end{itemize}
\end{addedblock}
% 
If a program contains declarations of function templates that are 
functionally equivalent but not equivalent, the program is ill-formed; 
no diagnostic is required.
\end{quote}


%%
%% Partial ordering of function templates
%%
\rSec3[temp.func.order]{Partial ordering of function templates}

Modify paragraph 2 to include constraints in the partial ordering
of function templates.

\begin{quote}
\setcounter{Paras}{1}
\pnum
Partial ordering selects which of two function templates is 
more specialized than the other by transforming each template 
in turn (see next paragraph) and performing template argument 
deduction using the function type. The deduction process 
determines whether one of the templates is more specialized 
than the other.
% 
If so, the more specialized template is the one chosen by the 
partial ordering process. 
% 
\added{If both deductions succeed, the partial ordering selects
the more constrained template as described by the rules in
\ref{temp.constr.order}.}
\end{quote}

%%
%% Name resolution
%%
\rSec1[temp.res]{Name resolution}

Modify paragraph 8.

\begin{quote}
\setcounter{Paras}{7}
\pnum
Knowing which names are type names allows the syntax of every
template to be checked. No diagnostic shall be issued for a template
for which a valid specialization can be generated. If no valid
specialization can be generated for a template, and that template is
not instantiated, the template is ill-formed, no diagnostic
required. If every valid specialization of a variadic template
requires an empty template parameter pack, the template is
ill-formed, no diagnostic required. 
% 
% TODO: "would result in a valid expression" should probably be
% "would always result in substitution failure".
% 
\added{If no instantiation of
the associated constraints (\ref{temp.constr.decl}) of a template would result 
in a valid expression, the template is ill-formed, no diagnostic required.}
% 
If a hypothetical instantiation of a template immediately following
its definition would be ill-formed due to a construct that does not
depend on a template parameter, the program is ill-formed; no
diagnostic is required. If the interpretation of such a construct in
the hypothetical instantiation is different from the interpretation
of the corresponding construct in any actual instantiation of the
template, the program is ill-formed; no diagnostic is required.
\end{quote}

%%
%% Dependent names
%%
\setcounter{subsection}{1}
\rSec2[temp.dep]{Dependent names}

%%
%% Type-dependent expressions
%%
\setcounter{subsubsection}{1}
\rSec3[temp.dep.expr]{Type-dependent expressions}

Add the following paragraph to this section.

\begin{quote}
\setcounter{Paras}{6}
\pnum
\added{A \grammarterm{fold-expression} is type-dependent.}
\end{quote}

%%
%% Value-dependent expressions
%%
\rSec3[temp.dep.constexpr]{Value-dependent expressions}

Modify paragraph 4 to include \grammarterm{fold-expression}{s} in
the set of value-dependent expressions.

\begin{quote}
\setcounter{Paras}{3}
\pnum
Expressions of the following form are value-dependent:

\begin{ncbnftab}
\terminal{sizeof} \terminal{...} \terminal{(} identifier \terminal{)}\br
\added{fold-expression}
\end{ncbnftab}
\end{quote}


%%
%% Dependent name resolution
%% 
\setcounter{subsection}{3}
\rSec2[temp.dep.res]{Dependent name resolution}

%%
%% Point of instantiation
%%
\rSec3[temp.point]{Point of instantiation}

Add a new paragraph after paragraph 4.

\begin{quote}
\setcounter{Paras}{4}
\begin{addedblock}
\pnum
The point of instantiation of a \grammarterm{constraint-expression} of a
specialization immediately precedes the point of instantiation of
the specialization.
\end{addedblock}
\end{quote}


%%
%% Template instantiation and specialization
%%
\rSec1[temp.spec]{Template instantiation and specialization}

%%
%% Implicit instantiation
\rSec2[temp.inst]{Implicit Instantiation}
    
Change paragraph 1 to include associated constraints.

\begin{quote}
Unless a class template specialization has been explicitly
instantiated \ref{temp.explicit} or explicitly specialized \ref{temp.expl.spec}, 
the class template specialization is implicitly instantiated when the
specialization is referenced in a context that requires a
completely-defined object type or when the completeness of the
class type affects the semantics of the program. 
% 
\enternote
Within a template declaration, a local class or enumeration and the members
of a local class are never considered to be entities that can be
separately instantiated (this includes their default arguments,
exception-specifications, and non-static data member initializers, if any). 
% 
As a result, the dependent names are looked up, the semantic constraints 
are checked, and any templates used are instantiated as part of the
instantiation of the entity within which the local class or enumeration is 
declared.
\exitnote
% 
The implicit instantiation of a class template specialization causes the 
implicit instantiation of the declarations, but not of the definitions, default
arguments, \added{associated constraints (\ref{temp.constr.decl}),} or
\grammarterm{exception-specification}{}s of the class member functions,
member classes, scoped member enumerations, static data members and
member templates; and it causes the implicit instantiation of the
definitions of unscoped member enumerations and member anonymous
unions.
\end{quote}


Add a new paragraph after paragraph 15 to describe how associated
constraints are instantiated.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{15}
\pnum
The associated constraints of a template specialization are not
instantiated along with the specialization itself; they are
instantiated only to determine if they are satisfied
(\ref{temp.constr}).
% 
\enternote
The satisfaction of constraints is determined during name lookup or overload
resolution (\ref{over.match}). Preserving the spelling
of the substituted constraint also allows constrained member function
to be partially ordered by those constraints according to the rules
in \ref{temp.constr.order}.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) > 2;
template<typename T> concept bool D = C<T> && sizeof(T) > 4;

template<typename T> struct S {
  S() requires C<T> { } // \#1
  S() requires D<T> { } // \#2
};

S<char> s1;    // error: no matching constructor
S<char[8]> s2; // OK: calls \#2
\end{codeblock}

Even though neither constructor for \tcode{S<char>} will be selected by
overload resolution, both constructors remain a part of the class template 
specialization. 
% 
This also has the effect of suppressing the implicit generation of a default
constructor (\cxxref{class.ctor}).
\exitexample
% 
\enterexample
\begin{codeblock}
template<typename T> struct S1 {
  template<typename U> requires false struct Inner1; // OK
};

template<typename T> struct S2 {
  template<typename U> 
    requires sizeof(T[-(int)sizeof(T)]) > 1 // error: ill-formed, no diagnostic required
      struct Inner2;
};
\end{codeblock}
\exitexample
Every instantiation of \tcode{S1} results in a valid type, although any use 
of its nested \tcode{Inner1} template is invalid.
% 
\tcode{S2} is ill-formed, no diagnostic required, since no substitution into 
the constraints of its \tcode{Inner2} template would result in a valid 
expression.
\end{addedblock}
\end{quote}


%%
%% Explicit instantiation
%%
\rSec2[temp.explicit]{Explicit instantiation}

Add the following note after paragraph 7.

\begin{quote}
\setcounter{Paras}{7}
\begin{addedblock}
\pnum
\enternote
An explicit instantiation of a constrained template shall satisfy that
template's associated constraints (\ref{temp.constr}). The satisfaction
of constraints is determined during name lookup for explicit instantiations
in which all template arguments are specified (\ref{temp.names}), or for
explicit instantiations of function templates, during template argument 
deduction (\ref{temp.deduct.decl}) when one or more trailing template 
arguments are left unspecified.
\exitnote
\end{addedblock}
\end{quote}

Modify paragraph 8 to ensure that only members whose constraints are 
satisfied are explicitly instantiated during class template 
specialization. The note in the \Cpp Standard is omitted.

\begin{quote}
\setcounter{Paras}{7}
\pnum
An explicit instantiation that names a class template specialization is 
also an explicit instantiation of the same kind (declaration or 
definition) of each of its members (not including members inherited from 
base classes and members that are templates) that has not been previously 
explicitly specialized in the translation unit containing the explicit 
instantiation, \added{and provided that the associated constraints 
(\ref{temp.constr.decl}), if any, of that member are satisfied 
(\ref{temp.constr}) by the template arguments of the explicit instantiation, } 
except as described below.
\end{quote}

%%
%% Explicit specialization
%%
\rSec2[temp.expl.spec]{Explicit specialization}

Add the following note after paragraph 10.

\begin{quote}
\setcounter{Paras}{10}
\begin{addedblock}
\pnum
\enternote
An explicit specialization of a constrained template shall satisfy that
template's associated constraints (\ref{temp.constr}). The satisfaction
of constraints is determined during name lookup for explicit specializations
in which all template arguments are specified (\ref{temp.names}), or for
explicit specializations of function templates, during template argument 
deduction (\ref{temp.deduct.decl}) when one or more trailing template 
arguments are left unspecified.
\exitnote
\end{addedblock}
\end{quote}


%%
%% Function template specializations
%%
\rSec1[temp.fct.spec]{Function template specializations}

%%
%% Template argument deduction
%%
\setcounter{subsection}{1}
\rSec2[temp.deduct]{Template argument deduction}

Add the following sentences to the end of paragraph 5. This defines
the substitution of template arguments into a function template's
associated constraints. Note that the last part of paragraph 5
has been duplicated in order to provide context for the addition.

\begin{quote}
\setcounter{Paras}{4}
\pnum
When all template arguments have been deduced or obtained from default 
template arguments, all uses of template parameters in the template 
parameter list of the template and the function type are replaced with
the corresponding deduced or default argument values. 
% 
If the substitution results in an invalid type, as described above, type 
deduction fails.
% 
\added{If the function template has associated constraints (\ref{temp.constr.decl}),
the template arguments are substituted into the associated constraints
without evaluating the resulting expression. If this substitution
results in an invalid type or expression, type deduction fails.
% 
\enternote
The satisfaction of constraints (\ref{temp.constr})
associated with the function template specialization is determined during 
overload resolution (\ref{over.match}), and not at 
the point of substitution.
\exitnote}
\end{quote}

\setcounter{subsubsection}{5}
\rSec3[temp.deduct.decl]{Deducing template arguments from a function declaration}

Add the following after paragraph 1 in order to require the
satisfaction of constraints when matching a specialization to a
template.

\begin{quote}
\begin{addedblock}
\setcounter{Paras}{2}
\pnum
Remove from the set of function templates considered all those
whose associated constraints (if any) are not satisfied by the deduced
template arguments (\ref{temp.constr}).
\end{addedblock}
\end{quote}

Update paragraph 2 (now paragraph 3) to accommodate the new wording.

\begin{quote}
\pnum
If, 
\removed{for the set of function templates so considered}
\added{for the remaining function templates},
there is either no match or more than one match after partial ordering 
has been considered (\ref{temp.func.order}), deduction fails 
and, in the declaration cases, the program is ill-formed.
\end{quote}

Add the following example to paragraph 3.

\begin{quote}
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { -t; };

template<C T>        void f(T) { } // \#1
template<typename T> void g(T) { } // \#2
template<C T>        void g(T) { } // \#3

template void f(int);   // OK: refers to \#1
template void f(void*); // error: no matching template
template void g(int);   // OK: refers to \#3
template void g(void*); // OK: refers to \#2
\end{codeblock}
\exitexample
\end{quote}


\input{constraints}

