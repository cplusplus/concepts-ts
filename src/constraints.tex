
%%
%% Template constraints
%%
\rSec1[temp.constr]{Template constraints}

Add this section after 14.8.

\begin{quote}

\pnum
\enternote
This section defines the meaning of constraints on template arguments, including
the translation of \grammarterm{constraint-expression}{}s
into constraints (\ref{temp.constr.expr}),
and also the abstract syntax, satisfaction, and subsumption of those 
constraints (\ref{temp.constr.op}, \ref{temp.constr.atom}).
\exitnote

\pnum
A \defn{constraint} is a sequence of logical operations and 
operands that specifies requirements on template arguments.
\enternote The operands of a logical operation are constraints. \exitnote

\pnum
After substitution, a constraint is \defn{satisfied} if and only if 
it and all of its operands are satisfied according to the evaluation 
rules described in \ref{temp.constr.op} and \ref{temp.constr.atom}.
% 
If the substitution of template arguments into a constraint fails, 
that constraint is not satisfied.
% 
\enternote
Substitution into a constraint may yield a well-formed constraint that
contains ill-formed expressions or types. This may happen, for
example, in the substitution into expression constraints
(\ref{temp.constr.atom.expr}) and type constraints
(\ref{temp.constr.atom.type}).
\exitnote

\pnum
A constraint \tcode{P} is said to \defn{subsume} another constraint \tcode{Q} 
if, informally, it can be determined that \tcode{P} implies \tcode{Q}, up to 
the equivalence of types and expressions in atomic constraints.
\ref{temp.constr.atom}. 
% 
\enternote
Subsumption does not determine, for example, if the predicate 
constraint (\ref{temp.constr.atom.pred}) 
\tcode{N \% 2 == 1} subsumes \tcode{N \& 1} for 
some integral template argument, \tcode{N}. 
\exitnote
% 
The rules determining when one constraint subsumes another is given
in \ref{temp.constr.order}, and subsumption
rules for each kind of atomic constraint are given in
\ref{temp.constr.atom}.


%%
%% Logical operations
%%
\rSec2[temp.constr.op]{Logical operations}

\pnum
There are two logical operations on constraints: conjunction
and disjunction.
% 
\enternote 
These logical operations have no corresponding C++ syntax.
For the purpose of exposition, conjunction is spelled
using the symbol $\land$ and disjunction is spelled using the 
symbol $\lor$. Grouping of constraints is shown using parentheses.
\exitnote

\pnum
A \defn{conjunction} is a logical operation taking two 
operands. A conjunction of constraints is satisfied if and only 
if both operands are satisfied.

\pnum
A \defn{disjunction} is a logical operation taking two 
operands. A disjunction of constraints is satisfied if and only 
if either operand is satisfied or both operands are satisfied.

%%
%% Atomic constraints
%%
\rSec2[temp.constr.atom]{Atomic constraints}

Any constraint that is not a conjunction or disjunction is an
\defn{atomic constraint}.

%%
%% Predicate constraints
%%
\rSec3[temp.constr.atom.pred]{Predicate constraints}

\pnum
A \defn{predicate constraint} is an atomic constraint
that evaluates a prvalue constant expression of type \tcode{bool}
(\cxxref{expr.const}).
% 
The constraint is satisfied if and only if the expression 
evaluates to \tcode{true}.
% 
\enternote
Predicate constraints allow the definition of template requirements
in terms of constant expressions. This allows the specification 
constraints on non-type template arguments and template template 
arguments.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = sizeof(T) == 4 && !true;
\end{codeblock}
Here, \tcode{sizeof(T) == 4} and \tcode{!true} are 
predicate constraints required by the concept, \tcode{C}.
\exitexample

\pnum
A predicate constraint \tcode{P} subsumes another predicate constraint 
\tcode{Q} if and only if \tcode{P} and \tcode{Q} are equivalent 
\grammarterm{constraint-expression}{}s (\ref{temp.constr.expr}).
% 
\enterexample
The predicate \tcode{M >= 0} does not subsume the predicate
\tcode{M > 0} because they are not equivalent
\grammarterm{constraint-expressions}.
\exitexample



%%
%% Expression constraints
%%
\rSec3[temp.constr.atom.expr]{Expression constraints}

\pnum
An \defn{expression constraint} is an atomic constraint
that specifies a requirement on the formation of an
\grammarterm{expression} \tcode{E}
through substitution of template arguments.
% 
An expression constraint is satisfied if substitution 
yielding \tcode{E} did not fail. 
% 
Within an expression constraint, \tcode{E} is an unevaluated 
operand (Clause \ref{expr}).
% 
\enternote
An expression constraint is introduced by the \grammarterm{expression} in 
either a \grammarterm{simple-requirement} (\ref{expr.prim.req.simple})
or \grammarterm{compound-requirement} (\ref{expr.prim.req.compound})
of a \grammarterm{requires-expression}.
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires (T t) { ++t; };
\end{codeblock}
The concept \tcode{C} introduces an expression constraint for 
the expression \tcode{++t}.
% 
The type argument \tcode{int} satisfies this constraint because the
the expression \tcode{++t} is valid after substituting \tcode{int}
for \tcode{T}.
\exitexample

\pnum
An expression constraint \tcode{P} subsumes another expression constraint 
\tcode{Q} if and only if the \grammarterm{expression}{}s of \tcode{P}
and \tcode{Q} are equivalent (\ref{temp.over.link}). 


%%
%% Type constraints
%%
\rSec3[temp.constr.atom.type]{Type constraints}

\pnum
A \defn{type constraint} is an atomic constraint that specifies a requirement 
on the formation of a type \tcode{T} through the substitution of template 
arguments.
% 
A type constraint is satisfied if and only \tcode{T} is non-dependent, meaning 
that the substitution yielding \tcode{T} did not fail.
% 
\enternote
A type constraint is introduced by the \grammarterm{typename-specifier} in a
\grammarterm{type-requirement} of a \grammarterm{requires-expression}
(\ref{expr.prim.req.type}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C = requires () { typename T::type; };
\end{codeblock}
The concept \tcode{C} introduces a type constraint for the 
type name \tcode{T::type}.
% 
The type \tcode{int} does not satisfy this constraint
because substitution of that type into the constraint results in a
substitution failure; \tcode{typename int::type} is ill-formed.
\exitexample

\pnum
A type constraint that names a class template specialization 
does not require that type to be complete 
(\cxxref{basic.types}).

\pnum
A type constraint \tcode{P} subsumes another type
constraint \tcode{Q} if and only if the types in \tcode{P}
and \tcode{Q} are equivalent 
(\cxxref{temp.type}).


%%
%% Implicit conversion constraints
%%
\rSec3[temp.constr.atom.conv]{Implicit conversion constraints}

\pnum
An \defn{implicit conversion constraint} is an atomic constraint that 
specifies a requirement on the implicit conversion of an \grammarterm{expression}
\tcode{E} to a type \tcode{T}. 
% 
The constraint is satisfied if and only if \tcode{E} is implicitly convertible 
to \tcode{T} (Clause~\cxxref{conv}).

\enternote
A conversion constraint is introduced by a \grammarterm{trailing-return-type} 
in a \grammarterm{compound-requirement} when the 
\grammarterm{trailing-return-type} contains no placeholders 
(\ref{expr.prim.req.compound}).
\exitnote

\enterexample
\begin{codeblock}
template<typename T> concept bool C = 
  requires (T a, T b) {
    { a == b } -> bool;
  };
\end{codeblock}
The \grammarterm{compound-requirement} in the
\grammarterm{requires-expression} of \tcode{C} introduces two atomic 
constraints: an expression constraint for \tcode{a == b}, and the implicit 
conversion constraint that the expression \tcode{a == b} is implicitly 
convertible to \tcode{bool}.
\exitexample

\pnum
An implicit conversion constraint \tcode{P} subsumes another implicit 
conversion constraint \tcode{Q} if and only if the \grammarterm{expression}{}s 
of \tcode{P} and \tcode{Q} are equivalent (\ref{temp.over.link}) and the types
of \tcode{P} and \tcode{Q} are equivalent (\cxxref{temp.type}).


%%
%% Argument deduction constraints
%%
\rSec3[temp.constr.atom.deduct]{Argument deduction constraints}

\pnum
An \defn{argument deduction constraint} is an atomic
constraint that specifies a requirement on 
the usability of an \grammarterm{expression} 
\tcode{E} as an argument to an invented abbreviated
function template \tcode{F} (\ref{dcl.fct}),
where \tcode{F} has a single parameter formed from a type that 
includes placeholders 
(\ref{dcl.spec.auto}, \ref{dcl.spec.constr}).
% 
\enternote
An argument deduction constraint is introduced by a
\grammarterm{trailing-return-type} in a
\grammarterm{compound-requirement} when the
\grammarterm{trailing-type-specifier-seq}
contains at least one placeholder
(\ref{expr.prim.req.compound}).
\exitnote
% 
\enterexample
\begin{codeblock}
template<typename T>
concept bool C1() { return true; }

template<typename T>
concept bool C2() { return requires(T t) { {*t} -> const C1& x; }; }
\end{codeblock}
The invented function template for the
\grammarterm{compound-requirement} in
\tcode{C2} is:
\begin{codeblock}
void F(const C1& x);
\end{codeblock}
\exitexample
% 
The constraint is satisfied if and only if \tcode{F}
is selected by overload resolution for the call \tcode{F(E)}
(\ref{over.match}).
% 
\enternote
Overload resolution selects \tcode{F} only when template 
argument deduction succeeds and \tcode{F}'s associated 
constraints are satisfied.
\exitnote

\pnum
An argument deduction constraint \tcode{P} subsumes another argument deduction 
constraint \tcode{Q} if and only if the \grammarterm{expression}{}s of
\tcode{P} and \tcode{Q} are equivalent (\ref{temp.over.link}), and the types
of \tcode{P} and \tcode{Q} are equivalent (\cxxref{temp.type}). 


%%
%% Exception constraints
%%
\rSec3[temp.constr.atom.noexcept]{Exception constraints}

\pnum
An \defn{exception constraint} is an atomic constraint
for an expression \tcode{E} that is satisfied if and only
if the expression \tcode{noexcept(E)} is \tcode{true}
(\cxxref{expr.unary.noexcept}).
% 
\enternote
Constant expression constraints are introduced by a
\grammarterm{compound-requirement} that
includes the \tcode{noexcept} specifier
(\ref{expr.prim.req.compound}).
\exitnote


\pnum
An exception constraint \tcode{P} subsumes another
exception constraint \tcode{Q} if and only if the
\grammarterm{expression}{}s of \tcode{P}
and \tcode{Q} are equivalent 
(\ref{temp.over.link}).



%%
%% Partial ordering by constraints
%%
\rSec2[temp.constr.order]{Partial ordering by constraints}

\pnum
In order to determine if a constraint \tcode{P} subsumes a constraint
\tcode{Q}, transform \tcode{P} into disjunctive normal form, 
and transform \tcode{Q} into conjunctive normal form\footnote{
A constraint is in disjunctive normal form when it is a disjunction of
clauses where each clause is a conjunction of atomic constraints. 
% 
Similarly, a constraint is in conjunctive normal form when it is a conjunction 
of clauses where each each clause is disjunction of atomic constraints.
\enterexample
Let \tcode{A}, \tcode{B}, and \tcode{C} be atomic
constraints. 
% 
The constraint \tcode{A} $\land$ (\tcode{B} $\lor$ \tcode{C}) is in 
conjunctive normal form.
% 
Its conjunctive clauses are \tcode{A} and (\tcode{B} $\lor$ \tcode{C}).
% 
The disjunctive normal form of the constraint
\tcode{A} $\land$ (\tcode{B} $\lor$ \tcode{C}) 
is
(\tcode{A} $\land$ \tcode{B}) $\lor$ (\tcode{A} $\land$ \tcode{C}).
% 
Its disjunctive clauses are (\tcode{A} $\land$ \tcode{B}) and 
(\tcode{A} $\land$ \tcode{C}).
\exitexample
}.
% 
The disjunctive normal form of \tcode{P} subsumes the conjunctive normal 
form of \tcode{Q} if and only if every disjunctive clause in \tcode{P$i$} 
subsumes each conjunctive clause in \tcode{Q$j$}.
% 
A disjunctive clause \tcode{P$i$} subsumes a conjunctive clause
\tcode{Q$j$} when each atomic constraint in \tcode{P$i$} subsumes any atomic 
constraint in \tcode{Q$j$}.
% 
The rules for determining whether one atomic constraint subsumes
another are defined for each kind of atomic constraint
(\ref{temp.constr.atom}).
% 
\enterexample
Let \tcode{A} and \tcode{B} be
predicate constraints (\ref{temp.constr.atom.pred}).
% 
The constraint \tcode{A $\land$ B} subsumes \tcode{A}, 
but \tcode{A} does not subsume \tcode{A $\land$ B}. 
% 
The constraint \tcode{A} subsumes \tcode{A $\lor$ B}, but
\tcode{A $\lor$ B} does not subsume code \tcode{A}. 
% 
Also, any constraint \tcode{P} subsumes itself.
\exitexample


\pnum
The subsumption relation defines a partial ordering on constraints. 
This partial ordering is used to determine
% 
\begin{itemize}
\item the best viable candidate of non-template functions
     (\ref{over.match.best}), 
\item the address of a non-template function
     (\ref{over.over}), 
\item the matching of template template arguments
     (\ref{temp.arg.template}), 
\item the partial ordering of class template specializations
     (\ref{temp.class.order}), and
\item the partial ordering of function templates
     (\ref{temp.func.order}).
\end{itemize}

\pnum
When two declarations \tcode{D1} and \tcode{D2} are
partially ordered by their normalized constraints, \tcode{D1} is 
\defn{more constrained} than \tcode{D2} if
% 
\begin{itemize}
\item \tcode{D1} and \tcode{D2} are both constrained
declarations and \tcode{D1}'s associated constraints subsume but 
are not subsumed by those of \tcode{D2}; or

\item \tcode{D1} is constrained and \tcode{D2} is
unconstrained. 
\end{itemize}
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = requires(T t) { --t; };
template<typename T> concept bool C2 = C1<T> && requires(T t) { *t; };

template<C1 T> void f(T);       // \#1
template<C2 T> void f(T);       // \#2
template<typename T> void g(T); // \#3
template<C1 T> void g(T);       // \#4

f(0);       // selects \#1
f((int*)0); // selects \#2
g(true);    // selects \#3 because \tcode{C1<bool>} is not satisfied
g(0);       // selects \#4
\end{codeblock}
\exitexample

\pnum
A declaration \tcode{D1} is \defn{at least as constrained}
as another declaration \tcode{D2} when \tcode{D1} is more
constrained than \tcode{D2}, and \tcode{D2} is not more
constrained than \tcode{D1}.


%%
%% Constraint expressions
%%
\rSec2[temp.constr.expr]{Constraint expressions}

\pnum
Certain contexts require expressions that can be transformed
into constraints through the process of \defn{normalization}.

\begin{bnf}
\nontermdef{constraint-expression}\br
    logical-or-expression
\end{bnf}

\pnum
A \grammarterm{constraint-expression} is \defn{normalized} by forming a 
constraint as follows.

\begin{itemize}
\item The normalized form of \tcode{(P)} is the normalized form of 
\tcode{P}.

\item The normalized form of \tcode{P || Q} is
the disjunction (\ref{temp.constr.op}) of the 
normalized form of \tcode{P} and the normalized form of 
\tcode{Q}.

If, after substitution, overload resolution 
(\ref{over.match}) selects a user-declared 
\tcode{operator||}, the program is ill-formed.

\item The normalized form of \tcode{P \&\& Q} is
the conjunction (\ref{temp.constr.op}) of the 
normalized form of \tcode{P} and the normalized form of
\tcode{Q}.

If, after substitution, overload resolution 
(\ref{over.match}) selects a user-declared 
\tcode{operator\&\&}, the program is ill-formed.

\item The normalized form of a function call of the form
\tcode{C<A$1$, A$2$, ..., A$N$>()},
where \tcode{A$1$, A$2$, ..., A$N$}
is a sequence of template arguments and \tcode{C} names a function
concept (\ref{dcl.spec.concept}), is the result of 
substituting the template arguments into the expression
returned by \tcode{C}.

\item The normalized form of an \grammarterm{id-expression}
of the form \tcode{C<A$1$, A$2$, ..., A$N$>}
where \tcode{A$1$, A$2$, ..., A$N$}
is a sequence of template arguments and \tcode{C} names a variable
concept (\ref{dcl.spec.concept}) is the result of 
substituting the template arguments into the initializer
of \tcode{C}.

\item The normalized form of a 
\grammarterm{requires-expression} 
(\ref{expr.prim.req}) is
the conjunction of constraints (\ref{temp.constr.op}) 
introduced by the body of that expression.


\item Otherwise, \tcode{E} is a predicate constraint 
(\ref{temp.constr.atom.pred}). 
% 
After substitution, \tcode{E} shall be a converted constant 
expression of type \tcode{bool}.

\end{itemize}

% Do we need a top-level conversion requirement for constraint expressions?

\enternote
A \grammarterm{constraint-expression} defines a subset of constant 
expressions over which certain logical implications can be deduced during 
translation.

The prohibition against user-defined logical operators is intended to
prevent the subversion of the logic used to partially order 
constraints (\ref{temp.constr.order}).
\exitnote

% TODO: Make this a table.
\enterexample
\begin{codeblock}
template<typename T> concept bool C1() { return sizeof(T) == 1; }
template<typename T> concept bool C2 = C1<T>() && 1 == 2;
template<typename T> concept bool C3 = requires () { typename T::type; };

// Expression      // Constraints
C2<char>           sizeof(char) == 1 /* and */ 1 == 2
C3<int>            /* type constraint for int::type */
3 + 4              // error: not a constraint
(bool)(3 + 4)      (bool)(3 + 4)
\end{codeblock}
In the normalized constraints, the expressions \tcode{sizeof(char) == 1}, 
\tcode{1 == 2}, and \tcode{(bool)(3 + 4)} are predicate 
constraints (\ref{temp.constr.atom.pred}). 

The concept \tcode{C3} is normalized to a single type constraint
(\ref{temp.constr.atom.type}) for the (ill-formed) 
type \tcode{int::type}.

The expression \tcode{3 + 4} is not a 
\grammarterm{constraint-expression} because it does
not satisfy the requirements for being normalized into a predicate 
constraint.
\exitexample


%%
%% Resolution of constrained-type-specifiers
%%
\rSec2[temp.constr.resolve]{Resolution of \grammarterm{constrained-type-specifier}{}s}

\pnum
Whenever an \grammarterm{identifier} is a \grammarterm{concept-name}, it is 
necessary to determine a single concept referred to by the use of that name.
% 
\defn{Concept resolution} is the process of selecting a concept 
from a set of concept definitions referred to by a concept name.

Concept resolution is performed when a 
\grammarterm{constrained-type-specifier} appears in
the declaration of an abbreviated function (\ref{dcl.fct})
or generic lambda (\ref{expr.prim.lambda}),
in the \grammarterm{trailing-return-type} of a
\grammarterm{compound-requirement}, the
\grammarterm{constrained-type-specifier} of a
\grammarterm{constrained-parameter}, or
in a \grammarterm{template-introduction}.

\pnum
A concept is selected from a set of concepts based on a sequence
of template argument patterns and a sequence of explicit
template arguments. 
% 
A \defn{template argument pattern} is a kind of template argument 
that is used to match the type and form of a template parameter from a 
concept definition. A template argument pattern can be a pack expansion.
% 
A concept is selected from the set by matching the template
argument patterns and explicit template arguments against the template 
parameters of that concept.

\pnum
When selecting a concept for a \grammarterm{constrained-type-specifier},
there is a single template argument pattern. 
% 
If the \grammarterm{constrained-type-specifier} appears in the declaration 
of a \grammarterm{constrained-parameter} (\ref{temp.param}) and is
followed by an ellipsis, the template argument pattern is a pack
expansion.
% 
If the \grammarterm{constrained-type-specifier}
is a \grammarterm{partial-concept-id} the explicit
\grammarterm{template-arguments} are those in
the \grammarterm{partial-concept-id}.
% 
When selecting a concept for a \grammarterm{concept-name} in a 
\grammarterm{template-introduction}, there is one template argument pattern 
for each \grammarterm{introduced-parameter}.
% 
If an \grammarterm{introduced-parameter} is
preceded by an ellipsis, its corresponding template argument pattern
is a pack expansion.
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C1() { return true; }
template<typename T, typename U> concept bool C1() { return true; }
template<typename... T> concept bool C2() { return true; }
% 
void f1(C1); 
void f2(C1<int>);
\end{codeblock}
% 
In the resolution of \tcode{C1} required by the declaration of \tcode{f1}, 
there is a single template argument pattern and zero explicit template 
arguments.
% 
For \tcode{f2} there is a single template argument pattern and the 
single explicit template argument, \tcode{int}.
\begin{codeblock}
C1{T} void f3(T);
C1{T, U} void f4(T);
\end{codeblock}
In the resolution required by the declaration of \tcode{f3}, there
is a single template argument pattern; there are two in the resolution
required by \tcode{f2}. There are zero explicit template arguments
in the resolutions of \tcode{f1} and \tcode{f2}.
\begin{codeblock}
C2{...T} void f5();
\end{codeblock}
There is a single template argument pattern in the resolution of
\tcode{f2}, and it is a pack expansion.
\exitexample

\pnum
For each concept \tcode{C} in the concept set, each template 
argument in the combined sequence of template argument patterns and explicit 
template arguments is matched against the corresponding template parameter
in the \grammarterm{template-parameter-list} of 
\tcode{C} as follows.
% 
A template argument pattern that is not a parameter pack matches a 
non-pack template parameter of any type and form. A template argument 
pattern that is a parameter pack matches a template parameter pack
whose pattern is any form.
% 
The remaining explicit arguments are matched against parameters
as specified in \ref{temp.arg}.
% 
If any template argument patterns or explicit template arguments do not 
match the corresponding parameter, \tcode{C} is removed from the set.
% 
If a single concept remains, it is the one selected by concept 
resolution. Otherwise, the program is ill-formed. 
% 
\enterexample
\begin{codeblock}
template<typename T> concept bool C() { return true; }             // \#1
template<typename T, typename U> concept bool C() { return true; } // \#2
template<typename T> concept bool P() { return true; }
template<int T> concept bool P() { return true; }
template<<typename... Ts> concept bool Q = true;

void f1(const C*);  // OK: \tcode{C} selects \#1
void f2(C<char>);   // OK: \tcode{C<char>} selects \#2
void f3(C<3>);      // error: no matching concept for \tcode{C<3>} (mismatched template arguments)
void g1(P);         // error: resolution of \tcode{P} is ambiguous (\tcode{P} refers to two concepts)
Q{...Ts} void q1(); // OK: selects \tcode{Q}
Q{T} void q2();     // error: no matching concept (mismatched template arguments)
\end{codeblock}
\exitexample

\pnum
For the selected template, the set of template parameters corresponding
to the matched template argument patterns are called the
\defn{selected template parameters}. 
% 
In a \grammarterm{template-introduction} (\ref{temp.intro}), these
are used to derive the declarations of introduced parameters.


%%
%% Constraint formation from constrained-type-specifiers
%%
\rSec2[temp.constr.form]{Constraint formation from \grammarterm{constrained-type-specifier}{}s}

\pnum
When a parameter of an abbreviated function template is declared
with a \grammarterm{constrained-type-specifier},
or in the declaration of a 
\grammarterm{constrained-parameter},
the \grammarterm{constrained-type-specifier}
associates a \grammarterm{constraint-expression}
with the respective function or template declaration.
% 
The formation of that \grammarterm{constraint-expression}
is derived from the \grammarterm{constrained-type-specifier},
the designated concept selected by concept resolution 
(\ref{temp.constr.resolve}), and an 
invented template parameter or a declared template parameter, called
the \defn{target template parameter}.
% 
When the \grammarterm{constrained-type-specifier}
appears in the declaration of a function parameter, the target template
parameter is the one invented for the abbreviated function template
(\ref{dcl.fct}).

When the \grammarterm{constrained-type-specifier}
appears in the declaration of a 
\grammarterm{constrained-parameter},
the target template parameter is the declared template parameter.


\pnum
Let \tcode{C} be the concept designated by the
\grammarterm{constrained-type-specifier} (including its 
\grammarterm{nested-name-specifier}, if any),
let \tcode{P} be the prototype parameter of the designated
concept, and let \tcode{X} be the target template parameter.
% 
Form a new template argument \tcode{A} from \tcode{X} as
as follows. If \tcode{X} declares a parameter pack, and
\tcode{P} declares a parameter pack, \tcode{A}
is a pack expansion of \tcode{X}. Otherwise \tcode{A} is
a template argument referring to \tcode{X}.
% 
Form a \grammarterm{template-id} \tcode{TT}
as follows. 
% 
When the \grammarterm{constrained-type-specifier} is a 
\grammarterm{partial-concept-id}, \tcode{TT} is 
\tcode{C<A, Args>} where \tcode{Args} is the sequence of 
\grammarterm{template-argument}{}s in the
\grammarterm{partial-concept-id}.
% 
Otherwise, \tcode{TT} is \tcode{C<A, Args>}.
% 
Form an expression \tcode{E} from \tcode{TT}. If \tcode{C} refers to a 
variable concept, \tcode{E} is the \grammarterm{id-expression} \tcode{TT}.
% 
If \tcode{C} refers to a function concept, \tcode{E} is the function call 
\tcode{TT()}.

\pnum
The formed constraint is the fold expression \tcode{E1 \&\& E2 \&\& ... \&\& E$N$}
when the prototype parameter \tcode{P} declares a template parameter pack and 
the target template parameter \tcode{X} does not.
% 
Otherwise, the \grammarterm{constraint-expression} is \tcode{E}.
% 
% TODO: Add examples for constrained parameters 
% TODO: Give an example with a nested name specifier.
\enterexample
\begin{codeblock}
template<typename T> concept bool C1 = true;
template<typename T, typename U> concept bool C2() { return true; }
template<typename... Ts> concept bool C3;

template<int> struct X { };

void f1(C1&);     // associates \tcode{C1<T1>} with \tcode{f1}
void f2(C2<int>); // associates \tcode{C2<T2, int>()} with \tcode{f2}
void f3(C1...);   // associates \tcode{(C1<T1> \&\& ...)} with \tcode{f3}
void f4(C3...);   // associates \tcode{C3<T1...>} with \tcode{f4}
\end{codeblock}
% 
Here, \tcode{T1} and \tcode{T2} are invented type template parameters 
corresponding to the prototype parameter of their respective designated 
concepts.

\end{quote}
