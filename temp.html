
<cxx-clause id="temp" number="14">
  <h1>Templates</h1>

  <!-- Editing instruction -->
  Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in <cxx-ref in="cxx" to="temp"></cxx-ref>/1.

  <blockquote>
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        declaration
      </bnf-alt>
      <ins>
      <bnf-alt>
        <bnf-opt>nested-name-specifier</bnf-opt> 
        concept-name
        <bnf-terminal>{</bnf-terminal>
        introduction-list
        <bnf-terminal>}</bnf-terminal>
        declaration
      </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>

    <bnf-rule>introduction-list</bnf-rule>
      <bnf-alt>introduced-parameter</bnf-alt>
      <bnf-alt>introduction-list <bnf-terminal>,</bnf-terminal> introduced-parameter</bnf-alt>

      <bnf-rule>introduced-parameter</bnf-rule>
        <bnf-alt><bnf-opt><bnf-terminal>...</bnf-terminal></bnf-opt> identifier</bnf-alt>
    </ins>
  </bnf-grammar>
  </blockquote>
  
  <!-- <p> -->
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp"></cxx-ref>/6.
  <!-- </p> -->

  <p> A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its <cxx-grammarterm>template-parameters</cxx-grammarterm>. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <cxx-grammarterm>concept-name</cxx-grammarterm> and its
  <cxx-grammarterm>introduction-list</cxx-grammarterm>, collectively called
  a <dfn>concept introduction</dfn>. </p>

<!-- 
  <p>An <cxx-grammarterm>template declaration</cxx-grammarterm> declared
  by a concept introduction with a
  <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>C</code>, and
  an <cxx-grammarterm>introduction-list</cxx-grammarterm> containing the 
  identifiers <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code>
  is equivalent to a template declaration whose
  template parameters correspond to the first <i>n</i> template parameters
  of <code>C</code>, and the equivalent declaration has a
  <cxx-grammarterm>requires-clause</cxx-grammarterm> whose
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code> if <code>C</code> designates
  a variable concept or
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;()</code> if <code>C</code> designates
  a function concept.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N&gt; concept bool C = true;

C{A, N} struct Array;

template&lt;typename A, int M&gt; 
  requires C&lt;A, M&gt; // Constraint defined by C{A, M}
   struct Array;   // OK: redeclaration of X
   </cxx-codeblock>
  </cxx-example>
  </p> 
-->

  <p> The concept designated by the <cxx-grammarterm>concept-name</cxx-grammarterm>
  is determined by the number of <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s.
  Let <code>C</code> be a <cxx-grammarterm>concept-name</cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm>identifiers</cxx-grammarterm> in the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s of
  an <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  If the <cxx-grammarterm>template-id</cxx-grammarterm>
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code> refers to a single
  concept declaration, then that declaration is the one designated by
  the <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>C</code>. 
  Otherwise, the program is ill-formed.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq() { return true; }             // #1
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // #2

Eq{T} void f1(T, T);    // OK: designates #1
Eq{A, B} void f2(A, B); // OK: designates #2

template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // error: resolution of the concept C is ambiguous
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>Each <cxx-grammarterm>identifier</cxx-grammarterm>, <code>I</code>,
  in <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s,
  of the <cxx-grammarterm>introduction-list</cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm>concept-name</cxx-grammarterm>.
  <cxx-grammarterm>
  <ul>
  
  <li> If <code>P</code> is a template type parameter declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a type parameter using the same keyword;</li>
  
  <li> if <code>P</code> is a template type parameter that declares
  a class template, <code>I</code> is declared as a
  class template with the same template parameters as <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type template parameter, <code>I</code> is 
  declared as a non-type template parameter, having the same type as 
  <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm>introduced-parameter</cxx-grammarterm>
  shall be preceded by an ellipsis, and <code>I</code> is declared as a 
  template parameter pack.</li>
  </ul>
  
  An <cxx-grammarterm>introduced-parameter</cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt;
  concept bool Inscrutable() { return true; }

Inscrutable{A, B, ...C} // OK: A is declared as typename A
  struct s;             // B is declared as int B
                        // C is declared as typename... C

Inscrutable{X, Y, Z} // error: Z must be preceded by an ellipsis (...)
  struct t;

template&lt;template&lt;typename&gt; class X&gt;
  concept bool Unary_template = true;

Unary_template{T} // OK: T is declared as template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // error: the corresponding parameter is not a 
  void bar();        // template parameter pack
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>
  <cxx-note>
  A concept referred to be a <cxx-grammarterm>concept-name</cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm>introduction-list</cxx-grammarterm> may omit 
  <cxx-grammarterm>identifiers</cxx-grammarterm> for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // OK: f(T) is a function template with
                        // a single template type parameter T
  </cxx-codeblock>
There is no <cxx-grammarterm>introduced-parameter</cxx-grammarterm> 
corresponding to the template parameter <code>B</code> in the
<code>Ineffable</code> concept. <code>T</code> is the only declared
template parameter of <code>f(T)</code>.
  </cxx-example>
  </cxx-note>
  </p>

  <p> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typeaname T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // OK
Array&lt;double&gt; s2;    // error: Array takes 2 template arguments
  </cxx-codeblock>
  </cxx-example>
  </p>


  <p> The <cxx-grammarterm>introduction-list</cxx-grammarterm> shall not
  be empty.</p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // OK: definition of f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p>


  <p>An abbreviated function <cxx-ref to="dcl.fct"></cxx-ref> may be declared 
  as a function template by a concept introduction. The invented template
  parameters introduced by the 
  <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> or
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in
  the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
  are added to the list of template parameters specified in the
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  <cxx-example class="inline">
  <cxx-codeblock>
C{T} void f(T, D);
C{T} void g(T, C);

template&lt;C T, D __D&gt; void f(T, __D); // OK: redeclaration of f(T, D)
template&lt;C T, C __C&gt; void g(T, __C); // OK: redeclaration of g(T, C)
  </cxx-codeblock>
  A concept introduction does introduce a type name, so the use of
  <code>C</code> in the first declaration of <code>f</code> designates
  a new invented template parameter constrained by <code>C</code>
  (<cxx-ref to="dcl.fct"></cxx-ref>).
  </cxx-example>
  
  <cxx-example class="inline">
  <cxx-codeblock>
C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

  C{T} void X&lt;T&gt;::f(D) { } // OK: definition of X&lt;T&gt;::f(D);
                           // f is a function template with one invented
                           // template type parameter

  C{T} D{U} void X&lt;T&gt;::g(U, C) { } // OK: definition of X&lt;T&gt;::g(U, C);
                                   // g is a function template with two template
                                   // type parameters: one introduced (U) and
                                   // one invented
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>C</code>,
  associates a constraint  with the 
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. That constraint is
  
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code> if <code>C</code> designates
  a variable concept or
  
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;()</code> if <code>C</code> designates
  a function concept.
  </p>


  <!-- FIXME: This should move to a separate section? -->


  <p>A <cxx-grammarterm>template-declaration</cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  <ul>
  <li> the designated concept in a concept introduction,

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>)
  in the declaration's <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
  a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"></cxx-ref>),</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> appearing after
  the <cxx-grammarterm>declarator</cxx-grammarterm> of an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm>template-declaration</cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm>requires-clause</cxx-grammarterm> whose 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"></cxx-ref>).

  <cxx-note> This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

// All of the following declarations are equivalent:
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of a single
  <cxx-grammarterm>requires-clause</cxx-grammarterm>.
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  </cxx-note>
  <p>

  <p> When <cxx-grammarterm>template-declaration</cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> whose
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;class T, class U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // Constraint associated by C1{A, B}
   struct X;        // OK: redeclaration of X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // Constraint associated by C2{A, B}
   struct Y;           // OK: redeclaration of Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // Constraint associated by C3{P}
    void f(P);   // OK: redeclaration of f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;P&gt;          // Constraint associated by C4{...Qs}
    void void g(Qs&amp;&amp;...); // OK: redeclaration of g(Qs&amp;&amp;...)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>When a <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>), it
  is equivalent to a <cxx-grammarterm>template declaration</cxx-grammarterm>, <code>E</code>
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
  (<cxx-ref to="temp.param"></cxx-ref>).
  
  The declaration <code>E</code> has a <cxx-grammarterm>requires-clause</cxx-grammarterm>
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code> (<cxx-ref to="temp.param"></cxx-ref>).

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm>, its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 A, C2 B&gt; struct R;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f();

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt; 
    struct S; // OK: redeclaration of S

template&lt;typename X, int Y&gt;
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct R; // error: redeclaration of R with different constraints

template&lt;typename T&gt;  
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(); // OK: redeclaration of f()
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> When the declaration is abbreviated function, the declaration is 
  equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"></cxx-ref>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // OK: redeclaration of f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;
    void f(T, T, U): // OK: also a redeclaration of f(C, C, D)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> An abbreviated function can also be declared as a
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in the
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> and the
  following <cxx-grammarterm>requires-clause</cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D { return true; }
template&lt;typename P&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);

template&lt;C T, D U&gt;
  requires P&lt;T&gt;
    void g1(T, U);  // OK: redeclaration of g1(T, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // OK: also redeclaration of g1(T, D)

template&lt;C T&gt; void g2(T, D);
  
C{T} void g2(T, D); // OK: redeclaration of g2(T, D)
  </cxx-codeblock>
  </cxx-example>


  <p> A <dfn>trailing <cxx-grammarterm>requires-clause</cxx-grammarterm></dfn> 
  is a <cxx-grammarterm>requires-clause</cxx-grammarterm> that appears after
  the <cxx-grammarterm>declarator</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm>requires-clause</cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of the
  trailing <cxx-grammarterm>requires-clause</cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
  <cxx-codeblock>
  template&lt;C T&gt;
  struct S {
    template&lt;D U&gt; void f(P p) requires D&lt;T&gt;;
  };

  template&lt;C T&gt;
    template&lt;typename U, typename __P&gt;
      requires D&lt;U&gt; &amp;&amp; P&lt;__P&gt; &amp;&amp; D&lt;T&gt;
        void S&lt;T&gt;::f(U) { } // OK: definition of S&lt;T&gt;::f(U)

  template&lt;C T&gt;
    template&lt;typename U, typename __P&gt;
      void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; P&lt;__P&gt; &amp;&amp; D&lt;T&gt; { } // error: redefinition
  </cxx-codeblock>
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  </cxx-example>
  </p>

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    <p>Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref> to include
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>.

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <ins><bnf-alt>constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>constrained-parameter</bnf-rule>
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          declarator
        </bnf-alt>
        
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          declarator
          <bnf-terminal>=</bnf-terminal>
          constrained-initializer
        </bnf-alt>

        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          abstract-declarator<bnf-opt></bnf-opt>
        </bnf-alt>
        
        <bnf-alt>
          attribute-specifier-seq<bnf-opt></bnf-opt>
          decl-specifier-seq
          abstract-declarator<bnf-opt></bnf-opt>
          <bnf-terminal>=</bnf-terminal>
          constrained-initializer
        </bnf-alt>

      <bnf-rule>constrained-initializer</bnf-rule>
        <bnf-alt>type-id</bnf-alt>
        <bnf-alt>initializer-clause</bnf-alt>
      </ins>
    </bnf-grammar>

    <cxx-note> 
    The <cxx-grammarterm>constrained-parameter</cxx-grammarterm>
    syntax is largely identical to the
    <cxx-grammarterm>parameter-declaration</cxx-grammarterm> syntax except
    syntax of default arguments, which is extended to also accept a 
    <cxx-grammarterm>type-id</cxx-grammarterm>.
    </cxx-note>

    <p>Add the following paragraphs after
    <cxx-ref in="cxx" to="temp.param"></cxx-ref>/15.</p>

    <p>A <dfn>constrained template parameter</dfn> is a
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> whose
    <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> contains a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

    A <cxx-grammarterm>constrained-parameter</cxx-grammarterm> 
    defines its identifier to be a template parameter that matches in
    kind the first template parameter, called the <dfn>prototype parameter</dfn>, 
    of the concept designated by the 
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool C1 = ...;
template&lt;template&lt;typename&gt; class X&gt; 
  concept bool C2 = ...;
template&lt;int N&gt; 
  concept bool P = ...;

template&lt;C1 T&gt; void f();       // T is a type parameter
template&lt;C2 X&gt; void g();       // X is a template with one type parameter
template&lt;P N&gt; void x();        // N has type int
template&lt;const P* N&gt; void y(); // N has type const int*
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If the prototype parameter is a type parameter (including template
    template parameters), then the 
    <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of the
    constrained parameter shall consist of only the
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;const C1&gt; // Error: declares a const-qualified type parameter
  struct S;
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The declared <cxx-grammarterm>template-parameter</cxx-grammarterm> is
    a template parameter pack if the prototype parameter declares a
    template parameter pack. In such cases, the 
    <cxx-grammarterm>declarator-id</cxx-grammarterm> or
    <cxx-grammarterm>abstract-declarator</cxx-grammarterm> of the
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> shall
    also include an ellipsis.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename... Ts&gt;
  concept bool X = ...;

template&lt;X... Xs&gt; void f(); // Xs is a parameter pack
template&lt;X Xs&gt; void g();    // Error: must X must include ...
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If the <cxx-grammarterm>constrained-parameter</cxx-grammarterm>
    declares a type parameter, then the 
    <cxx-grammarterm>constrained-initializer</cxx-grammarterm>
    is parsed as a <cxx-grammarterm>type-id</cxx-grammarterm>. Otherwise, it
    is parsed as a <cxx-grammarterm>initializer-clause</cxx-grammarterm>.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;C1 T = int&gt; void p(); // Ok
template&lt;P N = 0&gt; void q();    // Ok
template&lt;P M = int&gt; void r();  // Error: int is not an expression
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The declaration of a 
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm> 
    introduces a new constraint on the template declaration. 

    The constraint is formed by substituting the declared 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> as the first
    template argument of the concept declaration designated by the
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> in
    the <cxx-grammarterm>constrained-parameter</cxx-grammarterm> declaration.

    If the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is
    a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>, its template
    arguments are substituted after the declared
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.

    If the designated concept is a function concept, then the 
    introduced constraint is a function call.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;C1 T&gt; void f1(); // requires C1&lt;T&gt;
template&lt;C2 U&gt; void f2(); // requires C2&lt;U&gt;
template&lt;P N&gt; void f3(); // requires P&lt;N&gt;
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If the <cxx-grammarterm>constrained-parameter</cxx-grammarterm> declares 
    a template parameter pack, the formation of the constraint depends on 
    whether the designated concept designated by the parameter's
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is variadic.

    Let <code>T</code> be the declared parameter, <code>C</code> be the
    designated concept, and <code>Args...</code> be a  sequence of template
    arguments from a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>,
    possibly empty.

    If <code>C</code> is a variadic concept, then the associated constraint
    is a <cxx-grammarterm>template-id</cxx-grammarterm> of the form
    <code>C&lt;T..., Args...&gt;</code>. 

    Otherwise, if <code>C</code> is not a variadic concept, the associated
    constraint is a conjunction of sub-constraints
    <code>C&lt;T<i>i</i>, Args...&gt;</code> for each <code>T<i>i</i></code>
    in the parameter pack <code>T</code>.

    If <code>C</code> is a function concept, each introduced constraint or
    sub-constraint is adjusted to be a call expression of the form
    <code>C&lt;X, Args...&gt;()</code> where <code>X</code> is either
    the template parameter pack <code>T</code> or an element 
    <code>T<i>i</i></code>.
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename... Ts&gt; concept bool P = ...;
template&lt;typename T> concept bool U = ...;


template&lt;P... Xs&gt; void f4();   // requires P&lt;Xs...&gt;
template&lt;U... Args&gt; void f5(); // requires U&lt;Args0&gt; && U&lt;Args1&gt; && ... && U&lt;Argsn&gt;
    </cxx-codeblock>
    Here, <code>Args0</code>, <code>Args1</code>, etc. denote elements
    of the template argument pack <code>Args</code> used as part of the
    introduced constraint.
    </cxx-example>
    </p>
  </cxx-section>

  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    <h1>Template names</h1>

    <p>Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names"></cxx-ref>/7.</p>

    <p>If a <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm>template-arguments</cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    </cxx-note>
    </p>

    </cxx-note>
    </p>
  </cxx-section> <!-- temp.names -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      <p>Modify <cxx-ref in="cxx" to="temp.arg.template"></cxx-ref>.

      <p>A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      shall subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool X = has_x&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Y = X&lt;T&gt; && has_y&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Z = Y&lt;T&gt; && has_z&lt;T&gt;::value;

template&lt;template&lt;Y&gt; class C&gt;
  class temp { ... };

template&lt;X T&gt; class x;
template&lt;Z T&gt; class z;

temp&lt;x&gt; s1; // OK: X is subsumed by Y
temp&lt;z&gt; s2; // Error: Z subsumes Y
      </cxx-codeblock>
      The template <code>x</code> is a valid argument for <code>temp</code>
      because any template arguments satisfying <code>Y</code> will also 
      satisfy <code>X</code>. That is, all uses of <code>x</code> by
      <code>temp</code> should result in well-formed programs. The 
      template <code>y</code> is not valid because some template arguments 
      satisfying <code>Y</code> may not satisfy <code>Z</code>.
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->

  <cxx-section id="temp.decls">
    <h1>Template declarations</h1>

    <cxx-section id="temp.class">
      <h1>Class templates</h1>


      <p>Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.class"></cxx-ref>/3.</p>

      <p>When a member of a constrained class template is defined outside of 
      its class template definition, it shall be specified with the
      <cxx-grammarterm>template-parameters</cxx-grammarterm> and
      associated constraints of the class template.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Con = ...;

template&lt;typename T&gt; requires Con&lt;T&gt;
  struct S {
    void f();
    void g();
  }

template&lt;typename T&gt; 
  requires Con&lt;T&gt;
    void S&lt;T&gt;::f() { } // Ok: parameters and constraints match

template&lt;typename T&gt;
  void S&lt;T&gt;::g() { } // Error: no declaration of g() in S&lt;T&gt;
      </cxx-codeblock>
      </cxx-example>
      </p>


      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        <p>Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func"></cxx-ref>.
        
        <p>A member function of a class template whose declarator contains a
        <cxx-grammarterm>requires-clause</cxx-grammarterm> is a
        <dfn>constrained member function</dfn>.
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  class S {
    void f() requires C&lt;T&gt;();
  };
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>Constraints on member functions are instantiated as needed
        during overload resolution, not when the class template is
        instantiated
        (<cxx-ref in="cxx" to="temp.inst"></cxx-ref>).
        <cxx-note>
        Constraints on member functions do not affect the declared 
        interface of a class. That is, a constrained copy constructor 
        is still a copy constructor, even if it will not be viable for 
        a specialization of the class template.
        </cxx-note>
        </p>

        <p>A constrained member function of a class template may be defined
        outside of its class template definition. Its definition shall be
        specified with the constraints of its declaration.
        <cxx-example>
        Consider possible definitions of the constrained member function 
        <code>S&lt;T&gt;f</code> from above.
        <cxx-codeblock>
template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() { }                 // Error: no declaration of f() in S&lt;T&gt;.

template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() requires C&lt;T&gt;() { } // Ok: defines S&lt;T&gt;::f
        </cxx-codeblock>
        </cxx-example>
        </p>

      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      <p>Insert the following paragraph after
      <cxx-ref in="cxx" to="temp.mem"></cxx-ref>/1.</p>

      <p>A constrained member template defined outside of its class template 
      definition shall be specified with the
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      and constraints of the class template followed by
      the template parameters and constraints of the member template.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Foo = ...;
template&lt;typename T&gt; concept bool Bar = ...; // Different than Foo

template&lt;Foo T&gt;
  struct S {
    template&lt;Bar U&gt; void f(U);
    template&lt;Bar U&gt; void g(U);
  };

template&lt;Foo T&gt; template&lt;Bar U&gt; void S&lt;T&gt;::f(U); // Ok
template&lt;Foo T&gt; template&lt;Foo U&gt; void S&lt;T&gt;::g(U); // Error: no g() declared in S
      </cxx-codeblock>
      The template constraints in the definition of <code>g</code> do not
      match those in its declaration.
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.mem -->


    <cxx-section id="temp.friend">
      <h1>Friends</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend"></cxx-ref>/9.

      <p> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };
      </cxx-codeblock>
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
      </cxx-example>
      </p>

      <p>
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    </cxx-section> <!-- temp.firend -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.spec.match"></cxx-ref>/2.</p>

        <p> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.</p>

      </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.order"></cxx-ref>/1.</p>

        <p>
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B
        </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        </cxx-example>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.deduct">
        <h1>Template argument deduction</h1>

        <p>Immediately after
        <cxx-ref in="cxx" to="temp.deduct"></cxx-ref>/5, add the following
        paragraph:</p>

        <p>If the template has associated constraints, the template arguments
        are substituted into those associated constraints and evaluated.
        If the substitution results in an invalid type or expression, or
        if the associated constraints evaluate to <code>false</code>,
        type deduction fails.</p>

      </cxx-section> <!-- temp.deduct -->

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link"></cxx-ref>/6.</p>

        <p>
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"></cxx-ref>.
        </p>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link">/6.</cxx-ref>

        <p>
        Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.func.order"></cxx-ref>/2.</p>

        <p>
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->
    </cxx-section> <!-- temp.fct -->
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.spec">
    <h1>Template instantiation and specialization</h1>

    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      <p>Insert the following paragraph after 
      <cxx-ref in="cxx" to="temp.inst"></cxx-ref>/1.</p>

      <p>The implicit instantiation of a class template does not cause
      the instantiation of the associated constraints of constrained member 
      functions.</p>
    </cxx-section> <!-- temp.inst -->

    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      <p>Insert the following paragraph under 
      <cxx-ref in="cxx" to="temp.explicit"></cxx-ref>.</p>

      <p>An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); };

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.explicit -->

    <cxx-section id="temp.expl.spec">
      <h1>Explicit specialization</h1>

      <p>Insert the following paragraphs under 
      <cxx-ref in="cxx" to="temp.expl.spec"></cxx-ref>.</p>

      <p>A constrained template declaration or constrained member function
      of a class template can be declared by a declaration
      introduced by <code>template&lt;&gt;</code>.</p>

      <p>The <cxx-grammarterm>template arguments</cxx-grammarterm> of a
      <cxx-grammarterm>simple-template-id</cxx-grammarterm> that
      names an explicit specialization of a constrained template
      declaration must satisfy that template's associated constraints
      (<cxx-ref to="temp"></cxx-ref>).
      <cxx-example class="inline">
      <code>C</code> is the type concept defined in the previous
      section.
      <cxx-codeblock>
template&lt;C T&gt;
  struct S1 { };

struct X { void c(); }

template&lt;&gt; S1&lt;X&gt; { };   // OK: X satisfies C
template&lt;&gt; S1&lt;int&gt; { }; // Error: int does not satisfy C
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>An explicit specialization of a constrained member function
      (<cxx-ref to="temp.mem.func"></cxx-ref>) shall not include a
      a <cxx-grammarterm>requires-clause</cxx-grammarterm>.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S2 { 
    void f(T) requires C&lt;T&gt;;
  };

template&lt;&gt; void S2&lt;X&gt;::f(T a) { }               // OK
template&lt;&gt; void S2&lt;X&gt;::f(T a) requires C&lt;X&gt; { } // Error: extra requires-clause
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.expl.spec -->
  </cxx-section> <!-- temp.spec -->


  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    <p>Add this as a new section under 
    <cxx-ref in="cxx" to="temp">"</cxx-ref>.</p>


    <p>Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
      <bnf-rule>constraint-expression</bnf-rule>
        <bnf-alt>logical-or-expression</bnf-alt>
    </bnf-grammar>

    <p>A <cxx-grammarterm>logical-or-expression</cxx-grammarterm> is a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    <ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note>
    A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    </cxx-note>
    <!-- </p> -->

    <p>A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm>constraint-expression</cxx-grammarterm>
    is required is ill-formed.</p>

    <p>
    <cxx-example>
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P && Q
P || (Q && R)
M == N              // only if the result type is bool
has_trait&lt;T&gt;::value // only if value is a bool member
M < N               // only if the result type is bool
M + N >= 0
P || !(M < N)
true
false
    </cxx-codeblock>
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    </cxx-example>
    </p>

    <p>A subexpression of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this section.</p>

    <p>Certain subexpressions of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    <ul>
    <li>a <cxx-grammarterm>logical-or-expression</cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm>logical-and-expression</cxx-grammarterm> of the form
        <code>P && Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm>requires-expression</cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm>requires-clause</cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    <cxx-codeblock>
has_trait&lt;T&gt;::value
M < N
M + N >= 0
true
false
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>A concept check is not an atomic expression.
    </cxx-note>
    <!-- </p> -->

    <p>Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm>requires-expression</cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note>
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    </cxx-note>
    </p>

    <p>A concept check that calls a function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable concepts is simplified by substituting the template arguments into the variable's initializer. </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm>requirement</cxx-grammarterm>s its 
    <cxx-grammarterm>requirement-list</cxx-grammarterm>.
    <cxx-note>
    Certain atomic constraints introduced by a 
    <cxx-grammarterm>requirement</cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    </cxx-note>
    </p>
 
    <p>
    <cxx-example>
    Let <code>P</code> and </code>Q</code> be variable templates
    that are atomic constraints.
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();
    </cxx-codeblock>
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */
</cxx-codeblock>
    </cxx-example>
    </p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p>A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p>
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p>Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  </cxx-section> <!-- temp.constr -->

</cxx-clause> <!-- temp -->
