
<cxx-clause id="temp" number="14">
  <h1>Templates</h1>

  Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p number="1" class="quoted">
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        declaration
      </bnf-alt>
      <ins>
      <bnf-alt>template-introduction declaration</bnf-alt>
      </ins>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>
    </ins>
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after paragraph 6.

  <p number="7" class="quoted"> 
  A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <cxx-grammarterm>template-introduction</cxx-grammarterm>
  (<cxx-ref to="temp.intro"></cxx-ref>).
  </p>


  <p class="quoted">
  The <dfn>associated constraints</dfn> of a 
  <cxx-grammarterm>template-declaration</cxx-grammarterm> are the 
  logical <code>&&</code> of all 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm>s introduced by:
  </p>
  
  <div class="quoted">
  <ul>
  <li> a concept introduction, and</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>, and</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>)
  in the declaration's <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,
  and </li>

  <li> any <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
  a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"></cxx-ref>), and</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> appearing after
  the <cxx-grammarterm>declarator</cxx-grammarterm> of an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).</li>
  </ul>

  Let <code>T1</code> be a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  with associated constraints. <code>T1</code> is equivalent to another
  <cxx-grammarterm>template-declaration</cxx-grammarterm> (call it <code>T2</code>) 
  whose template parameters are declared explicitly as unconstrained template 
  parameters, and <code>T2</code> has a single
  <cxx-grammarterm>requires-clause</cxx-grammarterm> whose 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T1</code> 
  (<cxx-ref to="temp.constr.expr"></cxx-ref>). <code>T2</code> is said
  to be the <dfn>canonical declaration</dfn> of all declarations that are 
  equivalent to it according to the rules below.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);
  </cxx-codeblock>
  The last declaration is the canonical declaration of <code>g(T)</code>.
  </cxx-example>
  </div>

  <p class="quoted" number="8"> 
  When a <cxx-grammarterm>template-declaration</cxx-grammarterm> is
  declared by a template introduction (<cxx-ref to="temp.intro"></cxx-ref>), 
  its canonical declaration is a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> whose
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> is defined 
  according to the rules for introducing template parameters in
  <cxx-ref to="temp.intro"></cxx-ref>, and the 
  equivalent declaration has a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  formed as follows.

  Let <code>TT</code> be a <cxx-grammarterm>template-id</cxx-grammarterm>
  formed as 
  <code>C&lt;I<i>1</i>, I<i>2</i>, ..., I<i>n</i>, D<i>1</i>, D<i>2</i>, ..., D<i>n</i>&gt;</code>
  where <code>C</code> is the name of the designated concept,
  <code>I<i>1</i>, I<i>2</i>, ..., I<i>n</i></code> is the sequence
  of introduced template parameters, and
  <code>D<i>1</i>, D<i>2</i>, ..., D<i>n</i></code> is the (possibly empty)
  sequence of instantiated default template arguments needed to form the
  <cxx-grammarterm>template-id</cxx-grammarterm> that refers to <code>C</code>.

  If an introduced parameter declares a template parameter pack, the
  corresponding template argument in the <code>TT</code> is a pack
  expansion (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>).
  
  If <code>C</code> is a variable concept, then the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  the <cxx-grammarterm>id-expression</cxx-grammarterm> <code>TT</code>.
  
  If <code>C</code> is a function concept, then the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  the function call <code>TT()</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt; // <i>constraint associated by</i> C4{...Qs}
    void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p class="quoted">
  When a <cxx-grammarterm>template-declaration</cxx-grammarterm> (call it <code>T1</code>) is
  explicitly declared with <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>), 
  its canonical declaration is a 
  <cxx-grammarterm>template-declaration</cxx-grammarterm> (call it <code>T2</code>)
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"></cxx-ref>).
  
  The declaration, <code>T2</code>, has a <cxx-grammarterm>requires-clause</cxx-grammarterm>
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is the
  conjunction of the <cxx-grammarterm>constraint-expressoin</cxx-grammarterm>s 
  associated by the constrained template parameters in <code>T1</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration <code>T1</code> includes a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm>, its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>T2</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"></cxx-ref>. The associated constraints of the
  abbreviated function are evaluated in the order in which they appear.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  An abbreviated function can also be declared as a
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in the
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> and the
  following <cxx-grammarterm>requires-clause</cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  A <dfn>trailing <cxx-grammarterm>requires-clause</cxx-grammarterm></dfn> 
  is a <cxx-grammarterm>requires-clause</cxx-grammarterm> that appears after
  the <cxx-grammarterm>declarator</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).

  When a constrained function template or member function template is
  declared with a trailing <cxx-grammarterm>requires-clause</cxx-grammarterm>
  it is equivalent to a declaration in which the 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of the
  trailing <cxx-grammarterm>requires-clause</cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)
  </cxx-codeblock>
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  </cxx-example>
  </p>

  <!-- FIXME: Does this need to go somewhere? Notes refer to it as 
       redundant. -->
  <!--  
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p> 
  -->


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/1 in order
    to allow constrained template parameters.

    <p number="1" class="quoted">

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <del><bnf-alt>parameter-declaration</bnf-alt></del>
        <ins><bnf-alt>non-type-or-constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>non-type-or-constrained-parameter</bnf-rule>
        <bnf-alt>basic-parameter-declaration</bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> type-id
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> id-expression
        </bnf-alt>
      </ins>
    </bnf-grammar>
    </p>
    
    Update the wording in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/2 as 
    follows.

    <p number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm>template-parameter</cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm>unqualified-id</cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm>qualified-id</cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm>parameter-declaration</cxx-grammarterm></del>
    <ins><cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm></ins>. 
    </p>

    Insert the following paragraphs after paragraph 3 in order to distinguish
    between a template parameter that declares a non-type parameter and a
    template-parameter that declares a constrained parameter, which may
    declare a type parameter. 

    <p number="3" class="quoted">
    When a <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm> has
    the following form:
    <bnf-grammar>
    <bnf-alt>
    constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt>
    </bnf-alt>
    </bnf-grammar>
    it declares a <dfn>constrained template parameter</dfn>.

    Otherwise the parameter is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.
    </p>

    <p class="quoted">
    If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
    appears in the the parameter type of a
    <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm>,
    the program is ill-formed. The program is also ill-formed if a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> appears
    anywhere in the <cxx-grammarterm>basic-parameter-declaration</cxx-grammarterm> 
    and the form of that declaration does not match the form above.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S1;       // <i>OK:</i> T <i>is a constrained template parameter</i>
template&lt;int N&gt; struct S2;     // <i>OK:</i> N <i>is a non-type template parameter</i>
template&lt;auto X&gt; struct S2;    // <i>error: auto in template parameter</i>
template&lt;const D N&gt; void f1(); // <i>error:</i> D <i>is used with a const-qualifier</i>
template&lt;D* N&gt; void f2();      // <i>error:</i> N <i>declares a pointer-to-</i>D
    </cxx-codeblock>
    </cxx-example>
    </p>

    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.

    <p number="9" class="quoted">
    A constrained template parameter declares a template parameter whose
    type and form match that of the prototype parameter of the concept 
    designated by its <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
    The designated concept is found using the rules in
    <cxx-ref to="dcl.spec.constr"></cxx-ref>. 

    Let <code>I</code> be the <cxx-grammarterm>declarator-id</cxx-grammarterm>
    of the <cxx-grammarterm>basic-parameter-declaration</cxx-grammarterm>,
    and let <code>P</code> be the prototype parameter of the designated
    concept. The declared template parameter is determined by the type
    and form of <code>P</code> and the <cxx-grammarterm>identifier</cxx-grammarterm>
    and optional ellipsis in <code>I</code>.
    </p>
    
    <div class="quoted">
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> declared with
    the <code>class</code> or <code>typename</code>, the declared parameter is 
    a type <cxx-grammarterm>template-parameter</cxx-grammarterm>. </li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, the declared
    parameter is a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same type as <code>P</code>. </li>

    <li> If <code>P</code> is a template 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, the declared
    parameter is a template <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
    as <code>P</code>. </li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>I</code> shall include an ellipsis, and the declared parameter
    is a template parameter pack. </li>
    </ul>

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error:</i> Ts <i>must be preceded by an ellipsis</i>
template&lt;C5... Cs&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i>
    </cxx-codeblock>
    </cxx-example>
    </div>
  </cxx-section> <!-- temp.param -->


  <!-- ===================================
       Introduction of template parameters
       =================================== -->

  <cxx-section id="temp.intro" number="2">
    <h1>Introduction of template parameters</h1>

    Add this section after <cxx-ref to="temp.param"></cxx-ref>.

    <p> A <dfn>template introduction</dfn> provides a convenient way of declaring
    different templates that have the same template parameters and constraints.

    <bnf-grammar>
      <bnf-rule>template-introduction</bnf-rule>
        <bnf-alt>
          <bnf-opt>nested-name-specifier</bnf-opt>
          concept-name
          <bnf-terminal>{</bnf-terminal> introduction-list <bnf-terminal>}</bnf-terminal>
        </bnf-alt>

      <bnf-rule>introduction-list</bnf-rule>
        <bnf-alt>introduced-parameter</bnf-alt>
        <bnf-alt>introduction-list<bnf-terminal>,</bnf-terminal> introduced-parameter</bnf-alt>

        <bnf-rule>introduced-parameter</bnf-rule>
          <bnf-alt><bnf-opt><bnf-terminal>...</bnf-terminal></bnf-opt> identifier</bnf-alt>
      </ins>
    </bnf-grammar>

    A template introduction declares a sequence of 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>s, which are derived 
    from a <cxx-grammarterm>concept-name</cxx-grammarterm>
    and the sequence of <cxx-grammarterm>identifier</cxx-grammarterm>s in 
    its <cxx-grammarterm>introduction-list</cxx-grammarterm>.


    <!-- FIXME: This is grorss... -->
    <p> The concept designated by the <cxx-grammarterm>concept-name</cxx-grammarterm>
    (call it <code>C</code>) is determined by the 
    <cxx-grammarterm>introduction-list</cxx-grammarterm>.

    The <cxx-grammarterm>concept-name</cxx-grammarterm> <code>C</code> 
    refers to a set of concept definitions. A concept <code>CC</code> in
    that set is viable if <code>CC</code> declares at least as many template 
    parameters as there are <cxx-grammarterm>identifier</cxx-grammarterm>s in 
    the <cxx-grammarterm>introduction-list</cxx-grammarterm>, and
    all template parameters in excess of the number of 
    <cxx-grammarterm>identifier</cxx-grammarterm>s are declared with default 
    template arguments.

    If only one concept in that set is viable, that is the concept
    designated by <code>C</code>. Otherwise, the program is ill-formed.

    <cxx-example class="inline">
    It is possible to overload function concepts in such a way that a
    <cxx-grammarterm>concept-name</cxx-grammarterm> can designate multiple
    concepts.
    <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i>
  </cxx-codeblock>
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of</i> C{X} <i>is ambiguous</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    For each 
    <cxx-grammarterm>introduced-parameter</cxx-grammarterm> <code>I</code> in an
    <cxx-grammarterm>introduction-list</cxx-grammarterm>,
    and for its corresponding template parameter in the 
    <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
    of the designated concept (call it <code>P</code>), declare a new template 
    parameter using the rules for declaring a constrained parameter in
    <cxx-ref to="temp.param"></cxx-ref> by using <code>I</code> as a
    <cxx-grammarterm>declarator-id</cxx-grammarterm> and <code>P</code>
    as the prototype parameter.

    However, if <code>I</code> contains an ellipsis, <code>P</code> shall
    declare a template parameter pack.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;

C1{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;    // B <i>is declared as</i> int B
               // C <i>is declared as</i> typename... C

C1{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

C2{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

C2{...X}      // <i>error: the corresponding parameter is not a</i> 
  void bar(); // <i>template parameter pack</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    <cxx-note>
    A concept referred to by a <cxx-grammarterm>concept-name</cxx-grammarterm> 
    may have template parameters with default template arguments. An
    <cxx-grammarterm>introduction-list</cxx-grammarterm> may omit 
    <cxx-grammarterm>identifier</cxx-grammarterm>s for a corresponding template
    parameter if it has a default argument. However, only the
    <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s are declared
    as template parameters. 
    
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename A, typename B = bool&gt; 
  concept bool C() { return true; }

C{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                // <i>a single template type parameter</i> T
  </cxx-codeblock>
  There is no <cxx-grammarterm>introduced-parameter</cxx-grammarterm> 
  that corresponds to the template parameter <code>B</code> in the
  <code>C</code> concept, so <code>f(T)</code> is declared with only
  one template parameter.
    </cxx-example>
    </cxx-note>
    </p>


    <p> An introduced template parameter does not have a default template 
    argument even if its corresponding template parameter does.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p> 
    <cxx-note>
    The introduction of a sequence of template parameters by a
    <cxx-grammarterm>concept-name</cxx-grammarterm> associates a constraint 
    with the <cxx-grammarterm>template-declaration</cxx-grammarterm>
    according to the rules describe in <cxx-ref to="temp"></cxx-ref>.
    </cxx-note>
    </p>

  </cxx-section> <!-- temp.intro -->


  <!-- =================================
       Names of template specializations
       ================================= -->

  <cxx-section id="temp.names">
    <h1>Names of template specializations</h1>


    Add the following paragraph to require the implicit instantiation
    of default template arguments for non-function templates.

    <p number="8" class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> does 
    not name a function, a default 
    <cxx-grammarterm>template-argument</cxx-grammarterm> is implicitly
    instantiated (<cxx-ref to="temp.inst"></cxx-ref>) in a context that 
    requires the value of that default argument.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, typename U = int&gt; struct S { };

S&lt;bool&gt;* p; // <i>the type of</i> p <i>i</i>s S&lt;bool, int&gt;*
    </cxx-codeblock>
    The default argument for <code>U</code> is instantiated to form
    the type <code>S&lt;bool, int&gt;*</code>, but the definition of that
    class template specialization is not implicitly instantiated
    (<cxx-ref to="temp.inst"></cxx-ref>); it is not used in a 
    context that requires a complete type.
    </cxx-example>
    </p>

    Add this paragraph to require the satisfaction of associated constraints
    on the formation of the <cxx-grammarterm>simple-template-id</cxx-grammarterm>.

    <p class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> names
    a constrained class template, variable template or alias template,
    and all <cxx-grammarterm>template-argument</cxx-grammarterm>s in the
    <cxx-grammarterm>template-id</cxx-grammarterm> are non-dependent,
    (<cxx-ref in="cxx" to="temp.nondep"></cxx-ref>), the associated constraints
    are checked against those
    <cxx-grammarterm>template-argument</cxx-grammarterm>s
    (<cxx-ref to="temp.constr"></cxx-ref>). If, as a result of checking,
    the associated constraints are not satisfied, the program is ill-formed.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename C&gt; = false;

template&lt;C T&gt; struct S { };
template&lt; T&gt; using Ptr = T*;

S&lt;int&gt;* p;  // <i>error: constraints not satisfied</i>
Ptr&lt;int&gt; p; // <i>error: constraints not satisfied</i>
    </cxx-codeblock>
    </cxx-example>
    </p>


  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      Modify paragraph 3 to include rules for matching constrained template 
      <cxx-grammarterm>template parameter</cxx-grammarterm>s. Note that the 
      examples following this paragraph in
      the original document are omitted.

      <p number="3" class="quoted">
      A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and <code>P</code> is more constrained than
       <code>A</code> according to the rules in 
       <cxx-ref to="temp.constr"></cxx-ref></ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"></cxx-ref>), and 
      for template <cxx-grammarterm>template-parameter</cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s matches, recursively. 

      When <code>P</code>’s <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <p number="3" class="quoted">
      <div class="quoted">
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; && requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z
      </cxx-codeblock>
      </cxx-example>
      </div>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    <h1>Template declarations</h1>


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
      <h1>Class templates</h1>

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. Note that the example
      in the original document is omitted. The example in this paragraph
      is to be added after the omitted example.

      <p number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;C T&gt; void S&lt;T&gt;::f() { }        // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; 
  template&lt;D U&gt; struct S&lt;T&gt;::Inner { }; // <i>OK</i>
      </cxx-codeblock>
      The declaration of <code>S&lt;T&gt;::g()</code> does not match because
      it does not have the associated constraints of <code>S</code>.
      </cxx-example>
      </p>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        Add the following example to the end of paragraph 1.

        <p number="1" class="quoted">
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g() { }               // <i>error: no matching function in</i> S&lt;T&gt;
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->

    <!-- ================
         Member templates
         ================ -->

    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. Add the example in this
      document after the example in the original document, which is omitted
      here.

      <p number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) &lt;= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;C2 U&gt; 
  void S&lt;T&gt;::f(U) { } // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U) { } // <i>error: no matching function in</i> S&lt;T&gt;
      </cxx-codeblock>
      The associated constraints in the definition of <code>g()</code> do not
      match those in of its declaration.
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ -->

    <cxx-section id="temp.friend" number="4">
      <h1>Friends</h1>


      Add the following paragraphs to explain the meaning of constrained
      friend declarations. 

      <p number="10" class="quoted">
      A friend function template may be constrained, except:
      </p>
      <div class="quoted">
      <ul>
      <li> if the friend declares, but does not define, a non-template
      function to be a friend of a class template, the associated constraints
      of that friend function declaration shall be non-dependent
      (<cxx-ref in="cxx" to="temp.nondep"></cxx-ref>); </li>

      <li> if the friend declares a function template specialization to
      be a friend of a class template, the declaration shall not have
      associated constraints, and the template arguments of that specialization
      shall satisfy the associated constraints of the template referred to
      by the friend declaration (<cxx-ref to="temp.deduct.decl"></cxx-ref>). </li>
      </ul>

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = false;

template&lt;C1 T&gt; g1(T);
template&lt;C2 T&gt; g2(T);

template&lt;typename T&gt;
  struct S {
    void f1() requires true;  // <i>OK</i>
    void f2() requires C1&lt;T&gt;; // <i>error: constraints refer to</i> T
    void g1&lt;T&gt;(T);            // <i>OK</i>
    void g2&lt;T&gt;(T);            // <i>error: constraints not satisfied</i>
  };
      </cxx-codeblock>
      </cxx-example>
      </div>

      <p>
      <cxx-note>
      Within a class template, a friend may define a non-template function
      whose constraints specify requirements on template arguments.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq = requires (T t) { t == t; };

template&lt;typename T&gt;
  strut S {
    bool operator==(S a, S b) requires Eq&lt;T&gt; { return a == b; } // OK
  };
      </cxx-codeblock>
      </cxx-example>
      In the instantiation of such a class template, the template
      arguments are substituted into the constraints but not evaluated.
      Constraints are checked (<cxx-ref to="temp.constr"></cxx-ref>) only when
      that function is considered as a viable candidate for overload resolution
      (<cxx-ref to="over.match.viable"></cxx-ref>).
      </cxx-note>
      </p>

    </cxx-section> <!-- temp.friend -->



    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p number="4" class="quoted">
      A class template partial specialization may be constrained
      (<cxx-ref to="temp"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool N = N &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      Modify the 3rd item in the list of paragraph 8 to allow 
      constrained class template partial specializations like #6.
      Note that all other items in that list are elided. 

      <p number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      <ul>
      <li>...</li>
      <li><ins>In an unconstrained class template partial specialization,</ins>
      <del>The</del><ins>the</ins> argument list of the specialization shall
      not be identical to the implicit argument list of the primary template.
      <li>...</li>
      </ul>


      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. Add the example given here
        to the (omitted) example in the original document.

        <p number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.
        <cxx-example class="inline">
        <cxx-codeblock>
struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i>
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. Add the
        example at the end of this paragraph to the (omitted) example
        in the original document.

        <p number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <div class="quoted">
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i>
        </cxx-codeblock>
        The partial specialization #2 is be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        </cxx-example>
        </div>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        Modify paragraph 6 to account for constraints on function
        templates.

        <p number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        </p>
        <div class="quoted">
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they are:
        <ul>
        <li> declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints that are equivalent using the rules 
             in <cxx-ref to="temp.constr.expr"></cxx-ref> to
             compare <cxx-grammarterm>constraint-expression</cxx-grammarterm>s.</li>
        </ul>
        </ins>
        </div>

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that <del>one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters</del>
        <ins>
        <ul> 
        <li>one or more expressions that involve template parameters in the 
        return types and parameter lists are functionally equivalent using 
        the rules described above to compare expressions involving template 
        parameters, or if not that, </li>

        <li> both function templates have associated constraints that are
        functionally equivalent but not equivalent, using the rules in 
        <cxx-ref to="temp.constr.expr"></cxx-ref> to compare 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>s.</li>
        </ul>
        </ins>
        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by the rules in
        <cxx-ref to="temp.constr.order"></cxx-ref>.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->

    </cxx-section> <!-- temp.fct -->

  </cxx-section> <!-- temp.decls -->


  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    <h1>Template instantiation and specialization</h1>


    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p number="2" class="quoted">
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <cxx-note>
      The evaluation of constraints happens during lookup or overload
      resolution (<cxx-ref to="over"></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"></cxx-ref>.
      </cxx-note>

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C<T> && sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { } // <i>#1</i>
  S() requires D&lt;T&gt; { } // <i>#2</i>
};

S&lt;char&gt; s1;    // <i>error: no matching constructor</i>
S&lt;char[8]&gt; s2; // <i>OK: calls #2</i>

      </cxx-codeblock>
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors, 
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization. This also
      has the effect of suppressing the implicit generation of a default 
      constructor (<cxx-ref in="cxx" to="class.ctor"></cxx-ref>).

      <cxx-codeblock>
template&lt;typename T&gt; struct S2 {
    void f() requires T::value == 1;
  };

S2&lt;int&gt; s; // <i>error: substitution failure in definition of</i> S2&lt;int&gt;
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.inst -->


    <!-- ======================
         Explicit instantiation
         ====================== -->

    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      Add the following paragraphs to this section. These require an explicit
      instantiation of a constrained template to satisfy the template's
      associated constraints.

      <p number="14" class="quoted">
      If the explicit instantiation names a class template specialization
      or variable template specialization of a constrained template, then
      the <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of the explicit
      instantiation shall satisfy the template's associated constraints
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template S&lt;char&gt;;    // <i>OK</i>
template S&lt;char[2]&gt;; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>

      <p class="quoted">
      When an explicit instantiation refers to a specialization of a
      function template (<cxx-ref to="temp.deduct.decl"></cxx-ref>), that 
      template's associated constraints shall be satisfied by the template 
      arguments of the explicit instantiation.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T) { } // <i>#1</i>
template&lt;typename T&gt; void g(T) { } // <i>#2</i>
template&lt;C T&gt;        void g(T) { } // <i>#3</i>

template void f(int);   // <i>OK: refers to #1</i>
template void f(void*); // <i>error: no matching template</i>
template void g(int);   // <i>OK: refers to #3</i>
template void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.explicit -->


    <!-- =======================
         Explicit specialization
         ======================= -->

    <cxx-section id="temp.expl.spec">
      <h1>Explicit specialization</h1>

      Insert the following paragraphs after paragraph 12. These require
      an explicit specialization to satisfy the constraints of the primary
      template.

      <p number="12" class="quoted">
      The <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of an explicit 
      specialization of a constrained class template or
      constrained variable template shall satisfy the associated constraints
      of that template, if any (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template&lt;&gt; S&lt;char&gt; { };    // <i>OK</i>
template&lt;&gt; S&lt;char[2]&gt; { }; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p class="quoted">
      When determining the function template referred to by an explicit 
      specialization of a function template 
      (<cxx-ref to="temp.deduct.decl"></cxx-ref>),
      the associated constraints of that template (if any) shall be satisfied 
      (<cxx-ref to="temp.constr"></cxx-ref>) by the
      template arguments of the explicit specialization.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;C T&gt;        void f(T); // <i>#1</i>
template&lt;typename T&gt; void g(T); // <i>#2</i>
template&lt;C T&gt;        void g(T); // <i>#3</i>

template&lt;&gt; void f(int);   // <i>OK: refers to #1</i>
template&lt;&gt; void f(void*); // <i>error: no matching template</i>
template&lt;&gt; void g(int);   // <i>OK: refers to #3</i>
template&lt;&gt; void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.expl.spec -->
  </cxx-section> <!-- temp.spec -->


  <!-- =================================
       Function template specializations
       ================================= -->

  <cxx-section id="temp.fct.spec" number="8">
    <h1>Function template specializations</h1>

    <cxx-section id="temp.deduct" number="2">
      <h1>Template argument deduction</h1>

      Add the following sentences to the end of paragraph 5. This defines
      the substitution of template arguments into a function template's
      associated constraints. Note that the last part of paragraph 5
      has been duplicated in order to provide context for the addition.

      <p number="5" class="quoted">
      When all template arguments have been deduced or obtained from default 
      template arguments, all uses of template parameters in the template 
      parameter list of the template and the function type are replaced with
      the corresponding deduced or default argument values. 

      If the substitution results in an invalid type, as described above, type 
      deduction fails.

      <ins>
      If the function template has associated constraints
      (<cxx-ref to="temp"></cxx-ref>),
      the template arguments are substituted into the constraints without 
      evaluating the resulting expression. If this substitution results in an 
      invalid type, then the resulting expression is defined to be 
      <code>false</code>.

      The resulting constraints are associated with the function template
      specialization.

      <cxx-note>
      The constraints associated with the function template specialization
      are checked (<cxx-ref to="temp.constr"></cxx-ref>) in order to determine 
      if the specialization is a viable candidate 
      (<cxx-ref to="over.match.viable"></cxx-ref>), and not at the point
      of substitution.
      </cxx-note>
      </ins>
      </p>

      <cxx-section id="temp.deduct.decl" number="6">
        <h1>Deducing template arguments from a function declaration</h1>

        Add the following after paragraph 1 in order to require the
        satisfaction of constraints when matching a specialization to a
        template.

        <p number="2" class="quoted">
        Remove, from the set of function templates considered, all those
        whose associated constraints (if any) are not satisfied by the deduced
        template arguments (<cxx-ref to="temp.constr"></cxx-ref>).
        </p>

        Update paragraph 2 (now paragraph 3) to accommodate the new
        wording.

        <p class="quoted">
        If, 
        <del>for the set of function templates so considered</del>
        <ins>for the remaining function templates</ins>,
        there is either no match or more than one match after partial ordering 
        has been considered (<cxx-ref to="temp.func.order"></cxx-ref>), deduction fails 
        and, in the declaration cases, the program is ill-formed.
        </p>
      </cxx-section> <!-- temp.deduct.decl -->

    </cxx-section> <!-- temp.deduct -->

  </cxx-section> <!-- temp.fct.spec -->


  <!-- ====================
       Template constraints
       ==================== -->

  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    Add this section after 14.8.

    <p>
    <cxx-note>
    This section defines the meaning of constraints on template arguments, including
    the translation of <cxx-grammarterm>constraint-expression</cxx-grammarterm>s
    into constraints by normalization (<cxx-ref to="temp.constr.expr"></cxx-ref>),
    and the abstract syntax, satisfaction, and subsumption of those constraints
    (<cxx-ref to="temp.constr.op"></cxx-ref>, <cxx-ref to="temp.constr.atom"></cxx-ref>).
    </cxx-note>
    </p>

    <p> A <dfn>constraint</dfn> is a sequence of logical operators and 
    operands that specifies requirements on template arguments. </p>

    <p>
    <dfn>Constraint checking</dfn> is the processing of substituting 
    non-dependent template arguments (<cxx-ref in="cxx" to="temp.nondep"></cxx-ref>) 
    into a constraint for the purpose of determining if the constraint
    is satisfied.

    After substitution, a constraint is <dfn>satisfied</dfn> if and only if 
    all of its sub-constraints are satisfied according to the evaluation 
    rules described in
    <cxx-ref to="temp.constr.op"></cxx-ref> and
    <cxx-ref to="temp.constr.atom"></cxx-ref>.

    If the substitution of template arguments into a constraint fails, 
    that constraint is not satisfied.

    <cxx-note>
    Substitution into a constraint may yield a well-formed constraint that
    contains ill-formed expressions or types. This may happen, for
    example, in the implicit instantiation of a class template
    specialization (<cxx-ref to="temp.inst"></cxx-ref>).
    </cxx-note>
    </p>

    <p> A constraint <code>P</code> is said to <dfn>subsume</dfn> another
    constraint <code>Q</code> if, informally, it can be determine that
    <code>P</code> implies <code>Q</code>, up to the equivalence of
    expressions and types in <code>P</code> and <code>Q</code>.
    
    <cxx-note>
    Subsumption does not determine, for example, if the predicate 
    constraint (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>) 
    <code>N % 2 == 1</code> subsumes <code>N &amp; 1</code> for 
    some integral template argument, <code>N</code>. 
    </cxx-note>
    The rules defining the subsumption relation are given for each kind
    of constraint in
    <cxx-ref to="temp.constr.op"></cxx-ref> and
    <cxx-ref to="temp.constr.atom"></cxx-ref>.
    </p>

    <cxx-section id="temp.constr.op">
      <h1>Logical operators</h1>

      <p> There are two logical operators on constraints: conjunction
      and disjunction. </p>


        <!-- ===========
             Conjunction
             =========== -->

        <cxx-section id="temp.constr.op.conj">
          <h1>Conjunction</h1>

          <p> A <dfn>conjunction</dfn> is a logical operator taking two 
          operands. A conjunction of constraints is satisfied if and only 
          if both operands are satisfied. </p>

          <p> A conjunction of the constraints <code>P</code> 
          and <code>Q</code> subsumes another constraint <code>R</code>
          if and only if <code>P</code> subsumes <code>R</code>,
          <code>Q</code> subsumes <code>R</code>, or both subsume
          <code>R</code>.
          </p>
        </cxx-section> <!-- temp.constr.op.conj -->


        <!-- ===========
             Disjunction
             =========== -->

        <cxx-section id="temp.constr.op.disj">
          <h1>Disjunction</h1>

          <p> A <dfn>disjunction</dfn> is a logical operator taking two 
          operands. A disjunction of constraints is satisfied if and only 
          if either operand is satisfied or both operands are satisfied. </p>

          <p> A disjunction of the constraints <code>P</code> and <code>Q</code>
          subsumes another constraint <code>R</code> if and only if
          <code>P</code> subsumes <code>R</code> and <code>Q</code> subsumes
          <code>R</code>.
          </p>
        </cxx-section> <!-- temp.constr.op.disj -->

      </cxx-section> <!-- temp.constr.op -->

      <!-- =================
          Atomic constraints
          ================== -->

      <cxx-section id="temp.constr.atom">
        <h1>Atomic constraints</h1>

        <p> Any constraint that is not a conjunction or disjunction is an
        <dfn>atomic constraint</dfn>. </p>

        <p> An atomic constraint <code>P</code> subsumes a disjunction
        of the constraints <code>Q</code> and <code>R</code> if and only
        if <code>P</code> subsumes <code>Q</code>, <code>P</code>
        subsumes <code>R</code>, or both. </p>

        <p> An atomic constraint <code>P</code> subsumes a conjunction
        of the constraints <code>Q</code> and <code>R</code> if and only
        if <code>P</code> subsumes <code>Q</code> and <code>P</code>
        subsumes <code>R</code>.</p>

        <!-- =====================
             Predicate constraints
             ===================== -->

        <cxx-section id="temp.constr.atom.pred">
          <h1>Predicate constraints</h1>

          <p> A <dfn>predicate constraint</dfn> is an atomic constraint
          that evaluates a prvalue constant expression of type <code>bool</code>
          (<cxx-ref in="cxx" to="expr.const"></cxx-ref>).
          The constraint is satisfied if and only if the expression 
          evaluates to <code>true</code>.
          
          <cxx-note>
          Predicate constraints allow the definition of template requirements
          in terms of constant expressions. This enables constraints on non-type
          arguments, template template arguments, and also the definition of
          constraints as metaprograms on template arguments.
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 4 &amp;&amp; !true;
          </cxx-codeblock>
          Here, <code>sizeof(T) == 4</code> and <code>!true</code> are 
          predicate constraints required by the concept, <code>C</code>.
          </cxx-example>
          </p>

          <p>A predicate constraint <code>P</code> subsumes another
          predicate constraint <code>Q</code> if and only if
          <code>P</code> and <code>Q</code> are equivalent
          <cxx-grammarterm>constraint-expression</cxx-grammarterm>s
          (<cxx-ref to="temp.constr.expr"></cxx-ref>).

          <cxx-example class="inline">
          The predicate <code>M >= 0</code> does not subsume the predicate
          <code>M > 0</code> because they are not equivalent
          <cxx-grammarterm>constraint-expressions</cxx-grammarterm>.
          </cxx-example>
          </p>

        </cxx-section> <!-- temp.constr.atom.pred -->


        <!-- ======================
             Expression constraints
             ====================== -->

        <cxx-section id="temp.constr.atom.expr">
          <h1>Expression constraints</h1>

          <p> An <dfn>expression constraint</dfn> is an atomic constraint
          that specifies a requirement on the formation of an
          <cxx-grammarterm>expression</cxx-grammarterm> (call it <code>E</code>)
          through substitution of template arguments.

          An expression constraint is satisfied if <code>E</code> is non-dependent, 
          meaning that the substitution yielding <code>E</code> did not fail. 
          Within an expression constraint, <code>E</code> is an unevaluated 
          operand (<cxx-ref to="expr"></cxx-ref>).

          <cxx-note>
          An expression constraint is introduced by the 
          <cxx-grammarterm>expression</cxx-grammarterm> in either a
          <cxx-grammarterm>simple-requirement</cxx-grammarterm> 
          (<cxx-ref to="expr.prim.req.simple"></cxx-ref>)
          or
          <cxx-grammarterm>compound-requirement</cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>)
          of a
          <cxx-grammarterm>requires-expression</cxx-grammarterm>.
          </cxx-note>

          <cxx-example class="inline">
          The concept <code>C</code> introduces an expression constraint for 
          the expression <code>++t</code>.
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };
          </cxx-codeblock>
          The type argument <code>int</code> satisfies this constraint because the
          the expression <code>++t</code> is valid after substituting <code>int</code>
          for <code>T</code>.
          </cxx-example>
          </p>

          <p> An expression constraint <code>P</code> subsumes another
          expression constraint <code>Q</code> if and only if
          the <cxx-grammarterm>expression</cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.expr -->


        <!-- ================
             Type constraints
             ================ -->

        <cxx-section id="temp.constr.atom.type">
          <h1>Type constraints</h1>

          <p> A <dfn>type constraint</dfn> is an atomic constraint that
          specifies a requirement on the formation 
          of a type (call it <code>T</code>) through the substitution of
          template arguments

          A type constraint is satisfied if and only 
          <code>T</code> is non-dependent, meaning that the substitution 
          yielding <code>T</code> did not fail.

          <cxx-note>
          A type constraint is introduced by the 
          <cxx-grammarterm>typename-specifier</cxx-grammarterm> in a
          <cxx-grammarterm>type-requirement</cxx-grammarterm> of a
          <cxx-grammarterm>requires-expression</cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.type"></cxx-ref>).
          </cxx-note>

          <cxx-example example="inline">
          The concept <code>C</code> introduces a type constraint for the 
          type name <code>T::type</code>.
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = 
requires (T t) { 
  typename T::type;
};
          </cxx-codeblock>
          The type <code>int</code> does not satisfies this constraint 
          because substitution of that type into the constraint results in a
          substitution failure; <code>int::type</code> is ill-formed.
          </cxx-example>
          </p>

          <p> A type requirement that names a class template specialization 
          does not require that type to be complete 
          (<cxx-ref in="cxx" to="basic.types"></cxx-ref>). </p>

          <p> A type requirement <code>P</code> subsumes another type
          requirement <code>Q</code> if and only if the types in <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.type -->


        <!-- ===============================
             Implicit conversion constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.conv">
          <h1>Implicit conversion constraints</h1>

          <p> A <dfn>implicit conversion constraint</dfn> is an atomic
          constraint that specifies a requirement 
          on the implicit conversion of an 
          <cxx-grammarterm>expression</cxx-grammarterm>
          (call it <code>E</code>) to a 
          type (call it <code>T</code>). The constraint is satisfied if and 
          only if <code>E</code> is implicitly convertible to <code>T</code>
          (<cxx-ref in="cxx" to="conv"></cxx-ref>).
          
          <cxx-note>
          A conversion constraint is introduced by a
          <cxx-grammarterm>trailing-return-type</cxx-grammarterm> in a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> when
          its type contains no placeholders
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = 
requires (T a, T b) {
  { a == b } -> bool;
};
          </cxx-codeblock>
          The <cxx-grammarterm>compound-requirement</cxx-grammarterm> in the
          <cxx-grammarterm>requires-expression</cxx-grammarterm> of <code>C</code>
          introduces two atomic constraints: an expression constraint
          for <code>a == b</code> and the implicit conversion constraint that 
          the expression <code>a == b</code> is implicitly convertible to
          <code>bool</code>.
          </cxx-example>
          </p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          T1 is convertible to T2. -->

          <p> An implicit conversion constraint <code>P</code> subsumes 
          another implicit conversion constraint <code>Q</code> if and only if
          the <cxx-grammarterm>expression</cxx-grammarterm>s of 
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"></cxx-ref>) and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>).</p>

        </cxx-section> <!-- temp.constr.atom.conv -->


        <!-- ==============================
             Argument deduction constraints
             ============================== -->

        <cxx-section id="temp.constr.atom.deduct">
          <h1>Argument deduction constraints</h1>

          <p> An <dfn>argument deduction constraint</dfn> is an atomic
          constraint that specifies a requirement on 
          the usability of an <cxx-grammarterm>expression</cxx-grammarterm> 
          (call it <code>E</code>) as an argument to an invented 
          function template (call it <code>F</code>) that has a single 
          parameter whose type (call it <code>T</code>) is
          written in terms of <code>F</code>'s template parameters.

          The constraint is satisfied if and only if <code>F</code>
          is selected by overload resolution for the call <code>F(E)</code>
          (<cxx-ref to="over.match"></cxx-ref>).

          <cxx-note>
          Overload resolution selects <code>F</code> only when template 
          argument deduction succeeds and <code>F</code>'s associated 
          constraints are satisfied.
          </cxx-note>

          <cxx-note>
          An argument deduction constraint is introduced by a
          <cxx-grammarterm>trailing-return-type</cxx-grammarterm> in a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> when the
          <cxx-grammarterm>trailing-type-specifier-seq</cxx-grammarterm>
          contains at least one placeholder
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>

          <cxx-example>
          The concept <code>D</code> introduces an argument deduction 
          constraint for the expression <code>*t</code>.
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { ++t; }
template&lt;typename T&gt; concept bool D = requires (T t) { *t -> const C&amp;; }
          </cxx-codeblock>
          When determining if <code>D</code> is satisfied, overload resolution
          is performed for the call <code>g(*t)</code> against the following 
          invented function:
          <cxx-codeblock>
template&lt;typename T&gt; requires C&lt;T&gt; void g(const T&amp;);
          </cxx-codeblock>
          </cxx-example>
          </p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          f(T1) is more specialized than f(T2) where f is the corresponding
          invented function template. -->

          <p> An argument deduction constraint <code>P</code> subsumes
          another argument deduction constraint <code>Q</code> if and only
          if the <cxx-grammarterm>expression</cxx-grammarterm>s of
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"></cxx-ref>), and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.deduct -->


        <!-- ===============================
             Constant expression constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.constexpr">
          <h1>Constant expression constraints</h1>

          <p> A <dfn>constant expression constraint</dfn> is an atomic
          constraint that specifies a requirement that
          an <cxx-grammarterm>expression</cxx-grammarterm> (call it <code>E</code>) 
          can be evaluated during translation. The constraint is satisfied if 
          and only if <code>E</code> is a prvalue constant expression 
          (<cxx-ref in="cxx" to="expr.const"></cxx-ref>).

          <cxx-note>
          A constant expression constraint determines if an expression can be
          evaluated during translation for specific <code>constexpr</code>
          arguments. It cannot be used to determine if an expression is
          evaluated during translation for all possible arguments.
          </cxx-note>

          <cxx-note>
          Constant expression constraints are introduced by a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> that
          includes the <code>constexpr</code> specifier
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T, int N&gt; concept bool C = 
requires() {
  constexpr { T(N) }; // <i>determines if</i> T(N) <i>is a constant expression</i>
};
          </cxx-codeblock>
          </cxx-example>
          </p>

          <p> A constant expression constraint <code>P</code> subsumes
          another constant expression constraint <code>Q</code> if and
          only if the expressions of <code>P</code> and <code>Q</code>
          are equivalent (<cxx-ref to="temp.over.link"></cxx-ref>). </p>
        
        </cxx-section> <!-- temp.constr.atom.constexpr -->


        <!-- ===============================
             Exception constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.noexcept">
          <h1>Exception constraints</h1>

          <p> An <dfn>exception constraint</dfn> is an atomic constraint
          that specifies a requirement that an
          <cxx-grammarterm>expression</cxx-grammarterm> 
          (call it <code>E</code>) does not throw an exception.
          It is satisfied if and only if the expression 
          <code>noexcept(E)</code>
          is <code>true</code>
          (<cxx-ref in="cxx" to="expr.unary.noexcept"></cxx-ref>).
          
          <cxx-note>
          Constant expression constraints are introduced by a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> that
          includes the <code>noexcept</code> specifier
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>
          </p>

          <p> An exception constraint <code>P</code> subsumes another
          exception constraint <code>Q</code> if and only if the
          <cxx-grammarterm>expression</cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.noexcept -->

    </cxx-section> <!-- temp.constr.atom -->


    <!-- ===============================
         Partial ordering of constraints
         =============================== -->

    <cxx-section id="temp.constr.order">
      <h1>Partial ordering by constraints</h1>

      <p>The subsumption relation defines a partial ordering on constraints. 
      This partial ordering is used to determine </p>

      <ul>
      <li> the best viable candidate of non-template functions
           (<cxx-ref to="over.match.best"></cxx-ref>), </li>
      <li> the address of a non-template function
           (<cxx-ref to="over.over"></cxx-ref>), </li>
      <li> the matching of template template arguments
           (<cxx-ref to="temp.arg.template"></cxx-ref>).</li>
      <li> the partial ordering of class template specializations
           (<cxx-ref to="temp.class.order"></cxx-ref>), </li>
      <li> the partial ordering of function templates
           (<cxx-ref to="temp.func.order"></cxx-ref>), and </li>
      </ul>

      <p> When two declarations <code>D1</code> and <code>D2</code> are
      partially ordered by their constraints, <code>D1</code> is more
      constrained than <code>D2</code> if

      <ul>
      <li> <code>D1</code> and <code>D2</code> are both constrained
      declarations and <code>D1</code>'s associated constraints subsume but 
      are not subsumed by those of <code>D2</code>, or if not that, </li>

      <li> <code>D1</code> is constrained and <code>D2</code> is
      unconstrained. </li>
      </ul>

      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = requires(T t) { ++t; };
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt; &amp;&amp; requires(T t) { *t; };

template&lt;C1 T&gt; void f(T);       // <i>#1</i>
template&lt;C2 T&gt; void f(T);       // <i>#2</i>
template&lt;typename T&gt; void g(T); // <i>#3</i>
template&lt;C1 T&gt; void g();        // <i>#4</i>

f(0);       // <i>selects #1</i>
f((int*)0); // <i>selects #2</i>
g(true);    // <i>selects #3 because</i> C1&lt;bool&gt; <i>is not satisfied</i>
g(0);       // <i>selects #4</i>
      </cxx-codeblock>
      </cxx-example>

    </cxx-section> <!-- temp.constr.order -->



    <!-- ======================
         Constraint expressions
         ====================== -->

    <cxx-section id="temp.constr.expr">
      <h1>Constraint expressions</h1>

      <p>Certain contexts require expressions that can be transformed
      into constraints through the process of normalization.
      <bnf-grammar>
        <bnf-rule>constraint-expression</bnf-rule>
          <bnf-alt>logical-or-expression</bnf-alt>
      </bnf-grammar>
      </p>

      <p> A <cxx-grammarterm>constraint-expression</cxx-grammarterm>
      <code>E</code> is <dfn>normalized</dfn> by forming a constraint 
      (<cxx-ref to="temp.constr"></cxx-ref>) from
      <code>E</code> and its subexpressions.
      
      That transformation is defined as follows:

      <ul>
      <li> The normalization of an expression of the form <code>(P)</code> is
      the normalization of <code>P</code>.</li>

      <li> The normalization of an expression of the form <code>P || Q</code> is
      the disjunction of the normalization of <code>P</code> and the
      normalization of <code>Q</code>. 

      If, in the expression <code>P || Q</code>, lookup of <code>operator||</code> 
      finds a user-defined function, the program is ill-formed.</li>

      <li> The normalization of an expression of the form <code>P &amp;&amp; Q</code> is
      the conjunction of the normalization of <code>P</code> and the
      normalization of <code>Q</code>. 

      If, in the expression <code>P &amp;&amp; Q</code>, lookup of
      <code>operator&amp;&amp;</code> finds a user-defined function, the 
      program is ill-formed.</li>

      <li> The normalization of a function call of the form
      <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;()</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a function
      concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>) is defined as follows:

      Let <code>E</code> be the expression returned by the function concept 
      <code>C</code>, and let <code>S</code> be the result of substituting the
      template arguments into that expression. The resulting constraint is
      the normalization of <code>S</code>.</li>

      <li> The normalization of a <cxx-grammarterm>id-expression</cxx-grammarterm>
      of the form <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a variable
      concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>) is defined as follows:

      Let <code>E</code> be the initializer of the variable concept
      <code>C</code>, and let <code>S</code> be the result of substituting the
      template arguments into that expression. The resulting constraint is
      the normalization of <code>S</code>.</li>

      <li> The normalization of a 
      <cxx-grammarterm>requires-expression</cxx-grammarterm> is 
      defined to be the conjunction of constraints introduced by
      the body of that expression (<cxx-ref to="expr.prim.req"></cxx-ref>).
      </li>

      <li> Otherwise, <code>E</code> shall be a prvalue constant
      expression of type <code>bool</code>, and it denotes a
      predicate constraint (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>).
      </li>
      </ul>

      <cxx-note>
      A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
      defines a subset of constant expressions over which certain 
      logical implications can be deduced during translation.

      The prohibition against user-defined logical operators in intended to
      prevent the subversion of the underlying logic necessary partially
      order constraints (<cxx-ref to="temp.constr.order"></cxx-ref>).
      </cxx-note>

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1() { return sizeof(T) == 1; }
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt;() &amp;&amp; 1 == 2; }
template&lt;typename T&gt; concept bool C3 = requires () { typename T::type; };

// <i>Expression</i>      // <i>Constraints</i>
C2&lt;char&gt;           sizeof(char) == 1 /* <i>and</i> */ 1 == 2
C3&lt;int&gt;            /* <i>type constraint for</i> int::type */
3 + 4              // <i>error: not a constraint</i>
(bool)(3 + 4)      (bool)(3 + 4)
      </cxx-codeblock>
      In the normalized constraints, the expressions <code>sizeof(char) == 1</code>, 
      <code>1 == 2</code>, and <code>(bool)(3 + 4)</code> are predicate 
      constraints (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>). 

      The concept <code>C3</code> is normalized to a single type constraint
      (<cxx-ref to="temp.constr.atom.type"></cxx-ref>) for the (ill-formed) 
      type <code>int::type</code>.

      The expression <code>3 + 4</code> is not a 
      <cxx-grammarterm>constraint-expression</cxx-grammarterm> because it does
      not satisfy the requirements for being normalized into a predicate 
      constraint.
      </cxx-example>


      <!-- TODO: What about constraint expressions that refer to local
      parameters of the same type? It's okay to say no. -->

      <p> Two <cxx-grammarterm>constraint-expression</cxx-grammarterm>s are 
      considered equivalent if two function definitions containing the 
      expressions would satisfy the one definition rule 
      (<cxx-ref in="cxx" to="basic.def.odr"></cxx-ref>), except that
      the tokens used to name template parameters may differ as long as a 
      token used to name a template parameter in one expression is replaced by 
      another token that names the same template parameter in the other 
      expression, and the tokens used to name names of other entities may 
      differ only if those names refer to the same set of declarations.
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;typename T&gt; requires C&lt;T&gt; void f(); // <i>#1</i>
template&lt;typename U&gt; requires C&lt;U&gt; void f(); // <i>OK: redeclaration of #1</i>

namespace N1 { template&lt;typename T&gt; concept bool C1 = true; }
namespace N2 { template&lt;typename T&gt; concept bool C2 = true; }

template&lt;typename T&gt; requires N1::C1&lt;T&gt; void g(); // #2
template&lt;typename T&gt; requires N1::C1&lt;T&gt; void h(); // #3
using N1::C1;
template&lt;typename T&gt; requires C1&lt;T&gt; void g();     // <i>OK: redeclaration of #2</i>
using namespace N2;
template&lt;typename T&gt; requires C2&lt;T&gt; void h();     // <i>OK: redeclaration of #3</i>
      </cxx-codeblock>
      </cxx-example>

      Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm> that are not 
      equivalent are functionally equivalent if, for any given set of template 
      arguments, the satisfaction of their normalized constraints yields the
      same result.

      A <cxx-grammarterm>constraint-expression</cxx-grammarterm> or
      subexpression thereof of the form <code>(E)</code> is not equivalent to
      <code>E</code>, but the two expressions are functionally equivalent. </p>
      <cxx-example class="inline">
      <cxx-codeblock>
void f() requires true || 1 == 2;   // <i>#1</i>
void f() requires true || (1 == 2); // <i>not equivalent but functionally equivalent</i>
      </cxx-codeblock>
      </cxx-example>
    </cxx-section> <!-- temp.constr.expr -->

  </cxx-section> <!-- temp.constr -->

</cxx-clause> <!-- temp -->


