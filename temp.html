
<cxx-clause id="temp" number="14">
  <h1>Templates</h1>

  Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p number="1" class="quoted">
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        declaration
      </bnf-alt>
      <ins>
      <bnf-alt>
        <bnf-opt>nested-name-specifier</bnf-opt> 
        concept-name
        <bnf-terminal>{</bnf-terminal>
        introduction-list
        <bnf-terminal>}</bnf-terminal>
        declaration
      </bnf-alt>
      </ins>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>

    <bnf-rule>introduction-list</bnf-rule>
      <bnf-alt>introduced-parameter</bnf-alt>
      <bnf-alt>introduction-list<bnf-terminal>,</bnf-terminal> introduced-parameter</bnf-alt>

      <bnf-rule>introduced-parameter</bnf-rule>
        <bnf-alt><bnf-opt><bnf-terminal>...</bnf-terminal></bnf-opt> identifier</bnf-alt>
    </ins>
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp"></cxx-ref>/6.

  <p> A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <dfn>concept introduction</dfn>, a
  <cxx-grammarterm>concept-name</cxx-grammarterm> and following
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.</p>

  <p> The concept designated by the <cxx-grammarterm>concept-name</cxx-grammarterm>
  is determined by the <cxx-grammarterm>introduction-list</cxx-grammarterm>.
  Let <code>C</code> be a <cxx-grammarterm>concept-name</cxx-grammarterm>
  and <code>I1</code>, <code>I2</code>, ..., <code>I<i>n</i></code> be a 
  sequence of <cxx-grammarterm>identifiers</cxx-grammarterm> in the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s of
  an <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  If the <cxx-grammarterm>template-id</cxx-grammarterm>,
  <code>C&lt;I1, I2, ..., I<i>n</i>&gt;</code>, refers to a single
  concept declaration, then that concept is the one designated by
  <code>C</code>. Otherwise, the program is ill-formed.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool Eq() { return true; } // <i>#2</i>

Eq{T} void f1(T, T);    // <i>OK:</i> Eq{T} <i>designates #1</i>
Eq{A, B} void f2(A, B); // <i>OK:</i> Eq{A, B} <i>designates #2</i>
  </cxx-codeblock>
  It is possible to overload function concepts in such a way that a
  <cxx-grammarterm>concept-name</cxx-grammarterm> can designate multiple
  concepts.
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }
template&lt;int N&gt; concept bool C() { return true; }

C{X} void f(); // <i>error: resolution of</i> C{X} <i>is ambiguous</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>Each <cxx-grammarterm>identifier</cxx-grammarterm>, <code>I</code>,
  in the <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s
  of the <cxx-grammarterm>introduction-list</cxx-grammarterm> 
  is declared to be a template parameter that matches the 
  corresponding template parameter, <code>P</code>, in the 
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
  of the concept designated by the 
  <cxx-grammarterm>concept-name</cxx-grammarterm>.
  <cxx-grammarterm>
  <ul>
  
  <li> If <code>P</code> is a template 
  <cxx-grammarterm>type-parameter</cxx-grammarterm> declared with either 
  the <code>class</code> or <code>typename</code> keyword, 
  <code>I</code> is declared as a template 
  <cxx-grammarterm>type-parameter</cxx-grammarterm> using the same keyword;</li>
  
  <li> if <code>P</code> is a template <cxx-grammarterm>type-parameter</cxx-grammarterm> 
  that declares a class template, <code>I</code> is declared as a
  class template with the template parameters of <code>P</code>;</li>
  
  <li> if <code>P</code> is a non-type 
  <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>I</code> is
  declared as a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm> 
  having the same type as <code>P</code>;</li>
  
  <li> if <code>P</code> is a template parameter pack, 
  the <cxx-grammarterm>identifier</cxx-grammarterm>, <code>I</code>,
  shall be preceded by an ellipsis, and is declared as a template parameter 
  pack.</li>
  </ul>
  
  An <cxx-grammarterm>introduced-parameter</cxx-grammarterm> shall not contain
  an ellipsis if its corresponding template parameter does not declare
  a template parameter pack.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt; concept bool Inscrutable = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool Unary_template = true;

Inscrutable{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;             // B <i>is declared as</i> int B
                        // C <i>is declared as</i> typename... C

Inscrutable{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

Unary_template{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

Unary_template{...X} // <i>error: the corresponding parameter is not a</i> 
  void bar();        // <i>template parameter pack</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p>
  <cxx-note>
  A concept referred to by a <cxx-grammarterm>concept-name</cxx-grammarterm> 
  may have template parameters with default template arguments. An
  <cxx-grammarterm>introduction-list</cxx-grammarterm> may omit 
  <cxx-grammarterm>identifier</cxx-grammarterm>s for a corresponding template
  parameter if it has a default argument. However, only the
  <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s are declared
  as template parameters. 
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename A, typename B = bool&gt; 
  concept bool Ineffable() { return true; }

Ineffable{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                        // <i>a single template type parameter</i> T
  </cxx-codeblock>
There is no <cxx-grammarterm>introduced-parameter</cxx-grammarterm> 
that corresponds to the template parameter <code>B</code> in the
<code>Ineffable</code> concept, so <code>f(T)</code> is declared with only
one template parameter.
  </cxx-example>
  </cxx-note>
  </p>

  <p> The <cxx-grammarterm>introduction-list</cxx-grammarterm> shall not
  be empty.</p>

  <p> An introduced template parameter does not have a default template 
  argument, even if its corresponding template parameter does.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!-- FIXME: Does this belong here or in member functions? -->
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p>

  <p> A <cxx-grammarterm>template-declaration</cxx-grammarterm> declared
  by a concept introduction can also be an abbreviated function
  (<cxx-ref to="dcl.fct"></cxx-ref>).

  The invented template parameters introduced by the presence of
  <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>s or
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in
  the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
  are added to the list of template parameters introduced by the the
  <cxx-grammarterm>introduction-list</cxx-grammarterm>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} void f(T, D);

template&lt;C T, D __D&gt; void f(T, __D); // <i>OK: redeclaration of</i> f(T, D)
  </cxx-codeblock>
  </cxx-example>
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  void f(D);
  D{U} void g(U, C);
};

C{T} void X&lt;T&gt;::f(D) { } // <i>OK: definition of</i> X&lt;T&gt;::f(D);
                         // f <i>is a function template with one invented</i>
                         // <i>template type-parameter</i>

C{T} D{U} void X&lt;T&gt;::g(U, C) { } // <i>OK: definition of</i> X&lt;T&gt;::g(U, C);
                                 // g <i>is a function template with two template</i>
                                 // <i>type parameters: one introduced (</i>U<i>) and</i>
                                 // <i>one invented</i>
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> The introduction of a sequence of template parameters,
  <code>T1, T2, ..., T<i>n</i></code>, by a 
  <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>C</code>,
  associates a constraint with the 
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. That constraint is
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;</code> when <code>C</code> designates
  a variable concept and
  <code>C&lt;T1, T2, ..., T<i>n</i>&gt;()</code> when <code>C</code> designates
  a function concept. If an <cxx-grammarterm>introduced-parameter</cxx-grammarterm>
  declares a template parameter pack, its corresponding template argument in the
  associated constraint is a pack expansion 
  (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>).

  <cxx-example>
  <cxx-codeblock>
template&lt;typename A, typename B, int C&gt; concept bool C = true;
template&lt;typename A, typename... Args&gt; concept bool D = true;

C{X, Y, Z} struct S;  // <i>associates</i> C&lt;X, Y, Z&gt; <i>with</i> S
D{P, ...Qs} struct T; // <i>associates</i> D&lt;P, Qs...&gt; <i>with</i> T
  </cxx-codeblock>
  </cxx-example>
  </p>


  <!-- FIXME: This should move to a separate section? -->


  <p>A <cxx-grammarterm>template-declaration</cxx-grammarterm>'s 
  <dfn>associated constraints</dfn> are a conjunction of all constraints 
  introduced by
  <ul>
  <li> a concept introduction,

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>)
  in the declaration's <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,</li>

  <li> any <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
  a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a function
  declaration or definition (<cxx-ref to="dcl.spec.constr"></cxx-ref>),</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> appearing after
  the <cxx-grammarterm>declarator</cxx-grammarterm> of an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>), or</li>

  <li>some combination these.</li>
  </ul>

  A <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, 
  whose constraints are introduced using any combination of these mechanisms is 
  equivalent to another <cxx-grammarterm>template-declaration</cxx-grammarterm>,
  <code>E</code>, whose template parameters are declared explicitly and as
  unconstrained template parameters, and <code>E</code> has a single 
  <cxx-grammarterm>requires-clause</cxx-grammarterm> whose 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is equivalent to 
  the associated constraints of <code>T</code> 
  (<cxx-ref to="temp.over.link"></cxx-ref>).

  <cxx-note> This section describes how constrained template declarations can 
  be equivalently written using alternative syntax in order to generate
  a canonical spelling of a template's associated constraints. 
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);
  </cxx-codeblock>
  The last declaration includes the canonical spelling of the associated 
  constraints for all declarations of <code>g(T)</code> as the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of its
  <cxx-grammarterm>requires-clause</cxx-grammarterm>.
  </cxx-example>
  The paragraphs below define the rules that make these declarations
  equivalent.
  </cxx-note>
  <p>

  <p> When <cxx-grammarterm>template-declaration</cxx-grammarterm> is
  declared by a concept introduction, it is equivalent to a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> whose
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> is defined 
  according to the rules for introducing template parameters above, and the 
  equivalent declaration has a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  equivalent to constraint associated by the concept introduction.
  
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt;      // <i>constraint associated by</i> C4{...Qs}
    void void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!-- TODO: Update based on rewrite of temp.param -->
  <p>When a <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>T</code>, is
  explicitly declared with <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>), it
  is equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>, <code>E</code>,
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"></cxx-ref>).
  
  The declaration, <code>E</code>, has a <cxx-grammarterm>requires-clause</cxx-grammarterm>
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is the
  conjunction of the constraints associated by the constrained template 
  parameters in <code>T</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared. If the constraints of a redeclaration are
  functionally equivalent, but not equivalent to, those of the original,
  the program is ill-formed; no diagnostic is required
  (<cxx-ref to="temp.over.link"></cxx-ref>).

  If the original declaration, <code>T</code>, includes a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm>, its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>E</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename X, int Y&gt; 
  requires C2&lt;Y&gt; &amp;&amp; C1&lt;X&gt;
    struct S; // <i>error: constraints are functionally equivalent but not</i>
              // <i>equivalent to those of</i> R<i>; no diagnostic required</i>

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p> When the declaration is an abbreviated function, it is 
  equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"></cxx-ref>. The associated constraints of the
  abbreviated function are evaluated in the order in which they appear.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires D&lt;U&gt;() &amp;&amp; C&lt;T&gt;  
    void f(T, T, U): // <i>error: constraints are functionally equivalent</i>
                     // <i>but not equivalent to those of</i> f(C, C, D)</i>;
                     // <i>no diagnostic required</i></cxx-codeblock>
  </cxx-example>
  </p>

  <p> An abbreviated function can also be declared as a
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in the
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> and the
  following <cxx-grammarterm>requires-clause</cxx-grammarterm>, if present.
  This is also the case for an abbreviated function that is declared
  is declared with a concept introduction.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

template&lt;C T, D U&gt;
  requires P&lt;T&gt;     // <i>associated constraints are</i> C&lt;T&gt; &amp;&amp; D&lt;U&gt;() &amp;&amp; P&lt;T&gt; 
    void g1(T, U);  // <i>error: ill-formed, no diagnostic required</i>;
  
C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)
  </cxx-codeblock>
  The second declaration of <code>g1(T, U)</code> is ill-formed (no diagnostic
  required) because it is functionally equivalent to the first declaration, 
  but not equivalent.
  </cxx-example>


  <p> A <dfn>trailing <cxx-grammarterm>requires-clause</cxx-grammarterm></dfn> 
  is a <cxx-grammarterm>requires-clause</cxx-grammarterm> that appears after
  the <cxx-grammarterm>declarator</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).

  When a constrained function template or member function template 
  declared with a trailing <cxx-grammarterm>requires-clause</cxx-grammarterm>
  is equivalent to a declaration in which the 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of the
  trailing <cxx-grammarterm>requires-clause</cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U, typename __P&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)
  </cxx-codeblock>
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  </cxx-example>
  </p>


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/1 in order
    to allow constrained template parameters.

    <p number="1" class="quoted">

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <del><bnf-alt>parameter-declaration</bnf-alt></del>
        <ins><bnf-alt>non-type-or-constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>non-type-or-constrained-parameter</bnf-rule>
        <bnf-alt>basic-parameter-declaration</bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> initializer
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> type-id
        </bnf-alt>

        <bnf-alt>
          basic-parameter-declaration <bnf-terminal>=</bnf-terminal> id-expression
        </bnf-alt>
      </ins>
    </bnf-grammar>
    </p>
    
    Update the wording in <cxx-ref in="cxx" to="temp.param"></cxx-ref>/2 as 
    follows.

    <p number="2" class="quoted">
    There is no semantic difference between <code>class</code> and <code>typename</code> 
    in a <cxx-grammarterm>template-parameter</cxx-grammarterm>. <code>typename</code> 
    followed by an <cxx-grammarterm>unqualified-id</cxx-grammarterm> names a 
    template type parameter. <code>typename</code> followed by a 
    <cxx-grammarterm>qualified-id</cxx-grammarterm> denotes the
    type in a non-type 
    <del><cxx-grammarterm>parameter-declaration</cxx-grammarterm></del>
    <ins><cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm></ins>. 
    </p>

    Insert the following paragraphs after paragraph 3 in order to distinguish
    between a template parameter that declares a non-type parameter and a
    template-parameter that declares a constrained parameter, which may
    declare a type parameter. 

    <p number="3" class="quoted">
    When a <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm> has
    the following form:
    <bnf-grammar>
    <bnf-alt>
    constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt>
    </bnf-alt>
    </bnf-grammar>
    it declares a <dfn>constrained template parameter</dfn>.

    Otherwise the parameter is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.
    </p>

    <p class="quoted">
    If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
    appears in the the parameter type of a
    <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm>,
    the program is ill-formed. The program is also ill-formed if a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> appears
    anywhere in the <cxx-grammarterm>basic-parameter-declaration</cxx-grammarterm> 
    and the form of that declaration does not match the form above.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S1;       // <i>OK:</i> T <i>is a constrained template parameter</i>
template&lt;int N&gt; struct S2;     // <i>OK:</i> N <i>is a non-type template parameter</i>
template&lt;auto X&gt; struct S2;    // <i>error: auto in template parameter</i>
template&lt;const D N&gt; void f1(); // <i>error:</i> D <i>is used with a const-qualifier</i>
template&lt;D* N&gt; void f2();      // <i>error:</i> N <i>declares a pointer-to-</i>D
    </cxx-codeblock>
    </cxx-example>
    </p>


    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.


    <p>A constrained template parameter declares a template parameter whose
    type and form match that of the prototype parameter of the concept 
    designated by its <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
    The designated concept is found using the rules in
    <cxx-ref to="dcl.spec.constr"></cxx-ref>. 

    In particular, when 
    <code>T</code> is a template parameter declared as 
    <cxx-grammarterm>non-type-or-constrained-parameter</cxx-grammarterm>,
    and <code>P</code> is its corresponding prototype parameter, then
    <code>T</code> is declared as follows:
    
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> declared with
    the <code>code</code> or <code>typename</code>, <code>T</code> is also 
    type <cxx-grammarterm>template-parameter</cxx-grammarterm> . It is 
    unspecified whether <code>T</code> is declared with <code>class</code>
    or <code>typename</code>.</li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>T</code> is 
    also a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same type as <code>P</code>.</li>

    <!-- TODO: A template template parameter can be declared with
         typename in addition to class. -->
    <li> If <code>P</code> is a template 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, <code>T</code> is
    also a template <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
    <code>P</code>.</li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>T</code> also declares a template parameter pack. In such cases,
    <code>T</code> shall be declared with <code>...</code> following its
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.</li>
    </ul>

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error: parameter pack declared without</i> ...
template&lt;C5... Cx&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i>
    </cxx-codeblock>
    </cxx-example>
    </p>
  </cxx-section> <!-- temp.param -->


  <!-- ==============
       Template Names 
       ============== -->

  <!-- FIXME: Check that this is in an appropriate place. -->
  <cxx-section id="temp.names">
    <h1>Template names</h1>

    Insert the following paragraphs after 
    <cxx-ref in="cxx" to="temp.names"></cxx-ref>/7.</p>

    <p>If a <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
    specialization of a constrained template declaration, the template's
    associated constraints are checked by substituting the
    <cxx-grammarterm>template-arguments</cxx-grammarterm> into the
    constraints and evaluating the resulting expression. If the substitution 
    results in an invalid type or expression, or if the associated constraints 
    evaluate to <code>false</code>, then the program is ill-formed.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt; concept bool True = true;
template&lt;typename T&gt; concept bool False = false;

template&lt;False T&gt; struct S;
template&lt;True T&gt; using Ptr = T*;

S&lt;int&gt;* x;   // Error: int does not satisfy the constraints of False.
Ptr&lt;int&gt; z;  // Ok: z has type int*
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>
    Checking the constraints of a constrained class template does not 
    require its instantiation. 
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    </cxx-note>
    </p>

    </cxx-note>
    </p>
  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      Modify paragraph 3 to include rules for matching constrained template 
      template parameters. Note that the examples following this paragraph in
      the original document are omitted.

      <p number="3" class="quoted">
      A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      subsume the associated constraints of <code>A</code>
      (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"></cxx-ref>), and 
      for template <cxx-grammarterm>template-parameter</cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s matches, recursively. 

      When <code>P</code>â€™s <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <p number="3" class="quoted">
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; && requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    <h1>Template declarations</h1>


    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
      <h1>Class templates</h1>

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. Note that the example
      in the original document is omitted. The example in this paragraph
      is to be added after the omitted example.

      <p number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.

      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;C T&gt; void S&lt;T&gt;::f() { }        // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; 
  template&lt;D U&gt; struct S&lt;T&gt;::Inner { }; // <i>OK</i>
      </cxx-codeblock>
      The declaration of <code>S&lt;T&gt;::g()</code> does not match because
      it does not have the associated constraints of <code>S</code>.
      </cxx-example>
      </p>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        Add the following example to the end of paragraph 1.

        <p number="1" class="quoted">
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g()                   // <i>error: no matching function in</i> S&lt;T&gt;
        </cxx-codeblock>
        </cxx-example>
        </p>

        <!--
        <p>Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func"></cxx-ref>.
        
        <p>A member function of a class template whose declarator contains a
        <cxx-grammarterm>requires-clause</cxx-grammarterm> is a
        <dfn>constrained member function</dfn>.
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  class S {
    void f() requires C&lt;T&gt;();
  };
        </cxx-codeblock>
        </cxx-example>
        </p>


        <p>A constrained member function of a class template may be defined
        outside of its class template definition. Its definition shall be
        specified with the constraints of its declaration.
        <cxx-example>
        Consider possible definitions of the constrained member function 
        <code>S&lt;T&gt;f</code> from above.
        <cxx-codeblock>
template&lt;typename T&gt; 
  void S&lt;T&gt;::f() { }                 // Error: no declaration of f() in S&lt;T&gt;.

template&lt;typenamae T&gt; 
  void S&lt;T&gt;::f() requires C&lt;T&gt;() { } // Ok: defines S&lt;T&gt;::f
        </cxx-codeblock>
        </cxx-example>
        </p>
        -->

      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->


    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      <p>Insert the following paragraph after
      <cxx-ref in="cxx" to="temp.mem"></cxx-ref>/1.</p>

      <p>A constrained member template defined outside of its class template 
      definition shall be specified with the
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      and constraints of the class template followed by
      the template parameters and constraints of the member template.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Foo = ...;
template&lt;typename T&gt; concept bool Bar = ...; // Different than Foo

template&lt;Foo T&gt;
  struct S {
    template&lt;Bar U&gt; void f(U);
    template&lt;Bar U&gt; void g(U);
  };

template&lt;Foo T&gt; template&lt;Bar U&gt; void S&lt;T&gt;::f(U); // Ok
template&lt;Foo T&gt; template&lt;Foo U&gt; void S&lt;T&gt;::g(U); // Error: no g() declared in S
      </cxx-codeblock>
      The template constraints in the definition of <code>g</code> do not
      match those in its declaration.
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.mem -->


    <cxx-section id="temp.friend" number="4">
      <h1>Friends</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend"></cxx-ref>/9.

      <p> 
      A <dfn>constrained friend</dfn> of a class or class template is
      a constrained class template, constrained function template, a 
      constrained ordinary or generic (non-member) function definition.
      
      <cxx-example class="inline">
      When <code>C</code> is a type concept, all of the following are valid 
      constrained friend declarations.
      <cxx-codeblock>
template&lt;typename T&gt;
  struct X {
    template&lt;C U&gt;         
      friend void f(X x, U u) { }    // Constrained function template

    template&lt;C W&gt;         
      friend struct Z { };           // Constrained class template

    friend bool operator==(X a, X b) // Constrained ordinary function
      requires C&lt;T&gt;() { return true; }

    friend void g(X a, C b) { }      // Constrained generic function
  };
      </cxx-codeblock>
      Note that <code>g</code> is a generic function because the the
      parameter <code>b</code> has a
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
      </cxx-example>
      </p>

      <p>
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.</p>

    </cxx-section> <!-- temp.friend -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.spec.match"></cxx-ref>/2.</p>

        <p> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.</p>

      </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.order"></cxx-ref>/1.</p>

        <p>
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B
        </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        </cxx-example>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link"></cxx-ref>/6.</p>

        <p>
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"></cxx-ref>.
        </p>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link">/6.</cxx-ref>

        <p>
        Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.func.order"></cxx-ref>/2.</p>

        <p>
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->
    </cxx-section> <!-- temp.fct -->
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.spec" number="7">
    <h1>Template instantiation and specialization</h1>


    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      Add the following paragraph after paragraph 1 in order to explain
      the how constrained members are instantiated.

      <p>
      When a constrained member of a class is instantiated, new constraints
      for the instantiated declaration are formed by substituting the
      template arguments into the associated constraints of that member.
      The resulting expression is not evaluated after this substitution.

      If the substitution fails, the program is ill-formed.

      <cxx-note>
      The evaluation of constraints happens during lookup or overload
      resolution (<cxx-ref to="over"></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr"></cxx-ref>.
      </cxx-note>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C<T> && sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { }
  S() requires D&lt;T&gt; { throw 0; }
};

S&lt;char&gt; s1;    // error: no matching constructor
S&lt;char[8]&gt; s2; // OK: but throws
      </cxx-codeblock>
      The instantiation of <code>S&lt;char&gt;</code> produces a class
      template specialization having the constructors, 
      <code>S&lt;char&gt;::S() requires C&lt;char&gt;</code> and
      <code>S&lt;char&gt;::S() requires D&lt;char&gt;</code>.

      Even though neither constructor will be selected by overload resolution,
      they remain a part of the class template specialization, and therefore
      suppress the generation of a default constructor.

      The default constructor invoked by the declaration of <code>s2</code>
      is the more constrained: the constraint
      <code>D&lt;char[8]&gt;</code> subsumes <code>C&lt;char[8]&gt;</code>.
      </cxx-example>
      </cxx-note>
      </p>

    </cxx-section> <!-- temp.inst -->


    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      Add the following paragraph:

      <p number="14">
      If the explicit instantiation names a constrained function template, 
      member function, or member function template, the explicit specialization 
      shall have associated constraints that are equivalent to those of the 
      template declaration (<cxx-ref to="temp"></cxx-ref>) after substituting the
      specified or deduced template arguments into the template's associated 
      constraints.

      Explicit instantiations of class templates and variable templates
      cannot be constrained; such declarations simply refer to their 
      respective template declarations as if the templates were unconstrained.

      The template arguments of an explicit specialization shall satisfy
      the associated constraints of the template declaration, if any
      (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };

void f(C) { }
struct X { void f(); };

template void f(double);              // <i>error: no matching declaration</i>
template void f(X) requires C&lt;X&gt;;     // <i>OK</i>
template void f(int) requires C&lt;int&gt;; // <i>error: constraints not satisfied</i>

template&lt;C T&gt; struct Vec { };

template struct Vec&lt;X&gt;;   // <i>OK</i>
template struct Vec&lt;int&gt;; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>
      
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    void f();               // <i>#1</i>
    void f() requires C&lt;T&gt;; // <i>#2</i>
  };

template void S&lt;int&gt;::f();               // <i>OK: explicit specialization of #1</i>
template void S&lt;int&gt;::f() requires C&lt;T&gt;; // <i>OK: explicit specialization of #2</i>
      </cxx-codeblock>
      In the last declaration, the <cxx-grammarterm>requires-clause</cxx-grammarterm> 
      is needed to determine which declaration is being explicitly instantiated.
      </cxx-example>
      </p>

      <!--
      <p>An explicit instantiation of constrained template declaration
      (<cxx-ref to="temp"></cxx-ref>)
      or constrained member function declaration 
      (<cxx-ref to="temp.mem.func"></cxx-ref>)
      shall satsify the associated constraints of that declaration
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typname T&gt;
  concept bool C = requires(T t) { t.c(); };

template&lt;typenane T&gt;
  requires C&lt;T&gt;
    struct X { }

template struct X&lt;int&gt;; // Error: int does not satisfy C.
      </cxx-codeblock>
      </cxx-example>
      </p>

      -->
    </cxx-section> <!-- temp.explicit -->

    <cxx-section id="temp.expl.spec">
      <h1>Explicit specialization</h1>

      <p>Insert the following paragraphs under 
      <cxx-ref in="cxx" to="temp.expl.spec"></cxx-ref>.</p>

      <p>A constrained template declaration or constrained member function
      of a class template can be declared by a declaration
      introduced by <code>template&lt;&gt;</code>.</p>

      <p>The <cxx-grammarterm>template arguments</cxx-grammarterm> of a
      <cxx-grammarterm>simple-template-id</cxx-grammarterm> that
      names an explicit specialization of a constrained template
      declaration must satisfy that template's associated constraints
      (<cxx-ref to="temp"></cxx-ref>).
      <cxx-example class="inline">
      <code>C</code> is the type concept defined in the previous
      section.
      <cxx-codeblock>
template&lt;C T&gt;
  struct S1 { };

struct X { void c(); }

template&lt;&gt; S1&lt;X&gt; { };   // OK: X satisfies C
template&lt;&gt; S1&lt;int&gt; { }; // Error: int does not satisfy C
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>An explicit specialization of a constrained member function
      (<cxx-ref to="temp.mem.func"></cxx-ref>) shall not include a
      a <cxx-grammarterm>requires-clause</cxx-grammarterm>.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S2 { 
    void f(T) requires C&lt;T&gt;;
  };

template&lt;&gt; void S2&lt;X&gt;::f(T a) { }               // OK
template&lt;&gt; void S2&lt;X&gt;::f(T a) requires C&lt;X&gt; { } // Error: extra requires-clause
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- temp.expl.spec -->
  </cxx-section> <!-- temp.spec -->


  <cxx-section id="temp.fct.spec" number="8">
    <h1>Function template specialization</h1>

    <cxx-section id="temp.deduct" number="2">
      <h1>Template argument deduction</h1>

      After <cxx-ref in="cxx" to="temp.deduct"></cxx-ref>/5, add the following
      paragraph:

      <!-- TODO: Rewrite in terms of satisfaction. -->
      <p number="6"> If the template has associated constraints, the template 
      arguments are substituted into those associated constraints and evaluated.
      If the substitution results in an invalid type or expression, or
      if the associated constraints evaluate to <code>false</code>,
      type deduction fails.</p>

    </cxx-section> <!-- temp.deduct -->

  </cxx-section>


  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    <p>Add this as a new section under 
    <cxx-ref in="cxx" to="temp">"</cxx-ref>.</p>


    <p>Certain contexts require expressions that satisfy additional
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <dfn>constraint expression</dfn>s or simply 
    <dfn>constraint</dfn>s.
    <bnf-grammar>
      <bnf-rule>constraint-expression</bnf-rule>
        <bnf-alt>logical-or-expression</bnf-alt>
    </bnf-grammar>

    <p>A <cxx-grammarterm>logical-or-expression</cxx-grammarterm> is a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> if, after 
    substituting template arguments, the resulting expression
    <ul>
    <li>is a constant expression,</li>
    <li>has type <code>bool</code>, and</li>
    <li>both operands <code>P</code> and <code>Q</code> in every subexpression
    of a constraint of the form <code>P || Q</code> or <code>P &amp;&amp; Q</code> 
    have type <code>bool</code>.</li>
    </ul>
    <cxx-note>
    A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.
    The requirement that operands to logical operators have type
    <code>bool</code> prevents constraint expressions from finding
    user-defined overloads of those operators and possibly subverting the
    logical processing required by constraints.
    </cxx-note>
    <!-- </p> -->

    <p>A program that includes an expression not satisfying these requirements
    in a context where a <cxx-grammarterm>constraint-expression</cxx-grammarterm>
    is required is ill-formed.</p>

    <p>
    <cxx-example>
    Let <code>T</code> be a dependent type, <code>C</code> be a unary function 
    concept, <code>P</code>, <code>Q</code>, and <code>R</code> be 
    value-dependent expressions whose type is <code>bool</code>, and 
    <code>M</code> and  <code>N</code> be integral expressions. All of the 
    following expressions can be used as constraints:
    <cxx-codeblock>
C&lt;T&gt;()
has_trait&lt;T&gt;::value // only if value is a bool member
P && Q
P || (Q && R)
M == N              // only if the result type is bool
has_trait&lt;T&gt;::value // only if value is a bool member
M < N               // only if the result type is bool
M + N >= 0
P || !(M < N)
true
false
    </cxx-codeblock>
    An expression of the form <code>M + N</code> is not a valid constraint when
    the arguments have type <code>int</code> since the expression's type is not
    <code>bool</code>. Using this expression as a constraint would make the
    program ill-formed.
    </cxx-example>
    </p>

    <p>A subexpression of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"></cxx-ref> is a <dfn>concept check</dfn>.
    A concept check is not evaluated; it is simplified according to the
    rules described in this section.</p>

    <p>Certain subexpressions of a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> are 
    considered <dfn>atomic constraint</dfn>s. A constraint is atomic 
    if it is not:
    <ul>
    <li>a <cxx-grammarterm>logical-or-expression</cxx-grammarterm> of the form
        <code>P || Q</code>,</li>
    <li>a <cxx-grammarterm>logical-and-expression</cxx-grammarterm> of the form
        <code>P && Q</code>,</li>
    <li>a concept check,</li>
    <li>a <cxx-grammarterm>requires-expression</cxx-grammarterm>, or</li>
    <li>a subexpression of an atomic constraint.</li>
    </ul>
    The valid expression constraints, valid type constraints,
    result type constraints, and exception constraints introduced
    by a <cxx-grammarterm>requires-clause</cxx-grammarterm> are
    also atomic constraints.
    <cxx-example>
    <cxx-codeblock>
has_trait&lt;T&gt;::value
M < N
M + N >= 0
true
false
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>A concept check is not an atomic expression.
    </cxx-note>
    <!-- </p> -->

    <p>Constraints are <dfn>simplified</dfn> by reducing them to 
    expressions containing only logical operators and atomic constraints.
    Concept checks and <cxx-grammarterm>requires-expression</cxx-grammarterm>s 
    are replaced by simplified expressions.
    <cxx-note>
    An implementation is not required to normalize the constraint by rewriting
    in e.g., disjunctive normal form.
    </cxx-note>
    </p>

    <p>A concept check that calls a function concept is simplified by
    substituting the explicit template arguments into the named function
    body's return expression. A concept check that refers to a variable concepts is simplified by substituting the template arguments into the variable's initializer. </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> is simplified
    by replacing it with the conjunction of constraints introduced by
    the <cxx-grammarterm>requirement</cxx-grammarterm>s its 
    <cxx-grammarterm>requirement-list</cxx-grammarterm>.
    <cxx-note>
    Certain atomic constraints introduced by a 
    <cxx-grammarterm>requirement</cxx-grammarterm> have no explicit syntactic 
    representation in the C++.
    </cxx-note>
    </p>
 
    <p>
    <cxx-example>
    Let <code>P</code> and </code>Q</code> be variable templates
    that are atomic constraints.
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool P_and_Q() { return P&lt;T&gt; &amp;&amp; Q&lt;T&gt;; }

template&lt;typename T&gt;
  concept bool P_or_Q = P&lt;T&gt; || Q&lt;T&gt;;

template&lt;typename T&gt;
  concept bool C = P_and_Q&lt;T&gt; &amp;&amp;
                   requires(T x) { x.p() -&gt; int; };

template&lt;typename X&gt;
  requires P_and_Q&lt;X&gt;() void f();

template&lt;typename X&gt;
  requires P_or_Q&lt;X&gt; void g();

template&lt;typename X&gt;
  requires C&lt;X&gt; void h();
    </cxx-codeblock>
The associated constraints of <code>f</code> are simplified to
the expression <code>P&lt;X&gt; &amp;&amp; Q&lt;X&gt;</code>,
and the associated constraints of <code>g</code> are simplified
to <code>P&lt;X&gt; || Q&lt;X&gt;</code>. The associated constraints
of <code>h</code> are:
<cxx-codeblock>
P&lt;X&gt; &amp;&amp; Q&lt;X&gt;
  &amp;&amp; /* requires x.p() for all x of type X* /
  &amp;&amp; /* requires that x.p() convert to int */
</cxx-codeblock>
    </cxx-example>
    </p>
 <!-- 
    FIXME: Write a bunch of examples.


    <cxx-example class="inline"> 
    The expression 
    <code>x==y &amp;&amp; has_trait&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    The expression
    <code>requires(T a, T b) { {a==b} -> bool; }</code> has two atomic
    constraints. <code>a==b</code> must be a valid expression, and
    <code>decltype((a==b)) must be implicitly convertible to <code>bool</code>.
    </cxx-example>
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>
 -->


    <p>A constraint is <dfn>satisfied</dfn> if, after substituting template
    arguments, it evaluates to <code>true</code>. Otherwise, the constraint is 
    <dfn>unsatisfied</dfn>.</p>

    <p>
    For a mapping <i>M</i> from a set <i>X</i> of atomic 
    constraints to boolean values, let <i>G(M)</i> be the mapping 
    from constraints to boolean values such that <i>G(M)(C)</i> is 
    the result of substituting each atomic constraint A within 
    <i>C</i> for <i>M(A)</i>.

    For two constraints <code>P</code> and <code>Q</code>, let 
    <i>X</i> be the set of all atomic constraints that
    appear in <code>P</code> and <code>Q</code>.

    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if, for 
    every mapping <i>M</i> from members of <i>X</i> to boolean 
    values for which <i>M(A) = M(B)</i> whenever <i>A</i> and <i>B</i> 
    are equivalent, either <i>G(M)(P)</i> is false or <i>G(M)(Q)</i> is 
    true (or both).
    </p>


    <!--
    FIXME: Write meaningful examples:
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <dfn>subsume</dfn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example class="inline">
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>
    -->

    <p>Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm>
    <code>P</code> and <code>Q</code> are <dfn>logically equivalent</dfn> 
    if and only if <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>. </p>

  </cxx-section> <!-- temp.constr -->


        <!-- TODO: Consider adding this to the list of non-deduced contexts
             in 14.8.2.5. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->



</cxx-clause> <!-- temp -->


