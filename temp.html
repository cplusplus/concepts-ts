
<cxx-clause id="temp" number="14">
  <h1>Templates</h1>

  Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in paragraph 1 to allow a template declaration introduced
  by a concept.

  <p number="1" class="quoted">
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins><bnf-opt>requires-clause</bnf-opt></ins>
        declaration
      </bnf-alt>
      <ins>
      <bnf-alt>template-introduction declaration</bnf-alt>
      </ins>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt><bnf-terminal>requires</bnf-terminal> constraint-expression</bnf-alt>
    </ins>
  </bnf-grammar>
  </p>
  
  Add the following paragraphs after paragraph 6.

  <p number="7" class="quoted"> 
  A <cxx-grammarterm>template-declaration</cxx-grammarterm> is written in
  terms of its template parameters. These
  parameters are declared explicitly in a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  (<cxx-ref to="temp.param"></cxx-ref>), or they are
  introduced by a <cxx-grammarterm>template-introduction</cxx-grammarterm>
  (<cxx-ref to="temp.intro"></cxx-ref>).
  </p>

  <p class="quoted">
  A template declared by a <cxx-grammarterm>template-introduction</cxx-grammarterm>
  (<cxx-ref to="temp.intro"></cxx-ref>) can also be an abbreviated
  function template (<cxx-ref to="dcl.fct"></cxx-ref>). The invented
  template parameters introduced by the placeholders in the abbreviated
  function template are appended to the list of template parameters declared
  by the <cxx-grammarterm>template-introduction</cxx-grammarterm>.

  <cxx-example>
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;

C1{T} void f(T, auto);
template&lt;C T, typename U&gt; void f(T, U); // OK: redeclaration of f(T, auto)
  </cxx-codeblock>
  <cxx-note>
  The second declaration of <code>f</code> is a redeclaration of the first
  because their associated constraints are equivalent 
  (<cxx-ref to="temp.over.link"></cxx-ref>); this is described in the following
  paragraphs.
  </cxx-example>
  </p>

  <p class="quoted">
  The <dfn>associated constraints</dfn> of a 
  <cxx-grammarterm>template-declaration</cxx-grammarterm> are a defined to be a
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> formed from the
  conjunction of <cxx-grammarterm>constraint-expression</cxx-grammarterm>s
  associated by:

  <div class="quoted">
  <ul>
  <li> a constraint associated by a template introduction 
  (<cxx-ref to="temp.intro"></cxx-ref>), and</li>

  <li> any constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>)
  in the declaration's <cxx-grammarterm>template-parameter-list</cxx-grammarterm>,
  and </li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> following a
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm>, and</li>

  <li> any <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
  in a function declaration (<cxx-ref to="dcl.spec.constr"></cxx-ref>), and</li>

  <li> a <cxx-grammarterm>requires-clause</cxx-grammarterm> appearing in
  the <cxx-grammarterm>declarator</cxx-grammarterm> of a
  function declaration (<cxx-ref to="dcl.fct"></cxx-ref>).</li>
  </ul>

  The formation of the associated constraints for a template declaration
  gives a definite ordering on subexpressions for the purpose of determining
  when one template redeclares another.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

// <i>all of the following declare the same function:</i>
void g(C);
template&lt;C T&gt; void g(T);
C{T} void g(T);
template&lt;typename T&gt; requires C&lt;T&gt; void g(T);

// <i> these also declare the same function:</i>
template&lt;C T&gt; void f();
template&lt;typename T&gt; void f() requires C&lt;T&gt;;
  </cxx-codeblock>
  </cxx-example>
  </div>

  <p class="quoted"> 
  The order in which the subexpressions of the associated constraints
  are composed is the left-to-right order in which
  <cxx-grammarterm>template-introduction</cxx-grammarterm>s,
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s, and
  <cxx-grammarterm>requires-clause</cxx-grammarterm>s occur in the
  declaration.

  <cxx-note>
  A program containing two declarations whose associated constraints are 
  functionally equivalent but not equivalent 
  (<cxx-ref to="temp.over.link"></cxx-ref>) is ill-formed, no diagnostic
  required.
  </cxx-note>

  <cxx-example>
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = true;

C1{T} void f1(C2);                                                      // <i>#1</i>
template&lt;typename T, typename U&gt; requires C1&lt;T&gt; && C2&lt;U&gt; void f1(T, U); // <i>#2</i>
  </cxx-codeblock>

In the associated constraints of #1, the constraint associated by the 
<cxx-grammarterm>template-introduction</cxx-grammarterm> <code>C1{T}</code>
occurs before the constraint associated by the
<cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> in the
<cxx-grammarterm>parameter-declaration</cxx-grammarterm>
<code>C2</code>. 

The resulting <cxx-grammarterm>constraint-expression</cxx-grammarterm> is 
equivalent to the <cxx-grammarterm>requires-clause</cxx-grammarterm> in
#2.

  <cxx-codeblock>
C1{T} void f2(T) requires C2&lt;T&gt;;                        // <i>#1</i>
template&lt;typename T&gt; requires C1&lt;T&gt; &amp;&amp; C2&lt;T&gt; void f2(); // <i>#2</i>
  </cxx-codeblock>
The associated constraints of #1 and #2 are equivalent.

  <cxx-codeblock>
template&lt;C1 T&gt; requires C2&lt;T&gt; void f3(T);                // <i>#1</i>
template&lt;C1 T&gt; void f3(T) requires C2&lt;T&gt;;                // <i>#2</i>
template&lt;typename T&gt; requires C1&lt;T&gt; && C2&lt;T&gt; void f3(T); // <i>#3</i>
template&lt;typename T&gt; void f3(T) requires C1&lt;T&gt; && C2&lt;T&gt;; // <i>#4</i>
  </cxx-codeblock>
The associated constraints of #1, #2, #3, and #4 are equivalent. The 
<cxx-grammarterm>constraint-expression</cxx-grammarterm> associated by
<code>C1</code> occurs before the constraint associated by 
<code>C2</code> in each declaration.

  <cxx-codeblock>
template&lt;C1 T&gt; requires C2&lt;T&gt; void f5();
template&lt;C2 T&gt; requires C1&lt;T&gt; void f5(); // <i>error: constraints are functionally equivalent but not equivalent</i>
  </cxx-codeblock>

The associated constraints of the first declaration are
<code>C1&lt;T&gt; &amp;&amp; C2&lt;T&gt;</code>, and those of the second are
<code>C2&lt;T&gt; &amp;&amp; C1&lt;T&gt;</code>.
  </cxx-example>

  </p>

<!--
  <p class="quoted" number="9"> 
  When a <cxx-grammarterm>template-declaration</cxx-grammarterm> is
  declared by a template introduction (<cxx-ref to="temp.intro"></cxx-ref>), 
  its canonical declaration is a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> whose
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> is defined 
  according to the rules for introducing template parameters in
  <cxx-ref to="temp.intro"></cxx-ref>, and the 
  equivalent declaration has a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  formed as follows.

  Let <code>TT</code> be a <cxx-grammarterm>template-id</cxx-grammarterm>
  formed as 
  <code>C&lt;I<i>1</i>, I<i>2</i>, ..., I<i>n</i>, D<i>1</i>, D<i>2</i>, ..., D<i>n</i>&gt;</code>
  where <code>C</code> is the name of the designated concept,
  <code>I<i>1</i>, I<i>2</i>, ..., I<i>n</i></code> is the sequence
  of introduced template parameters, and
  <code>D<i>1</i>, D<i>2</i>, ..., D<i>n</i></code> is the (possibly empty)
  sequence of instantiated default template arguments needed to form the
  <cxx-grammarterm>template-id</cxx-grammarterm> that refers to <code>C</code>.

  If an introduced parameter declares a template parameter pack, the
  corresponding template argument in the <code>TT</code> is a pack
  expansion (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>).
  
  If <code>C</code> is a variable concept, then the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  the <cxx-grammarterm>id-expression</cxx-grammarterm> <code>TT</code>.
  
  If <code>C</code> is a function concept, then the
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
  the function call <code>TT()</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt; // <i>constraint associated by</i> C4{...Qs}
    void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <!--
  <p class="quoted">
  When a <cxx-grammarterm>template-declaration</cxx-grammarterm> (call it <code>T1</code>) is
  explicitly declared with a <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
  that has constrained template parameters (<cxx-ref to="temp.param"></cxx-ref>), 
  its canonical declaration is a 
  <cxx-grammarterm>template-declaration</cxx-grammarterm> (call it <code>T2</code>)
  with the same template parameters,
  except that all constrained parameters are replaced by unconstrained
  parameters matching the corresponding prototype parameter designated
  by the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
  (<cxx-ref to="dcl.spec.constr"></cxx-ref>).
  
  The declaration, <code>T2</code>, has a <cxx-grammarterm>requires-clause</cxx-grammarterm>
  whose <cxx-grammarterm>constraint-expression</cxx-grammarterm> is the
  conjunction of the <cxx-grammarterm>constraint-expressoin</cxx-grammarterm>s 
  associated by the constrained template parameters in <code>T1</code>.

  The order in which the introduced constraints are evaluated is 
  the same as the order in which the constrained template 
  parameters are declared.

  If the original declaration <code>T1</code> includes a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm>, its
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> is evaluated after 
  the constraints associated by the constrained template parameters in
  <code>T2</code>.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename&gt; concept bool C1 = true;
template&lt;int&gt; concept bool C2 = true;

template&lt;C1 A, C2 B&gt; struct S;
template&lt;C1 T&gt; requires C2&lt;sizeof(T)&gt; void f(T);

template&lt;typename X, int Y&gt; 
  requires C1&lt;X&gt; &amp;&amp; C2&lt;Y&gt;
    struct S; // <i>OK: redeclaration of</i> S

template&lt;typename T&gt; 
  requires C1&lt;T&gt; &amp;&amp; C2&lt;sizeof(T)&gt;
    void f(T); // <i>OK: redeclaration of</i> f(T)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  When the declaration is an abbreviated function template, it is
  equivalent to a <cxx-grammarterm>template-declaration</cxx-grammarterm>
  whose template parameters are declared according to the rules in
  <cxx-ref to="dcl.fct"></cxx-ref>. The associated constraints of the
  abbreviated function template are evaluated in the order in which they appear.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }

void f(C, C, D);

template&lt;C T, D U&gt; 
  void f(T, T, U);   // <i>OK: redeclaration of</i> f(C, C, D)

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void f(T, T, U): // <i>OK: also a redeclaration of</i> f(C, C, D)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  An abbreviated function template can also be declared as a
  <cxx-grammarterm>template-declaration</cxx-grammarterm>. The constraints
  associated by <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
  in the <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> of
  the function declaration are evaluated after those introduced by
  <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s in the
  <cxx-grammarterm>template-parameter-list</cxx-grammarterm> and the
  following <cxx-grammarterm>requires-clause</cxx-grammarterm>, if present.
  This is also the case for an abbreviated function template that
  is declared with a concept introduction.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D() { return true; }
template&lt;typename T&gt; concept bool P = true;

template&lt;C T&gt; requires P&lt;T&gt; void g1(T, D);
template&lt;C T&gt; void g2(T, D);

template&lt;typename T, typename U&gt;
  requires C&lt;T&gt; &amp;&amp; P&lt;T&gt; &amp;&amp; D&lt;U&gt;()
    void g1(T, U);      // <i>OK: redeclaration of</i> g1(T, D)

C{T} void g2(T, D); // <i>OK: redeclaration of</i> g2(T, D)
  </cxx-codeblock>
  </cxx-example>
  </p>

  <p class="quoted"> 
  A <dfn>trailing <cxx-grammarterm>requires-clause</cxx-grammarterm></dfn> 
  is a <cxx-grammarterm>requires-clause</cxx-grammarterm> that appears after
  the <cxx-grammarterm>declarator</cxx-grammarterm> in an
  <cxx-grammarterm>init-declarator</cxx-grammarterm>
  (<cxx-ref to="dcl.decl"></cxx-ref>),
  <cxx-grammarterm>function-definition</cxx-grammarterm>
  (<cxx-ref to="dcl.fct.def.general"></cxx-ref>), or
  <cxx-grammarterm>member-declarator</cxx-grammarterm>
  (<cxx-ref to="class.mem"></cxx-ref>).

  When a constrained function template or member function template is
  declared with a trailing <cxx-grammarterm>requires-clause</cxx-grammarterm>
  it is equivalent to a declaration in which the 
  <cxx-grammarterm>constraint-expression</cxx-grammarterm> of the
  trailing <cxx-grammarterm>requires-clause</cxx-grammarterm> is evaluated
  after all other associated constraints.

  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;C T&gt; struct S {
  template&lt;D U&gt; void f(U) requires D&lt;T&gt;;
};

template&lt;C T&gt; template&lt;typename U&gt;
    requires D&lt;U&gt; &amp;&amp; D&lt;T&gt;
      void S&lt;T&gt;::f(U) { } <i>// OK: definition of</i> S&lt;T&gt;::f(U)

template&lt;C T&gt; template&lt;typename U&gt;
    void S&lt;T&gt;::f(U) requires D&lt;U&gt; &amp;&amp; D&lt;T&gt; { } // <i>error: redefinition of</i> S&lt;T&gt;::f(U)
  </cxx-codeblock>
  The second definition if <code>S&lt;T&gt;::f(U)</code> is an error 
  because its declaration is equivalent to the first.
  </cxx-example>
  </p>

  <!-- FIXME: Does this need to go somewhere? Notes refer to it as 
       redundant. -->
  <!--  
  <p>
  <cxx-note>
  A constrained member function template of a constrained class template
  can be defined outside of its class definition by nested introductions.
  <cxx-example class="inline">
  <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

C{T} struct X {
  D{U} void f();
};

C{T} D{U} void X&lt;T&gt;::f() { } // <i>OK: definition of</i> f()
  </cxx-codeblock>
  </cxx-example>
  </cxx-note>
  </p> 
  -->


  <!-- =================== 
       Template Parameters 
       =================== -->

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    In paragraph 1, extend the grammar for template parameters to 
    constrained template parameters.

    <p number="1" class="quoted">
    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <ins>
        <bnf-alt>constrained-parameter</bnf-alt>
        </ins>

      <ins>
      <bnf-rule>constrained-parameter</bnf-rule>
        <bnf-alt>
          constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt>
        </bnf-alt>
        <bnf-alt>
          constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt> <bnf-terminal>=</bnf-terminal> type-id
        </bnf-alt>
        <bnf-alt>
          constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt> <bnf-terminal>=</bnf-terminal> id-expression
        </bnf-alt>
        <bnf-alt>
          constrained-type-specifier <bnf-opt>...</bnf-opt> <bnf-opt>identifier</bnf-opt> <bnf-terminal>=</bnf-terminal> initializer-clause
        </bnf-alt>
    </bnf-grammar>
    </p>

    Insert a new paragraph after paragraph 1.

    <p number="2" class="quoted">
    There is an ambiguity in the syntax of a 
    <cxx-grammarterm>parameter-declaration</cxx-grammarterm> and
    a <cxx-grammarterm>constrained-parameter</cxx-grammarterm>. 

    If the <cxx-grammarterm>type-specifier-seq</cxx-grammarterm> of
    a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> is a
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>, then
    the <cxx-grammarterm>parameter-declaration</cxx-grammarterm> is a
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>.
    </p>

    Insert the following paragraphs after paragraph 8. These paragraphs
    define the meaning of a constrained template parameter.

    <p number="9" class="quoted">
    A <cxx-grammarterm>constrained-parameter</cxx-grammarterm> declares a 
    template parameter whose type and form match that of the prototype 
    parameter of the concept designated by its 
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
    The designated concept is selected by concept resolution
    (<cxx-ref to="temp.concept.resolve"></cxx-ref>). 

    Let <code>P</code> be the prototype parameter of the designated
    concept. The declared template parameter is determined by the type
    and form of <code>P</code> and the optional ellipsis in the
    <cxx-grammarterm>template-parameter</cxx-grammarterm>.
    <!-- FIXME: this last line should not be template-parameter. -->
    </p>
    
    <div class="quoted">
    <ul>
    <li> If <code>P</code> is a type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> the declared 
    parameter is a type <cxx-grammarterm>template-parameter</cxx-grammarterm>. 
    </li>

    <li> If <code>P</code> is a non-type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, the declared
    parameter is a non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same type as <code>P</code>. </li>

    <li> If <code>P</code> is a template 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>, the declared
    parameter is a template <cxx-grammarterm>template-parameter</cxx-grammarterm>
    having the same <cxx-grammarterm>template-parameter-list</cxx-grammarterm>
    as <code>P</code>, excluding default template arguments. </li>

    <li> If <code>P</code> declares a template parameter pack,
    <code>I</code> shall include an ellipsis, and the declared parameter
    is a template parameter pack. </li>
    </ul>

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;
template&lt;int N&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;
template&lt;char... Cs&gt; concept bool C5 = true;

template&lt;C1 T&gt; void f1();     // <i>OK:</i> T <i>is a type template-parameter</i>
template&lt;C2 X&gt; void f2();     // <i>OK:</i> X <i>is a template with one type-parameter</i>
template&lt;C3 N&gt; void f3();     // <i>OK:</i> N <i>has type int</i>
template&lt;C4... Ts&gt; void f4(); // <i>OK:</i> Ts <i>is a template parameter pack of types</i>
template&lt;C4 Ts&gt; void f5();    // <i>error:</i> Ts <i>must be preceded by an ellipsis</i>
template&lt;C5... Cs&gt; f6();      // <i>OK:</i> Cs <i>is a template parameter pack of</i> char<i>s</i>
    </cxx-codeblock>
    </cxx-example>
    </div>

    <p class="quoted">
    A <cxx-grammarterm>constrained-parameter</cxx-grammarterm> associates a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> with its
    <cxx-grammarterm>template-declaration</cxx-grammarterm>. This
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> is formed
    according to the rules in <cxx-ref to="temp.constr.form"></cxx-ref>.

    Insert the following paragraph after paragraph 9 to restrict the forms 
    of default template argument for 
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>.

    <p class="quoted">
    The default <cxx-grammarterm>template-argument</cxx-grammarterm> of
    a <cxx-grammarterm>constrained-parameter</cxx-grammarterm> shall match
    the kind (type, non-type, template) of the declared parameter.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;int N&gt; concept bool C2 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C3 = true;

template&lt;typename T&gt; struct S0;

template&lt;C1 T = int&gt; struct S1; // <i>OK</i>
template&lt;C2 N = 0&gt; struct S2;   // <i>OK</i>
template&lt;C3 X = S0&gt; struct S3;  // <i>OK</i>
template&lt;C1 T = 0&gt; struct S4;   // <i>error: default argument is not a type</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

  </cxx-section> <!-- temp.param -->


  <!-- ===================================
       Introduction of template parameters
       =================================== -->

  <cxx-section id="temp.intro" number="2">
    <h1>Introduction of template parameters</h1>

    Add this section after <cxx-ref to="temp.param"></cxx-ref>.

    <p> A <dfn>template introduction</dfn> provides a convenient way of declaring
    different templates that have the same template parameters and constraints.

    <bnf-grammar>
      <bnf-rule>template-introduction</bnf-rule>
        <bnf-alt>
          <bnf-opt>nested-name-specifier</bnf-opt>
          concept-name
          <bnf-terminal>{</bnf-terminal> introduction-list <bnf-terminal>}</bnf-terminal>
        </bnf-alt>

      <bnf-rule>introduction-list</bnf-rule>
        <bnf-alt>introduced-parameter</bnf-alt>
        <bnf-alt>introduction-list<bnf-terminal>,</bnf-terminal> introduced-parameter</bnf-alt>

        <bnf-rule>introduced-parameter</bnf-rule>
          <bnf-alt><bnf-opt><bnf-terminal>...</bnf-terminal></bnf-opt> identifier</bnf-alt>
      </ins>
    </bnf-grammar>

    A template introduction declares a sequence of 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>s, which are derived 
    from a <cxx-grammarterm>concept-name</cxx-grammarterm>
    and the sequence of <cxx-grammarterm>identifier</cxx-grammarterm>s in 
    its <cxx-grammarterm>introduction-list</cxx-grammarterm>.


    <p> The concept designated by the <cxx-grammarterm>concept-name</cxx-grammarterm>
    is selected by concept resolution 
    (<cxx-ref to="temp.concept.resolve"></cxx-ref>).

    <p>
    For each 
    <cxx-grammarterm>introduced-parameter</cxx-grammarterm> <code>I</code> in an
    <cxx-grammarterm>introduction-list</cxx-grammarterm>,
    and for its corresponding selected template parameter <code>P</code>
    from the designated concept, declare a new template 
    parameter using the rules for declaring a constrained parameter in
    <cxx-ref to="temp.param"></cxx-ref> by using <code>I</code> as a
    <cxx-grammarterm>declarator-id</cxx-grammarterm> and <code>P</code>
    as the prototype parameter.

    If <code>I</code> contains an ellipsis, <code>P</code> declares a template 
    parameter pack.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, int N, typename... Xs&gt; concept bool C1 = true;
template&lt;template&lt;typename&gt; class X&gt; concept bool C2 = true;

C1{A, B, ...C} // <i>OK:</i> A <i>is declared as</i> typename A
  struct s;    // B <i>is declared as</i> int B
               // C <i>is declared as</i> typename... C

C1{X, Y, Z} // <i>error:</i> Z <i>must be preceded by an ellipsis</i>
  struct t;

C2{T} // <i>OK:</i> T <i>is declared as</i> template&lt;typename&gt; class T
  void foo();

C2{...X}      // <i>error: the corresponding parameter is not a</i> 
  void bar(); // <i>template parameter pack</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    <cxx-note>
    A concept referred to by a <cxx-grammarterm>concept-name</cxx-grammarterm> 
    may have template parameters with default template arguments. An
    <cxx-grammarterm>introduction-list</cxx-grammarterm> may omit 
    <cxx-grammarterm>identifier</cxx-grammarterm>s for a corresponding template
    parameter if it has a default argument. However, only the
    <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s are declared
    as template parameters. 
    
    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename A, typename B = bool&gt; 
  concept bool C() { return true; }

C{T} void f(T); // <i>OK:</i> f(T) <i>is a function template with</i>
                // <i>a single template type parameter</i> T
  </cxx-codeblock>
  There is no <cxx-grammarterm>introduced-parameter</cxx-grammarterm> 
  that corresponds to the template parameter <code>B</code> in the
  <code>C</code> concept, so <code>f(T)</code> is declared with only
  one template parameter.
    </cxx-example>
    </cxx-note>
    </p>


    <p> An introduced template parameter does not have a default template 
    argument even if its corresponding template parameter does.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, int N = -1&gt; concept bool P() { return true; }

P{T, N} struct Array { };

Array&lt;double, 0&gt; s1; // <i>OK</i>
Array&lt;double&gt; s2;    // <i>error:</i> Array <i>takes two template arguments</i>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <!-- TODO: Unify with temp.constr.form -->
    <p>
    A <cxx-grammarterm>template-introduction</cxx-grammarterm> associates
    a <cxx-grammarterm>constraint-expression</cxx-grammarterm> with its 
    <cxx-grammarterm>template-declaration</cxx-grammarterm>.
    
    The constraint is formed from the concept <code>C</code>, designated by the
    <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> (including its
    <cxx-grammarterm>nested-name-specifier</cxx-grammarterm>), 
    and the sequence of introduced parameters.

    Form a sequence of <cxx-grammarterm>template-argument</cxx-grammarterm>s
    <code>Args</code> from the template parameters declared by the
    <cxx-grammarterm>introduced-parameter</cxx-grammarterm>s
    as follows. If an introduced template parameter <code>T</code> is declared 
    as a template parameter pack, its corresponding 
    <cxx-grammarterm>template-argument</cxx-grammarterm> is a pack 
    expansion of <code>T</code>. Otherwise, its corresponding 
    <cxx-grammarterm>template-argument</cxx-grammarterm>
    matches the type an form of <code>T</code>.

    Let <code>TT</code> be a <cxx-grammarterm>template-id</cxx-grammarterm>
    formed as <code>C&lt;Args&gt;</code>.

    The associated <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
    the <cxx-grammarterm>id-expression</cxx-grammarterm> <code>TT</code>
    if <code>C</code> refers to a variable concept. 
    The associated <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
    the function call <code>TT()</code> if <code>C</code> refers to a variable 
    concept.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename T, typename U = char&gt; concept bool C3 = true;
template&lt;typename... Ts&gt; concept bool C4 = true;

C1{A, B} struct X;
C2{A, B} struct Y;
C3{P} void f(P);
C4{...Qs} void g(Qs&amp;&amp;...);

template&lt;typename A, typename B&gt; 
  requires C1&lt;A, B&gt; // <i>constraint associated by</i> C1{A, B}
    struct X;       // <i>OK: redeclaration of</i> X

template&lt;typename A, typename B&gt; 
  requires C2&lt;A, B&gt;()  // <i>constraint associated by</i> C2{A, B}
    struct Y;          // <i>OK: redeclaration of</i> Y

template&lt;class P&gt;
  requires C3&lt;P&gt; // <i>constraint associated by</i> C3{P}
    void f(P);   // <i>OK: redeclaration of</i> f(P)

template&lt;typename... Qs&gt;
  requires C4&lt;Qs...&gt; // <i>constraint associated by</i> C4{...Qs}
    void g(Qs&amp;&amp;...); // <i>OK: redeclaration of</i> g(Qs&amp;&amp;...)
    </cxx-codeblock>
    </cxx-example>
    </p>

  </cxx-section> <!-- temp.intro -->


  <!-- =================================
       Names of template specializations
       ================================= -->

  <cxx-section id="temp.names">
    <h1>Names of template specializations</h1>

    <!-- NOTE: This is a core issue DR. -->
    <!--
    Add the following paragraph to require the implicit instantiation
    of default template arguments for non-function templates.

    <p number="8" class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> does 
    not name a function, a default 
    <cxx-grammarterm>template-argument</cxx-grammarterm> is implicitly
    instantiated (<cxx-ref to="temp.inst"></cxx-ref>) in a context that 
    requires the value of that default argument.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T, typename U = int&gt; struct S { };

S&lt;bool&gt;* p; // <i>the type of</i> p <i>i</i>s S&lt;bool, int&gt;*
    </cxx-codeblock>
    The default argument for <code>U</code> is instantiated to form
    the type <code>S&lt;bool, int&gt;*</code>, but the definition of that
    class template specialization is not implicitly instantiated
    (<cxx-ref to="temp.inst"></cxx-ref>); it is not used in a 
    context that requires a complete type.
    </cxx-example>
    </p>
    -->

    Add this paragraph to require the satisfaction of associated constraints
    on the formation of the <cxx-grammarterm>simple-template-id</cxx-grammarterm>.

    <p class="quoted">
    When a <cxx-grammarterm>simple-template-id</cxx-grammarterm> names
    a constrained non-function template or a template template parameter,
    but not a member template that is a member of an unknown specialization
    (<cxx-ref in="cxx" to="temp.res"></cxx-ref>),
    and all <cxx-grammarterm>template-argument</cxx-grammarterm>s in the
    <cxx-grammarterm>template-id</cxx-grammarterm> are non-dependent
    (<cxx-ref in="cxx" to="temp.dep.temp"></cxx-ref>), the template
    arguments are substituted into the associated constraints
    (Clause <cxx-ref to="temp"></cxx-ref>). 

    If, as a result of substitution, the associated constraints are not 
    satisfied (<cxx-ref to="temp.constr"></cxx-ref>), the 
    <cxx-grammarterm>template-id</cxx-grammarterm> is ill-formed.

    <cxx-example class="inline">
    <cxx-codeblock>
template&lt;typename T&gt; concept bool C = false;

template&lt;C T&gt; struct S1 { };
template&lt;C T&gt; using Ptr = T*;

S1&lt;int&gt;* p; // <i>error: constraints not satisfied</i>
Ptr&lt;int&gt; p; // <i>error: constraints not satisfied</i>

template&lt;typname T&gt;
  struct S2 { Ptr&lt;int&gt; x; }; // <i>error: constraints not satisfied</i>

template&lt;typename T&gt;
  struct S3 { Ptr&lt;T&gt; x; }    // <i>OK: satisfaction is not required</i>

S3&lt;int&gt; x;                   // <i>error: constraints not satisfied</i>

template&lt;tempalte&lt;C T&gt; class X&gt;
  struct S3 {
    X&lt;int&gt; x; // <i>error: constraints not satisfied</i>

    using Type = T::template MT&lt;char&gt;;
  };
    </cxx-codeblock>
    The error in the instantiation of <code>S3&lt;int&gt;</code> is caused
    by the substitution into the type of the member <code>x</code>.

    Because there is no declaration for the template named by 
    <code>T::template MT&lt;char&gt;</code>, it cannot have associated
    constraints.
    </cxx-example>
    </p>

  </cxx-section> <!-- temp.names -->


  <!-- ==================
       Template Arguments
       ================== -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section number="3" id="temp.arg.template">
      <h1>Template template arguments</h1>

      Modify paragraph 3 to include rules for matching constrained template 
      <cxx-grammarterm>template parameter</cxx-grammarterm>s. Note that the 
      examples following this paragraph in
      the original document are omitted.

      <p number="3" class="quoted">
      A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and <code>P</code> is at least as constrained as
      <code>A</code> according to the rules in 
      <cxx-ref to="temp.constr.order"></cxx-ref></ins>.

      Two template parameters match if they are of the same kind 
      (type, non-type, template), 
      for non-type <cxx-grammarterm>template-parameter</cxx-grammarterm>s,
      their types are equivalent (<cxx-ref to="temp.over.link"></cxx-ref>), and 
      for template <cxx-grammarterm>template-parameter</cxx-grammarterm>s, 
      each of their corresponding 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s matches, recursively. 

      When <code>P</code>â€™s <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
      contains a template parameter pack 
      (<cxx-ref in="cxx" to="temp.variadic"></cxx-ref>), the template parameter 
      pack will match zero or more template parameters or template parameter 
      packs in the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>A</code> with the same type and form as the template parameter
      pack in <code>P</code> (ignoring whether those template parameters are 
      template parameter packs).
      </p>

      Add the following example to the end of paragraph 3, after the
      examples given in the original document.

      <div class="quoted">
      <ins>
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; && requires (T t) { t.g(); };

template&lt;template&lt;C&gt; class P&gt;
  struct S { };

template&lt;C&gt; struct X { };
template&lt;D&gt; struct Y { };
template&lt;typename T&gt; struct Z { };

S&lt;X&gt; s1; // <i>OK:</i> X <i>has the same constraints as</i> P
S&lt;Y&gt; s2; // <i>error: the constraints of</i> P <i>do not subsume those of</i> Y
S&lt;Z&gt; s3; // OK: <i>the constraints of P subsume those of</i> Z
      </cxx-codeblock>
      </cxx-example>
      </ins>
      </div>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->


  <!-- =====================
       Template declarations
       ===================== -->

  <cxx-section id="temp.decls" number="5">
    <h1>Template declarations</h1>

    Modify paragraph 2 to indicate that associated constraints are
    instantiated separately from the template they are associated with.

    <p number="2" class="quoted">
      For purposes of name lookup and instantiation, default
      arguments<ins>, associated constraints,</ins> and
      <i>exception-specifications</i> of function templates and default
      arguments<ins>, associated constraints,</ins>
      and <i>exception-specifications</i> of member functions of class
      templates are considered definitions; each default argument<ins>,
      associated constraint,</ins> or exception-specification is a separate
      definition which is unrelated to the function template definition or
      to any other default arguments<ins>, associated constraints,</ins>
      or <i>exception-specifications</i>.
    </p>

    <!-- ===============
         Class templates
         =============== -->

    <cxx-section id="temp.class">
      <h1>Class templates</h1>

      Modify paragraph 3 to require template constraints for out-of-class
      definitions of members of constrained templates. 

      <p number="3" class="quoted">
      When a member function, a member class, a member enumeration, a static 
      data member or a member template of a class template is defined outside 
      of the class template definition, the member definition is defined as a 
      template definition in which the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins> are those of the class template.

      The names of the template parameters used in the definition of the 
      member may be different from the template parameter names used in the 
      class template definition. The template argument list following the class
      template name in the member definition shall name the parameters in the 
      same order as the one used in the template parameter list of the member. 

      Each template parameter pack shall be expanded with an ellipsis in the 
      template argument list.
      </p>

      Add the following example at the end of paragraph 3.

      <div class="quoted">
      <ins>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; concept bool D = true;

template&lt;C T&gt; struct S {
    void f();
    void g();
    template&lt;D U&gt; struct Inner;
  }

template&lt;typename T&gt; requires C&lt;T&gt; void S&lt;T&gt;::f() { } // <i>OK: parameters and constraints match</i>
template&lt;typename T&gt; void S&lt;T&gt;::g() { } // <i>error: no matching declaration for</i> S&lt;T&gt;

template&lt;C T&gt; D{U} struct S&lt;T&gt;::Inner { }; // <i>OK</i>
      </cxx-codeblock>
      </cxx-example>
      </ins>
      </div>


    <!-- ===================================
         Member functions of class templates
         =================================== -->

      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        Add the following example to the end of paragraph 1.

        <p number="1" class="quoted">
        <ins>
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; struct S {
  void f() requires true;
  void g() requires true;
};

template&lt;typename T&gt; 
  void S&lt;T&gt;::f() requires true { } // <i>OK</i>
template&lt;typename T&gt; 
  void S&lt;T&gt;::g() { }               // <i>error: no matching function in</i> S&lt;T&gt;
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </p>
      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->

    <!-- ================
         Member templates
         ================ -->

    <cxx-section id="temp.mem">
      <h1>Member templates</h1>

      Modify paragraph 1 in order to account for constrained member templates
      of (possibly) constrained class templates. 

      <p number="1" class="quoted">
      A template can be declared within a class or class template; such a 
      template is called a member template. 

      A member template can be defined within or outside its class definition 
      or class template definition. 

      A member template of a class template that is defined outside of its 
      class template definition shall be specified with the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s 
      <ins>and associated constraints</ins>
      of the class template followed by the 
      <cxx-grammarterm>template-parameter</cxx-grammarterm>s
      <ins>and associated constraints</ins>
      of the member template.
      </p>

      Add the following example at the end of paragraph 1.

      <div class="quoted">
      <ins>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = sizeof(T) &lt;= 4;

template&lt;C1 T&gt;
  struct S {
    template&lt;C2 U&gt; void f(U);
    template&lt;C2 U&gt; void g(U);
  };

template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::f(U) requires C2&lt;U&gt; { } // <i>OK</i>
template&lt;C1 T&gt; template&lt;typename U&gt; 
  void S&lt;T&gt;::g(U) { } // <i>error: no matching function in</i> S&lt;T&gt;
      </cxx-codeblock>
      </cxx-example>
      </ins>
      </div>
    </cxx-section> <!-- temp.mem -->


    <!-- ============
         Friends
         ============ -->

    <cxx-section id="temp.friend" number="4">
      <h1>Friends</h1>


      Modify paragraph 9 to restrict constrained friend declarations.

      <p number="9" class="quoted">
	When a friend declaration refers to a specialization of a function
	template, the function parameter declarations shall not include
	default arguments, <ins>the declaration shall not be
	constrained,</ins> nor shall the inline specifier be used in such a
	declaration.</p>

      And add examples following that paragraph.

	<p class="quoted">
	<cxx-note>Other friend declarations can be constrained.  In a
	constrained friend declaration that is not a definition, the
	constraints are used for declaration
	matching.</cxx-note>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T&gt; concept bool C2 = false;

template&lt;C1 T&gt; g0(T);
template&lt;C1 T&gt; g1(T);
template&lt;C2 T&gt; g2(T);

template&lt;typename T&gt;
  struct S {
    friend void f1() requires true;  // <i>OK</i>
    friend void f2() requires C1&lt;T&gt;; // <i>OK</i>
    friend void g0&lt;T&gt;(T) requires C&lt;T>; // <i>error: constrained friend specialization</i>
    friend void g1&lt;T&gt;(T);            // <i>OK</i>
    friend void g2&lt;T&gt;(T);            // <i>ill-formed, no diagnostic required</i>
  };

void f1() requires true; // <i>friend of all S&lt;T></i>
void f2() requires C1&ltint>; // <i>friend of S&lt;int></i>
      </cxx-codeblock>
      The friend declaration of <code>g2</code> is ill-formed, no
      diagnostic required, because no valid specialization of <code>S</code>
      can be generated: for all <code>T</code> there is no <code>g2&lt;T></code>
      for which the constraints are satisfied, so template argument
      deduction (<cxx-ref to="temp.deduct.decl"></cxx-ref>) fails.
      </cxx-example>
      </p>
      <p class="quoted">
      <cxx-note>
      Within a class template, a friend may define a non-template function
      whose constraints specify requirements on template arguments.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool Eq = requires (T t) { t == t; };

template&lt;typename T&gt;
  struct S {
    friend bool operator==(S a, S b) requires Eq&lt;T&gt; { return a == b; } // OK
  };
      </cxx-codeblock>
      </cxx-example>
      In the instantiation of such a class template, the template
      arguments are substituted into the constraints but not evaluated.
      Constraints are checked (<cxx-ref to="temp.constr"></cxx-ref>) only when
      that function is considered as a viable candidate for overload resolution
      (<cxx-ref to="over.match.viable"></cxx-ref>).
      </cxx-note>
      </p>

    </cxx-section> <!-- temp.friend -->



    <!-- ======================================
         Class template partial specializations
         ====================================== -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      After paragraph 3, insert the following, which explains constrained
      partial specializations.

      <p number="4" class="quoted">
      A class template partial specialization may be constrained
      (Clause <cxx-ref to="temp"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;int I&gt; concept bool N = I &gt; 0;

template&lt;C T1, C T2, N I&gt; class A&lt;T1, T2, I&gt;;  // <i>#6</i>
template&lt;C T, N I&gt;        class A&lt;int, T*, I&gt;; // <i>#7</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      Remove the 3rd item in the list of paragraph 8 to allow
      constrained class template partial specializations like #6, and
      because it is redundant with the 4th item.
      Note that all other items in that list are elided. 

      <p number="8" class="quoted">
      Within the argument list of a class template partial specialization, 
      the following restrictions apply:
      <ul>
      <li>...</li>
      <li><del>The argument list of the specialization shall
	not be identical to the implicit argument list of the
	primary template.</del></li>
      <li>The specialization shall be more specialized than the primary
	template (<cxx-ref to="temp.class.order"></cxx-ref>).</li>
      <li>...</li>
      </ul>
 
      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        Modify paragraph 2; constraints must be satisfied in order
        to match a partial specialization. 

        <p number="2" class="quoted"> 
        A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list (<cxx-ref in="cxx" to="temp.deduct"></cxx-ref>)
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        (<cxx-ref to="temp.constr"></cxx-ref>)</ins>.
        </p>

        Add the following example to the end of paragraph 2.

        <div class="quoted">
        <ins>
        <cxx-example class="inline">
        <cxx-codeblock>
struct S { void f(); };

A&lt;S, S, 1&gt;    a6; // <i>uses #6</i>
A&lt;S, int, 2&gt;  a7; // <i>error: constraints not satisfied</i>
A&lt;int, S*, 3&gt; a8; // <i>uses #7</i>
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </div>
      </cxx-section> <!-- temp.class.spec.match -->


      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        Modify paragraph 1 so that constraints are considered in the
        partial ordering of class template specializations. 

        <p number="1" class="quoted">
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        (<cxx-ref in="cxx" to="temp.func.order"></cxx-ref>):
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and associated constraints</ins> as the first partial 
          specialization, and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and associated constraints</ins> as the second partial 
          specialization, and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>

        Add the following example to the end of paragraph 1.

        <div class="quoted">
        <ins>
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { t.f(); };
template&lt;typename T&gt; concept bool D = C&lt;T&gt; &amp;&amp; requires (T t) { t.f(); };


template&lt;typename T&gt; class S { };
template&lt;C T&gt; class S&lt;T&gt; { }; // <i>#1</i>
template&lt;D T&gt; class S&lt;T&gt; { }; // <i>#2</i>

template&lt;C T&gt; void f(S&lt;T&gt;); // <i>A</i>
template&lt;D T&gt; void f(S&lt;T&gt;); // <i>B</i>
        </cxx-codeblock>
        The partial specialization #2 is more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> is more specialized than <code>A</code>.
        </cxx-example>
        </ins>
        </div>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->


    <!-- ==================
         Function templates
         ================== --> 

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        Modify paragraph 6 to account for constraints on function
        templates.

        <p number="6" class="quoted">
        <del> Two function templates are <dfn>equivalent</dfn> if they are 
        declared in the same scope, have the same name, have identical template 
        parameter lists, and have return types and parameter lists that are 
        equivalent using the rules described above to compare expressions 
        involving template parameters.</del>
        </p>
        <div class="quoted">
        <ins>
        Two function templates are <dfn>equivalent</dfn> if they:
        <ul>
        <li> are declared in the same scope,</li>
        <li> have the same name,</li>
        <li> have identical template parameter lists,</li>
        <li> have return types and parameter lists that are equivalent using
             the rules described above to compare expressions involving 
             template parameters, and</li>
        <li> have associated constraints (Clause <cxx-ref to="temp"></cxx-ref>) 
             that are equivalent using the rules 
             above to compare expressions involving template parameters.</li>
        </ul>
        </ins>
        </div>

        <div class="quoted">
        Two function templates are <dfn>functionally equivalent</dfn> if they 
        are equivalent except that <del>one or more expressions that involve 
        template parameters in the return types and parameter lists are 
        functionally equivalent using the rules described above to compare 
        expressions involving template parameters</del>
        <ins>
        <ul> 
        <li>one or more expressions that involve template parameters in the 
        return types <del>and</del><ins>,</ins> parameter lists<ins>, and
        associated constraints, if any, (Clause <cxx-ref to="temp"></cxx-ref>)</ins> 
        are functionally equivalent using 
        the rules described above to compare expressions involving template 
        parameters; or</li>

        <li> both function templates have associated constraints that are
        functionally equivalent but not equivalent, using the rules in 
        <cxx-ref to="temp.constr.expr"></cxx-ref> to compare 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>s.</li>
        </ul>
        </ins>

        If a program contains declarations of function templates that are 
        functionally equivalent but not equivalent, the program is ill-formed; 
        no diagnostic is required.
        </div>
        <!-- </p> -->


      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        Modify paragraph 2 to include constraints in the partial ordering
        of function templates.

        <p number="2" class="quoted">
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. 

        <ins>If both deductions succeed, the partial ordering selects
        the more constrained template as described by the rules in
        <cxx-ref to="temp.constr.order"></cxx-ref>.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->

    </cxx-section> <!-- temp.fct -->

  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.res">
    <h1>Name resolution</h1>

    Modify paragraph 8.

    <p number="8" class="quoted">
      Knowing which names are type names allows the syntax of every
      template to be checked. No diagnostic shall be issued for a template
      for which a valid specialization can be generated. If no valid
      specialization can be generated for a template, and that template is
      not instantiated, the template is ill-formed, no diagnostic
      required. If every valid specialization of a variadic template
      requires an empty template parameter pack, the template is
      ill-formed, no diagnostic required. <ins>If no instantiation of
      the associated constraints of a template would result in a valid
      expression, the template is ill-formed, no diagnostic required.</ins>
      If a hypothetical instantiation of a template immediately following
      its definition would be ill-formed due to a construct that does not
      depend on a template parameter, the program is ill-formed; no
      diagnostic is required. If the interpretation of such a construct in
      the hypothetical instantiation is different from the interpretation
      of the corresponding construct in any actual instantiation of the
      template, the program is ill-formed; no diagnostic is required.
    </p>
    <cxx-section id="temp.dep.res" number="4">
      <h1>Dependent name resolution</h1>
      <cxx-section id="temp.point">
	<h1>Point of instantiation</h1>
	Add a new paragraph after paragraph 4.

	<p number="5" class="quoted">
	  The point of instantiation of a constraint-expression of a
	  specialization immediately precedes the point of instantiation of
	  the specialization.
	</p>
      </cxx-section>
    </cxx-section>
  </cxx-section>

  <!-- =========================================
       Template instantiation and specialization
       ========================================= -->

  <cxx-section id="temp.spec" number="7">
    <h1>Template instantiation and specialization</h1>


    <cxx-section id="temp.inst">
      <h1>Implicit instantiation</h1>

      Change paragraph 1 to include associated constraints.

      <p class="quoted">
	Unless a class template specialization has been explicitly
	instantiated (14.7.2) or explicitly specialized (14.7.3), the class
	template specialization is implicitly instantiated when the
	specialization is referenced in a context that requires a
	completely-defined object type or when the completeness of the
	class type affects the semantics of the program. [ Note: Within a
	template declaration, a local class or enumeration and the members
	of a local class are never considered to be entities that can be
	separately instantiated (this includes their default arguments,
	<i>exception-specifications</i>,
	and non-static data member initializers, if any). As a result, the
	dependent names are looked up, the semantic constraints are
	checked, and any templates used are instantiated as part of the
	instantiation of the entity within which the local class or
	enumeration is declared. â€”end note ] The implicit instantiation of
	a class template specialization causes the implicit instantiation
	of the declarations, but not of the definitions, default
	arguments, <ins>associated constraints,</ins> or
	<i>exception-specifications</i> of the class member functions,
	member classes, scoped member enumerations, static data members and
	member templates; and it causes the implicit instantiation of the
	definitions of unscoped member enumerations and member anonymous
	unions.
      </p>

      Add a new paragraph after paragraph 15 to describe how associated
      constraints are instantiated.

      <p number="16" class="quoted">
	The associated constraints of a template specialization are not
	instantiated along with the specialization itself; they are
	instantiated as part of satisfaction checking.
	(<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-note>
      The satisfaction of constraints is determined during lookup or overload
      resolution (<cxx-ref to="over.match"></cxx-ref>). Preserving the spelling
      of the substituted constraint also allows constrained member function
      to be partially ordered by those constraints according to the rules
      in <cxx-ref to="temp.constr.order"></cxx-ref>.
      </cxx-note>


      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) &gt; 2;
template&lt;typename T&gt; concept bool D = C&lt;T&gt; && sizeof(T) &gt; 4;

template&lt;typename T&gt; struct S {
  S() requires C&lt;T&gt; { } // <i>#1</i>
  S() requires D&lt;T&gt; { } // <i>#2</i>
};

S&lt;char&gt; s1;    // <i>error: no matching constructor</i>
S&lt;char[8]&gt; s2; // <i>OK: calls #2</i>
      </cxx-codeblock>

      Even though neither constructor for S&lt;char> will be selected by
      overload resolution,
      they remain a part of the class template specialization. This also
      has the effect of suppressing the implicit generation of a default 
      constructor (<cxx-ref in="cxx" to="class.ctor"></cxx-ref>)
      </cxx-example>

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; struct S1 {
  template&lt;typename U&gt; requires false struct Inner1; // <i>OK</i>
};

template&lt;typename T&gt; struct S2 {
  template&lt;typename U&gt; 
    requires sizeof(T[(int)-sizeof(T)]) > 1 // <i>error: ill-formed, no diagnostic required</i>
      struct Inner2;
};
      </cxx-codeblock>
      </cxx-example>
      Every instantiation of <code>S1</code> results in a valid type,
      although any use of its nested <code>Inner1</code> template is invalid.

      <code>S2</code> is ill-formed, no diagnostic required, since no
      substitution into the constraints of its <code>Inner2</code>
      template would result in a valid expression.
      </p>

    </cxx-section> <!-- temp.inst -->


    <!-- ======================
         Explicit instantiation
         ====================== -->

    <cxx-section id="temp.explicit">
      <h1>Explicit instantiation</h1>

      Modify paragraph 8 to ensure that only members whose constraints are 
      satisfied are explicitly instantiated during class template 
      specialization. The note in the original document is omitted.

      <p number="8" class="quoted">
      An explicit instantiation that names a class template specialization is 
      also an explicit instantiation of the same kind (declaration or 
      definition) of each of its members (not including members inherited from 
      base classes and members that are templates) that has not been previously 
      explicitly specialized in the translation unit containing the explicit 
      instantiation, 
      <ins>
      and provided that the associated constraints (<cxx-ref to="temp"></cxx-ref>), 
      if any, of that member are satisfied (<cxx-ref to="temp.constr"></cxx-ref>)
      by the template arguments of the explicit instantiation,
      </ins> 
      except as described below.
      </p>

      Add the following paragraphs to this section. These require an explicit
      instantiation of a constrained template to satisfy the template's
      associated constraints.

      <p number="14" class="quoted">
      If the explicit instantiation names a class template specialization
      or variable template specialization of a constrained template, then
      the <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of the explicit
      instantiation shall satisfy the template's associated constraints
      (<cxx-ref to="temp.constr"></cxx-ref>).
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template struct S&lt;char&gt;;    // <i>OK</i>
template struct S&lt;char[2]&gt;; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>

      <p class="quoted">
      When an explicit instantiation refers to a specialization of a
      function template (<cxx-ref to="temp.deduct.decl"></cxx-ref>), that 
      template's associated constraints shall be satisfied by the template 
      arguments of the explicit instantiation.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T) { } // <i>#1</i>
template&lt;typename T&gt; void g(T) { } // <i>#2</i>
template&lt;C T&gt;        void g(T) { } // <i>#3</i>

template void f(int);   // <i>OK: refers to #1</i>
template void f(void*); // <i>error: no matching template</i>
template void g(int);   // <i>OK: refers to #3</i>
template void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.explicit -->


    <!-- =======================
         Explicit specialization
         ======================= -->

    <cxx-section id="temp.expl.spec">
      <h1>Explicit specialization</h1>

      Insert the following paragraphs after paragraph 12. These require
      an explicit specialization to satisfy the constraints of the primary
      template.

      <p number="12" class="quoted">
      The <cxx-grammarterm>template-arguments</cxx-grammarterm> in the
      <cxx-grammarterm>template-id</cxx-grammarterm> of an explicit 
      specialization of a constrained non-function template shall satisfy the 
      associated constraints of that template, if any 
      (<cxx-ref to="temp.constr"></cxx-ref>).

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 1;

template&lt;C T&gt; struct S { };

template&lt;&gt; struct S&lt;char&gt; { };    // <i>OK</i>
template&lt;&gt; struct S&lt;char[2]&gt; { }; // <i>error: constraints not satisfied</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p class="quoted">
      When determining the function template referred to by an explicit 
      specialization of a function template 
      (<cxx-ref to="temp.deduct.decl"></cxx-ref>),
      the associated constraints of that template (if any) shall be satisfied 
      (<cxx-ref to="temp.constr"></cxx-ref>) by the
      template arguments of the explicit specialization.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { -t; };

template&lt;C T&gt;        void f(T); // <i>#1</i>
template&lt;typename T&gt; void g(T); // <i>#2</i>
template&lt;C T&gt;        void g(T); // <i>#3</i>

template&lt;&gt; void f(int);   // <i>OK: refers to #1</i>
template&lt;&gt; void f(void*); // <i>error: no matching template</i>
template&lt;&gt; void g(int);   // <i>OK: refers to #3</i>
template&lt;&gt; void g(void*); // <i>OK: refers to #2</i></cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.expl.spec -->
  </cxx-section> <!-- temp.spec -->


  <!-- =================================
       Function template specializations
       ================================= -->

  <cxx-section id="temp.fct.spec" number="8">
    <h1>Function template specializations</h1>

    <cxx-section id="temp.deduct" number="2">
      <h1>Template argument deduction</h1>

      Add the following sentences to the end of paragraph 5. This defines
      the substitution of template arguments into a function template's
      associated constraints. Note that the last part of paragraph 5
      has been duplicated in order to provide context for the addition.

      <p number="5" class="quoted">
      When all template arguments have been deduced or obtained from default 
      template arguments, all uses of template parameters in the template 
      parameter list of the template and the function type are replaced with
      the corresponding deduced or default argument values. 

      If the substitution results in an invalid type, as described above, type 
      deduction fails.

      <ins>
      If the function template has associated constraints
      (Clause <cxx-ref to="temp"></cxx-ref>),
      the template arguments are substituted into the associated constraints
      without evaluating the resulting expression. If this substitution
      results in an invalid type or expression, type deduction fails.

      <cxx-note>
      The satisfaction of constraints (<cxx-ref to="temp.constr"></cxx-ref>)
      associated with the function template specialization is determined during 
      overload resolution (<cxx-ref to="over.match"></cxx-ref>), and not at 
      the point of substitution.
      </cxx-note>
      </ins>
      </p>

      <cxx-section id="temp.deduct.decl" number="6">
        <h1>Deducing template arguments from a function declaration</h1>

        Add the following after paragraph 1 in order to require the
        satisfaction of constraints when matching a specialization to a
        template.

        <p number="2" class="quoted">
        Remove from the set of function templates considered all those
        whose associated constraints (if any) are not satisfied by the deduced
        template arguments (<cxx-ref to="temp.constr"></cxx-ref>).
        </p>

        Update paragraph 2 (now paragraph 3) to accommodate the new
        wording.

        <p class="quoted">
        If, 
        <del>for the set of function templates so considered</del>
        <ins>for the remaining function templates</ins>,
        there is either no match or more than one match after partial ordering 
        has been considered (<cxx-ref to="temp.func.order"></cxx-ref>), deduction fails 
        and, in the declaration cases, the program is ill-formed.
        </p>
      </cxx-section> <!-- temp.deduct.decl -->

    </cxx-section> <!-- temp.deduct -->

  </cxx-section> <!-- temp.fct.spec -->


  <!-- ====================
       Template constraints
       ==================== -->

  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    Add this section after 14.8.

    <p>
    <cxx-note>
    This section defines the meaning of constraints on template arguments, including
    the translation of <cxx-grammarterm>constraint-expression</cxx-grammarterm>s
    into constraints (<cxx-ref to="temp.constr.expr"></cxx-ref>),
    and also the abstract syntax, satisfaction, and subsumption of those 
    constraints
    (<cxx-ref to="temp.constr.op"></cxx-ref>, <cxx-ref to="temp.constr.atom"></cxx-ref>).
    </cxx-note>
    </p>

    <p> A <dfn>constraint</dfn> is a sequence of logical operations and 
    operands that specifies requirements on template arguments. 
    <cxx-note>The operands of a logical operation are constraints.</cxx-note>
    </p>


    <!-- NOTE: Satisfaction requires that the constraint has no
         dependent expressions or types -->
    <p>
    After substitution, a constraint is <dfn>satisfied</dfn> if and only if 
    it and all of its operands are satisfied according to the evaluation 
    rules described in
    <cxx-ref to="temp.constr.op"></cxx-ref> and
    <cxx-ref to="temp.constr.atom"></cxx-ref>.

    If the substitution of template arguments into a constraint fails, 
    that constraint is not satisfied.

    <cxx-note>
    Substitution into a constraint may yield a well-formed constraint that
    contains ill-formed expressions or types. This may happen, for
    example, in the substitution into expression constraints
    (<cxx-ref to="temp.constr.atom.expr"></cxx-ref>)
    and type constraints
    (<cxx-ref to="temp.constr.atom.type"></cxx-ref>).
    </cxx-note>
    </p>

    <p> A constraint <code>P</code> is said to <dfn>subsume</dfn> another
    constraint <code>Q</code> if, informally, it can be determined that
    <code>P</code> implies <code>Q</code>, up to the equivalence of types
    and expressions in atomic constraints.
    <cxx-ref to="temp.constr.atom"></cxx-ref>. 

    <cxx-note>
    Subsumption does not determine, for example, if the predicate 
    constraint (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>) 
    <code>N % 2 == 1</code> subsumes <code>N &amp; 1</code> for 
    some integral template argument, <code>N</code>. 
    </cxx-note>
    
    The rules determining when one constraint subsumes another is given
    in <cxx-ref to="temp.constr.order"></cxx-ref>, and subsumption
    rules for each kind of atomic constraint are given in
    <cxx-ref to="temp.constr.atom"></cxx-ref>.
    </p>

    <cxx-section id="temp.constr.op">
      <h1>Logical operations</h1>

      <p> There are two logical operations on constraints: conjunction
      and disjunction. </p>

      <cxx-note> 
      These logical operations have no corresponding C++ syntax.
      For the purpose of exposition, conjunction is spelled
      using the symbol &and;, and disjunction is spelled using the 
      symbol &or;. Grouping of constraints is shown using parentheses.
      </cxx-note>


      <!-- ===========
           Conjunction
           =========== -->

      <p> A <dfn>conjunction</dfn> is a logical operation taking two 
      operands. A conjunction of constraints is satisfied if and only 
      if both operands are satisfied. </p>

      <!-- ===========
           Disjunction
           =========== -->

      <p> A <dfn>disjunction</dfn> is a logical operation taking two 
      operands. A disjunction of constraints is satisfied if and only 
      if either operand is satisfied or both operands are satisfied. </p>

    </cxx-section> <!-- temp.constr.op -->

    <!-- =================
         Atomic constraints
         ================== -->

    <cxx-section id="temp.constr.atom">
      <h1>Atomic constraints</h1>

      <p> Any constraint that is not a conjunction or disjunction is an
      <dfn>atomic constraint</dfn>. </p>

        <!-- =====================
             Predicate constraints
             ===================== -->

        <cxx-section id="temp.constr.atom.pred">
          <h1>Predicate constraints</h1>

          <p> A <dfn>predicate constraint</dfn> is an atomic constraint
          that evaluates a prvalue constant expression of type <code>bool</code>
          (<cxx-ref in="cxx" to="expr.const"></cxx-ref>).
          The constraint is satisfied if and only if the expression 
          evaluates to <code>true</code>.
          
          <cxx-note>
          Predicate constraints allow the definition of template requirements
          in terms of constant expressions. This allows the specification 
          constraints on non-type template arguments and template template 
          arguments.
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = sizeof(T) == 4 &amp;&amp; !true;
          </cxx-codeblock>
          Here, <code>sizeof(T) == 4</code> and <code>!true</code> are 
          predicate constraints required by the concept, <code>C</code>.
          </cxx-example>
          </p>

          <p>A predicate constraint <code>P</code> subsumes another
          predicate constraint <code>Q</code> if and only if
          <code>P</code> and <code>Q</code> are equivalent
          <cxx-grammarterm>constraint-expression</cxx-grammarterm>s
          (<cxx-ref to="temp.constr.expr"></cxx-ref>).

          <cxx-example class="inline">
          The predicate <code>M >= 0</code> does not subsume the predicate
          <code>M > 0</code> because they are not equivalent
          <cxx-grammarterm>constraint-expressions</cxx-grammarterm>.
          </cxx-example>
          </p>

        </cxx-section> <!-- temp.constr.atom.pred -->


        <!-- ======================
             Expression constraints
             ====================== -->

        <cxx-section id="temp.constr.atom.expr">
          <h1>Expression constraints</h1>

          <p> An <dfn>expression constraint</dfn> is an atomic constraint
          that specifies a requirement on the formation of an
          <cxx-grammarterm>expression</cxx-grammarterm> <code>E</code>
          through substitution of template arguments.

          An expression constraint is satisfied if substitution 
          yielding <code>E</code> did not fail. 
          
          Within an expression constraint, <code>E</code> is an unevaluated 
          operand (Clause <cxx-ref to="expr"></cxx-ref>).

          <cxx-note>
          An expression constraint is introduced by the 
          <cxx-grammarterm>expression</cxx-grammarterm> in either a
          <cxx-grammarterm>simple-requirement</cxx-grammarterm> 
          (<cxx-ref to="expr.prim.req.simple"></cxx-ref>)
          or
          <cxx-grammarterm>compound-requirement</cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>)
          of a
          <cxx-grammarterm>requires-expression</cxx-grammarterm>.
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };
          </cxx-codeblock>
          The concept <code>C</code> introduces an expression constraint for 
          the expression <code>++t</code>.
          
          The type argument <code>int</code> satisfies this constraint because the
          the expression <code>++t</code> is valid after substituting <code>int</code>
          for <code>T</code>.
          </cxx-example>
          </p>

          <p> An expression constraint <code>P</code> subsumes another
          expression constraint <code>Q</code> if and only if
          the <cxx-grammarterm>expression</cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.expr -->


        <!-- ================
             Type constraints
             ================ -->

        <cxx-section id="temp.constr.atom.type">
          <h1>Type constraints</h1>

          <p> A <dfn>type constraint</dfn> is an atomic constraint that
          specifies a requirement on the formation 
          of a type <code>T</code> through the substitution of
          template arguments.

          A type constraint is satisfied if and only 
          <code>T</code> is non-dependent, meaning that the substitution 
          yielding <code>T</code> did not fail.

          <cxx-note>
          A type constraint is introduced by the 
          <cxx-grammarterm>typename-specifier</cxx-grammarterm> in a
          <cxx-grammarterm>type-requirement</cxx-grammarterm> of a
          <cxx-grammarterm>requires-expression</cxx-grammarterm>
          (<cxx-ref to="expr.prim.req.type"></cxx-ref>).
          </cxx-note>

          <cxx-example example="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires () { typename T::type; };
          </cxx-codeblock>
          The concept <code>C</code> introduces a type constraint for the 
          type name <code>T::type</code>.

          The type <code>int</code> does not satisfy this constraint
          because substitution of that type into the constraint results in a
          substitution failure; <code>typename int::type</code> is ill-formed.
          </cxx-example>
          </p>

          <p> A type constraint that names a class template specialization 
          does not require that type to be complete 
          (<cxx-ref in="cxx" to="basic.types"></cxx-ref>). </p>

          <p> A type constraint <code>P</code> subsumes another type
          constraint <code>Q</code> if and only if the types in <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.type -->


        <!-- ===============================
             Implicit conversion constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.conv">
          <h1>Implicit conversion constraints</h1>

          <p> An <dfn>implicit conversion constraint</dfn> is an atomic
          constraint that specifies a requirement 
          on the implicit conversion of an 
          <cxx-grammarterm>expression</cxx-grammarterm>
          <code>E</code> to a type <code>T</code>. 

          The constraint is satisfied if and
          only if <code>E</code> is implicitly convertible to <code>T</code>
          (Clause <cxx-ref in="cxx" to="conv"></cxx-ref>).
          
          <cxx-note>
          A conversion constraint is introduced by a
          <cxx-grammarterm>trailing-return-type</cxx-grammarterm> in a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> when
          the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> contains 
          no placeholders (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = 
requires (T a, T b) {
  { a == b } -> bool;
};
          </cxx-codeblock>
          The <cxx-grammarterm>compound-requirement</cxx-grammarterm> in the
          <cxx-grammarterm>requires-expression</cxx-grammarterm> of <code>C</code>
          introduces two atomic constraints: an expression constraint
          for <code>a == b</code>, and the implicit conversion constraint that 
          the expression <code>a == b</code> is implicitly convertible to
          <code>bool</code>.
          </cxx-example>
          </p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          T1 is convertible to T2. -->

          <p> An implicit conversion constraint <code>P</code> subsumes 
          another implicit conversion constraint <code>Q</code> if and only if
          the <cxx-grammarterm>expression</cxx-grammarterm>s of 
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"></cxx-ref>) and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>).</p>

        </cxx-section> <!-- temp.constr.atom.conv -->


        <!-- ==============================
             Argument deduction constraints
             ============================== -->

        <cxx-section id="temp.constr.atom.deduct">
          <h1>Argument deduction constraints</h1>

          <p> An <dfn>argument deduction constraint</dfn> is an atomic
          constraint that specifies a requirement on 
          the usability of an <cxx-grammarterm>expression</cxx-grammarterm> 
          <code>E</code> as an argument to an invented abbreviated
          function template <code>F</code> (<cxx-ref to="dcl.fct"></cxx-ref>),
          where <code>F</code> has a single parameter formed from a type that 
          includes placeholders 
          (<cxx-ref to="dcl.spec.auto"></cxx-ref>, <cxx-ref to="dcl.spec.constr"></cxx-ref>).

          <cxx-note>
          An argument deduction constraint is introduced by a
          <cxx-grammarterm>trailing-return-type</cxx-grammarterm> in a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> when the
          <cxx-grammarterm>trailing-type-specifier-seq</cxx-grammarterm>
          contains at least one placeholder
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>

          <cxx-example class="inline">
          <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C1() { return true; }

template&lt;typename T&gt;
  concept bool C2() { return requires(T t) { {*t} -> const C1& x; }; }
          </cxx-codeblock>
          The invented function template for the
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> in
          <code>C2</code> is:
          <cxx-codeblock>
void F(const C1& x);
          </cxx-codeblock>
          </cxx-example>

          The constraint is satisfied if and only if <code>F</code>
          is selected by overload resolution for the call <code>F(E)</code>
          (<cxx-ref to="over.match"></cxx-ref>).

          <cxx-note>
          Overload resolution selects <code>F</code> only when template 
          argument deduction succeeds and <code>F</code>'s associated 
          constraints are satisfied.
          </cxx-note>

          <!--
          <cxx-example>
          <cxx-codeblock>
template&lt;typename T&gt; concept bool C = requires (T t) { ++t; };
template&lt;typename T&gt; concept bool D = requires (T t) { *t -> const C&amp;; };
          </cxx-codeblock>
          The concept <code>D</code> introduces an argument deduction 
          constraint for the expression <code>*t</code>.

          When determining if <code>D</code> is satisfied, overload resolution
          is performed for the call <code>g(*t)</code> against the following 
          invented abbreviated function template:
          <cxx-codeblock>
void g(const C&);
          </cxx-codeblock>
          </cxx-example>
          -->
          </p>

          <!-- FIXME: For two constraints of the form {e} -> T1 (call it P)
          and {e} -> T2 (call it Q), P subsumes Q if e is the same and
          f(T1) is more specialized than f(T2) where f is the corresponding
          invented function template. -->

          <p> An argument deduction constraint <code>P</code> subsumes
          another argument deduction constraint <code>Q</code> if and only
          if the <cxx-grammarterm>expression</cxx-grammarterm>s of
          <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref to="temp.over.link"></cxx-ref>), and the types
          of <code>P</code> and <code>Q</code> are equivalent
          (<cxx-ref in="cxx" to="temp.type"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.deduct -->


        <!-- ===============================
             Exception constraints
             =============================== -->

        <cxx-section id="temp.constr.atom.noexcept">
          <h1>Exception constraints</h1>

          <p> An <dfn>exception constraint</dfn> is an atomic constraint
          for an expression <code>E</code> that is satisfied if and only
          if the expression <code>noexcept(E)</code> is <code>true</code>
          (<cxx-ref in="cxx" to="expr.unary.noexcept"></cxx-ref>).
          
          <cxx-note>
          Constant expression constraints are introduced by a
          <cxx-grammarterm>compound-requirement</cxx-grammarterm> that
          includes the <code>noexcept</code> specifier
          (<cxx-ref to="expr.prim.req.compound"></cxx-ref>).
          </cxx-note>
          </p>

          <p> An exception constraint <code>P</code> subsumes another
          exception constraint <code>Q</code> if and only if the
          <cxx-grammarterm>expression</cxx-grammarterm>s of <code>P</code>
          and <code>Q</code> are equivalent 
          (<cxx-ref to="temp.over.link"></cxx-ref>). </p>

        </cxx-section> <!-- temp.constr.atom.noexcept -->

    </cxx-section> <!-- temp.constr.atom -->


    <!-- ===============================
         Partial ordering of constraints
         =============================== -->

    <cxx-section id="temp.constr.order">
      <h1>Partial ordering by constraints</h1>

      <p>
      In order to determine if a constraint <code>P</code> subsumes a constraint
      <code>Q</code>, transform <code>P</code> into disjunctive normal
      form (a disjunction of clauses, each of which is a conjunction
      of atomic propositions), and transform <code>Q</code> into conjunctive
      normal form (a conjunction of clauses, each of which is a disjunction
      of atomic propositions).
      <cxx-example class="inline">
      Let <code>A</code>, <code>B</code>, and <code>C</code> be atomic
      constraints. 

      The constraint 
      <code>A</code> &and; (<code>B</code> &or; <code>C</code>) 
      is in conjunctive normal form.

      Its conjunctive clauses are <code>A</code> and
      (<code>B</code> &or; <code>C</code>).
      
      The disjunctive normal form of the constraint
      <code>A</code> &and; (<code>B</code> &or; <code>C</code>) 
      is
      (<code>A</code> &and; <code>B</code>) &or; (<code>A</code> &and; <code>C</code>).
      
      Its disjunctive clauses are 
      (<code>A</code> &and; <code>B</code>) and
      (<code>A</code> &and; <code>C</code>).
      </cxx-example>
      
      The disjunctive normal form of <code>P</code> subsumes the 
      conjunctive normal form of <code>Q</code>
      if and only if every disjunctive clause in 
      <code>P<sub><i>i</i></sub></code> subsumes each 
      conjunctive clause in <code>Q<sub><i>j</i></sub></code>. 

      A disjunctive clause
      <code>P<sub><i>i</i></sub></code> subsumes a conjunctive clause 
      <code>Q<sub><i>j</i></sub></code> when each atomic constraint in 
      <code>P<sub><i>i</i></sub></code> subsumes any atomic constraint in
      <code>Q<sub><i>j</i></sub></code>.

      The rules for determining whether one atomic constraint subsumes
      another are defined for each kind of atomic constraint
      (<cxx-ref to="temp.constr.atom"></cxx-ref>).

      <cxx-example class="inline">
      Let <code>A</code> and <code>B</code> be
      predicate constraints (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>).

      The constraint <code>A &and; B</code> subsumes <code>A</code>, 
      but <code>A</code> does not subsume <code>A &and; B</code>. 

      The constraint <code>A</code> subsumes <code>A &or; B</code>, but
      <code>A &or; B</code> does not subsume code <code>A</code>. 

      Also, any constraint <code>P</code> subsumes itself.
      </cxx-example>
      </p>


      <p>The subsumption relation defines a partial ordering on constraints. 
      This partial ordering is used to determine </p>

      <ul>
      <li> the best viable candidate of non-template functions
           (<cxx-ref to="over.match.best"></cxx-ref>), </li>
      <li> the address of a non-template function
           (<cxx-ref to="over.over"></cxx-ref>), </li>
      <li> the matching of template template arguments
           (<cxx-ref to="temp.arg.template"></cxx-ref>), </li>
      <li> the partial ordering of class template specializations
           (<cxx-ref to="temp.class.order"></cxx-ref>), and</li>
      <li> the partial ordering of function templates
           (<cxx-ref to="temp.func.order"></cxx-ref>).</li>
      </ul>

      <p> When two declarations <code>D1</code> and <code>D2</code> are
      partially ordered by their normalized constraints, <code>D1</code> is 
      <dfn>more constrained</dfn> than <code>D2</code> if

      <ul>
      <li> <code>D1</code> and <code>D2</code> are both constrained
      declarations and <code>D1</code>'s associated constraints subsume but 
      are not subsumed by those of <code>D2</code>; or</li>

      <li> <code>D1</code> is constrained and <code>D2</code> is
      unconstrained. </li>
      </ul>

      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = requires(T t) { --t; };
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt; &amp;&amp; requires(T t) { *t; };

template&lt;C1 T&gt; void f(T);       // <i>#1</i>
template&lt;C2 T&gt; void f(T);       // <i>#2</i>
template&lt;typename T&gt; void g(T); // <i>#3</i>
template&lt;C1 T&gt; void g(T);       // <i>#4</i>

f(0);       // <i>selects #1</i>
f((int*)0); // <i>selects #2</i>
g(true);    // <i>selects #3 because</i> C1&lt;bool&gt; <i>is not satisfied</i>
g(0);       // <i>selects #4</i>
      </cxx-codeblock>
      </cxx-example>

      <p> A declaration <code>D1</code> is <dfn>at least as constrained</dfn>
      as another declaration <code>D2</code> when <code>D1</code> is more
      constrained than <code>D2</code> and <code>D2</code> is not more
      constrained than <code>D1</code>. </p>

    </cxx-section> <!-- temp.constr.order -->



    <!-- ======================
         Constraint expressions
         ====================== -->

    <cxx-section id="temp.constr.expr">
      <h1>Constraint expressions</h1>

      <p>Certain contexts require expressions that can be transformed
      into constraints through the process of <dfn>normalization</dfn>.
      <bnf-grammar>
        <bnf-rule>constraint-expression</bnf-rule>
          <bnf-alt>logical-or-expression</bnf-alt>
      </bnf-grammar>
      </p>

      <p> A <cxx-grammarterm>constraint-expression</cxx-grammarterm>
      is <dfn>normalized</dfn> by forming a constraint
      as follows.

      <ul>
      <li> The normalized form of <code>(P)</code> is the normalized form of 
      <code>P</code>.</li>

      <li> The normalized form of <code>P || Q</code> is
      the disjunction (<cxx-ref to="temp.constr.op.disj"></cxx-ref>) of the 
      normalized form of <code>P</code> and the normalized form of 
      <code>Q</code>.</li>

      If, after substitution, overload resolution 
      (<cxx-ref to="over.match"></cxx-ref>) selects a user-declared 
      <code>operator||</code>, the program is ill-formed.</li>

      <li> The normalized form of <code>P &amp;&amp; Q</code> is
      the conjunction (<cxx-ref to="temp.constr.op.conj"></cxx-ref>) of the 
      normalized form of <code>P</code> and the normalized form of
      <code>Q</code>.

      If, after substitution, overload resolution 
      (<cxx-ref to="over.match"></cxx-ref>) selects a user-declared 
      <code>operator&amp;&amp;</code>, the program is ill-formed.</li>

      <li> The normalized form of a function call of the form
      <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;()</code>,
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a function
      concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>), is the result of 
      substituting the template arguments into the expression
      returned by <code>C</code>.</li>

      <li> The normalized form of an <cxx-grammarterm>id-expression</cxx-grammarterm>
      of the form <code>C&lt;A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub>&gt;</code>
      where <code>A<sub><i>1</i></sub>, A<sub><i>2</i></sub>, ..., A<sub><i>n</i></sub></code>
      is a sequence of template arguments and <code>C</code> names a variable
      concept (<cxx-ref to="dcl.spec.concept"></cxx-ref>) is the result of 
      substituting the template arguments into the initializer
      of <code>C</code>.</li>

      <li> The normalized form of a 
      <cxx-grammarterm>requires-expression</cxx-grammarterm> 
      (<cxx-ref to="expr.prim.req"></cxx-ref>) is
      the conjunction of constraints (<cxx-ref to="temp.constr.op.conj"></cxx-ref>) 
      introduced by the body of that expression.
      </li>

      <li> Otherwise, <code>E</code> is a predicate constraint 
      (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>). 

      After substitution, <code>E</code> shall be a converted constant 
      expression of type <code>bool</code>.
      </li>
      </ul>

      <!-- TODO: Do we need a top-level conversion requirement for
           constraint expressions? -->

      <cxx-note>
      A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
      defines a subset of constant expressions over which certain 
      logical implications can be deduced during translation.

      The prohibition against user-defined logical operators is intended to
      prevent the subversion of the logic used to partially
      order constraints (<cxx-ref to="temp.constr.order"></cxx-ref>).
      </cxx-note>

      <!-- TODO: Make this a table -->
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1() { return sizeof(T) == 1; }
template&lt;typename T&gt; concept bool C2 = C1&lt;T&gt;() &amp;&amp; 1 == 2;
template&lt;typename T&gt; concept bool C3 = requires () { typename T::type; };

// <i>Expression</i>      // <i>Constraints</i>
C2&lt;char&gt;           sizeof(char) == 1 /* <i>and</i> */ 1 == 2
C3&lt;int&gt;            /* <i>type constraint for</i> int::type */
3 + 4              // <i>error: not a constraint</i>
(bool)(3 + 4)      (bool)(3 + 4)
      </cxx-codeblock>
      In the normalized constraints, the expressions <code>sizeof(char) == 1</code>, 
      <code>1 == 2</code>, and <code>(bool)(3 + 4)</code> are predicate 
      constraints (<cxx-ref to="temp.constr.atom.pred"></cxx-ref>). 

      The concept <code>C3</code> is normalized to a single type constraint
      (<cxx-ref to="temp.constr.atom.type"></cxx-ref>) for the (ill-formed) 
      type <code>int::type</code>.

      The expression <code>3 + 4</code> is not a 
      <cxx-grammarterm>constraint-expression</cxx-grammarterm> because it does
      not satisfy the requirements for being normalized into a predicate 
      constraint.
      </cxx-example>

    </cxx-section> <!-- temp.constr.expr -->


    <!-- ==================
         Concept resolution
         ================== -->

    <cxx-section id="temp.concept.resolve">
      <h1>Concept resolution</h1>

      <p> Whenever a <cxx-grammarterm>identifier</cxx-grammarterm> is a
      <cxx-grammarterm>concept-name</cxx-grammarterm>, it is necessary to
      determine a single concept referred to by the use of that name.

      <p> <dfn>Concept resolution</dfn> is the process of selecting a concept 
      from a set of concept definitions referred to by a concept name.
      
      Concept resolution is performed when a 
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> appears in
      the declaration of an abbreviated function (<cxx-ref to="dcl.fct"></cxx-ref>)
      or generic lambda (<cxx-ref to="expr.prim.lambda"></cxx-ref>),
      in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a
      <cxx-grammarterm>compound-requirement</cxx-grammarterm>, the
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> of a
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, or
      in a <cxx-grammarterm>template-introduction</cxx-grammarterm>.
      </p>

      <p> A concept is selected from a set of concepts based on a sequence
      of <dfn>template argument pattern</dfn>s and a sequence of explicit
      template arguments. 

      A template argument pattern is a kind of template argument that is used 
      to match the type and form of any template parameter from a concept 
      definition. A template argument pattern can be a pack expansion.

      A concept is selected from the set by matching the template
      argument patterns and explicit template arguments against the template 
      parameters of that concept. </p>

      <p>
      When selecting a concept for a 
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
      there is a single template argument pattern. 
      
      If, the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
      appears in the declaration of a
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm> 
      (<cxx-ref to="temp.param"></cxx-ref>) and is
      followed by an ellipsis, the template argument pattern is a pack
      expansion.

      If the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> the explicit
      <cxx-grammarterm>template-arguments</cxx-grammarterm> are those in
      the <cxx-grammarterm>partial-concept-id</cxx-grammarterm>.

      When selecting a concept for a 
      <cxx-grammarterm>concept-name</cxx-grammarterm>
      in a <cxx-grammarterm>template-introduction</cxx-grammarterm>, there
      is one template argument pattern for each 
      <cxx-grammarterm>introduced-parameter</cxx-grammarterm>.

      If an <cxx-grammarterm>introduced-parameter</cxx-grammarterm> is
      preceded by an ellipsis, its corresponding template argument pattern
      is a pack expansion.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1() { return true; }
template&lt;typename T, typename U&gt; concept bool C1() { return true; }
template&lt;typename... T&gt; concept bool C2() { return true; }

void f(1C1); 
void f2(C1&lt;int&gt;);
      </cxx-codeblock>
      In the resolution of required by the declaration of <code>f1</code>, 
      there is a single template argument pattern and zero explicit template 
      arguments.

      For <code>f2</code> there is a single template argument pattern and the 
      single explicit template argument, <code>int</code>.
      <cxx-codeblock>
C1{T} void f3(T);
C1{T, U} void f4(T);
      </cxx-codeblock>
      In the resolution required by the declaration of <code>f3</code>, there
      is a single template argument pattern; there are two in the resolution
      required by <code>f2</code>. There are zero explicit template arguments
      in the resolutions of <code>f1</code> and <code>f2</code>.
      <cxx-codeblock>
C2{...T} void f5();
      </cxx-codeblock>
      There is a single template argument pattern in the resolution of
      <code>f2</code>, and it is a pack expansion.
      </cxx-example>
      </p>

      <p>
      For each concept <code>C</code> in the concept set, each template 
      argument in the combined sequence of template argument patterns and explicit 
      template arguments is matched against the corresponding template parameter
      in the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>C</code> as follows.

      A template argument pattern that is not a parameter pack matches a 
      non-pack template parameter of any type and form. A template argument 
      pattern that is a parameter pack matches a template parameter pack
      whose pattern is any form.

      The remaining explicit arguments are matched against parameters
      according in the usual way (<cxx-ref to="temp.arg"></cxx-ref>).

      If any template argument patterns or explicit template arguments do not 
      match the corresponding parameter, <code>C</code> is removed from the set.
      
      If a single concept remains, that concept is the one selected
      by concept resolution. Otherwise, the program is ill-formed. </p>

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }
template<&lt;typename... Ts> concept bool Q = true;

void f1(const C*);  // <i>OK:</i> C <i>selects #1</i>
void f2(C&lt;char&gt;);   // <i>OK:</i> C&lt;char&gt; <i>selects #2</i>
void f3(C&lt;3&gt;);      // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);         // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i>
Q{...Ts} void q1(); // <i>OK: selects</i> Q
Q{T} void q2();     // <i>error: no matching concept (mismatched template arguments)</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      For the selected template, the set of template parameters corresponding
      to the matched template argument patterns are called the
      <dfn>selected template parameters</dfn>. In 
      <cxx-grammarterm>template-introductions</cxx-grammarterm>, these
      are used to derive the declarations of introduced parameters.
      </p>
    </cxx-section> <!-- temp.concept.resolve -->


    <!-- ==================
         Concept resolution
         ================== -->

    <cxx-section id="temp.constr.form">
      <h1>Constraint formation</h1>

      <p> When a parameter of an abbreviated function template is declared
      with a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      or in the declaration of a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>,
      the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      associates a <cxx-grammarterm>constraint-expression</cxx-grammarterm>
      with the respective function or template declaration.

      The formation of that <cxx-grammarterm>constraint-expression</cxx-grammarterm>
      is derived from the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
      the designated concept selected by concept resolution 
      (<cxx-ref to="temp.concept.resolve"></cxx-ref>), and an 
      invented template parameter or a declared template parameter, called
      the <dfn>target template parameter</dfn>.
      
      When the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      appears in the declaration of a function parameter, the target template
      parameter is the one invented for the abbreviated function template
      (<cxx-ref to="dcl.fct"></cxx-ref>).

      When the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      appears in the declaration of a 
      <cxx-grammarterm>constrained-parameter</cxx-grammarterm>,
      the target template parameter is the declared template parameter.
      </p>

      <p>
      Let <code>C</code> be the concept designated by the
      <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      (including its <cxx-grammarterm>nested-name-specifier></cxx-grammarterm>,
      if any), 
      let <code>P</code> be the prototype parameter of the designated
      concept, and
      let <code>X</code> be the target template parameter.

      Form a new template argument <code>A</code> from <code>X</code> as
      as follows. If <code>X</code> declares a parameter pack, and
      <code>P</code> declares a parameter pack, <code>A</code>
      is pack expansion of <code>X</code>. Otherwise <code>A</code> is
      a template argument referring to <code>X</code>.

      Form a <cxx-grammarterm>template-id</cxx-grammarterm> <code>TT</code>
      as follows. 

      When the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
      is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>, <code>TT</code>
      is <code>C&lt;A, Args&gt;</code> where <code>Args</code> is the sequence of
      <cxx-grammarterm>template-argument</cxx-grammarterm>s in the
      <cxx-grammarterm>partial-concept-id</cxx-grammarterm></code>.
      
      Otherwise, <code>TT</code> is <code>C&lt;A, Args&gt;</code>.

      Form an expression <code>E</code> from <code>TT</code>. If <code>C</code>
      refers to a variable concept, <code>E</code> is the
      <cxx-grammarterm>id-expression</cxx-grammarterm> <code>TT</code>.
      If <code>C</code> refers to a variable concept, <code>E</code> is
      the function call <code>TT()</code>.
      </p>

      <p>
      The formed <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
      the fold expression <code>(E &amp;&amp; ...)</code> 
      (<cxx-ref to="expr.prim.fold"></cxx-ref>)
      when the prototype parameter <code>P</code> declares a template 
      parameter pack and the target template parameter <code>X</code> 
      does not. Otherwise, the 
      <cxx-grammarterm>constraint-expression</cxx-grammarterm> is
      <code>E</code>.


      <!-- TODO: Add examples for constrained parameters 
           TODO: Give an example with a nested name specifier. -->
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C1 = true;
template&lt;typename T, typename U&gt; concept bool C2() { return true; }
template&lt;typename... Ts&gt; concept bool C4;

template&lt;int&gt; struct X { };

void f1(C1&amp;);     // <i>associates</i> C1&lt;T1&gt; <i>with</i> f1
void f2(C2&lt;int&gt;); // <i>associates</i> C2&lt;T2, int&gt;() <i>with</i> f2
void f4(C1...);   // <i>associates</i> (C1<T1> && ...) <i>with</i> f4
void f5(C4...);   // <i>associates</i> C4<T1...> <i>with f5</i>
      </cxx-codeblock>
      Here, <code>T1</code> and <code>T2</code> are invented type template 
      parameters corresponding to the prototype parameter of their respective 
      designated concepts. 
      </p>


  </cxx-section> <!-- temp.constr -->

</cxx-clause> <!-- temp -->


