
<cxx-clause id="over" number="13">
  <h1>Overloading</h1>

  Modify paragraph 1 to allow overloading based on constraints.

  <p class="quoted">
  When two or more different declarations are specified for a single name 
  in the same scope, that name is said to be overloaded. By extension, two 
  declarations in the same scope that declare the same name but with
  different types 
  <ins>or different associated constraints (<cxx-ref to="temp"></cxx-ref>)</ins>
  are called <dfn>overloaded declarations</dfn>. Only function and function 
  template declarations can be overloaded; variable and type declarations 
  cannot be overloaded.
  </p>

  Update paragraph 3 to mention a function's overloaded constraints. 
  Note that the itemized list in the original text is omitted in this
  document.

  <p number="3" class="quoted">
  <cxx-note>
  As specified in <cxx-ref to="dcl.fct"></cxx-ref>, function declarations 
  that have equivalent parameter declarations 
  <ins>and associated constraints, if any (<cxx-ref to="temp"></cxx-ref>)</ins>,
  declare the same function and therefore cannot be overloaded: ...
  </p>


  <cxx-section id="over.dcl" number="2">
    <h1>Declaration matching</h1>

    Modify paragraph 1 to extend the notion of declaration matching to
    also include a function's associated constrains. Note that the
    example in the original text is omitted in this document.

    <p class="quoted">
    Two function declarations of the same name refer to the same function if 
    they are in the same scope and have equivalent parameter declarations 
    (<cxx-ref in="cxx" to="over.load"></cxx-ref>)
    <ins>and equivalent associated constraints, 
    if any (<cxx-ref to="temp"></cxx-ref>)</ins>.
    </p>
  </cxx-section> <!-- over.dcl -->

  <cxx-section id="over.match">
    <h1>Overload resolution</h1>

    <cxx-section id="over.match.viable">
      <h1>Viable functions</h1>

      Update paragraph 1 to require the checking of a candidate's associated
      constraints when determining if that candidate is a viable candidate
      for a function call.

      <p class="quoted">
      From the set of candidate functions constructed for a given context 
      (<cxx-ref in="cxx" to="over.match.funcs"></cxx-ref>), a set of viable 
      functions is chosen, from which the best function will be selected by 
      comparing argument conversion sequences and associated constraints
      for the best fit (<cxx-ref to="over.match.best"></cxx-ref>).

      The selection of viable functions considers 
      <ins>their associated constraints, if any (<cxx-ref to="temp"></cxx-ref>), and</ins>
      their relationships between arguments and function parameters other 
      than the ranking of conversion sequences.
      </p>

      Insert the following paragraph after paragraph 1; this introduces
      new a criterion for determining if a candidate is viable. Also, update
      the beginning of the subsequent paragraphs to account for the
      insertion.

      <p class="quoted" number="2">
      First, for <code>F</code> to be a viable function, if <code>F</code> has 
      associated constraints (<cxx-ref to="temp"></cxx-ref>), those 
      constraints shall be satisfied (<cxx-ref to="temp.constr"></cxx-ref>).
      </p>

      <p class="quoted" number="3">
      <del>First</del><ins>Second</ins>, to be a viable function ...
      </p>

      <p class="quoted" number="4">
      <del>Second</del><ins>Third</ins>, for <code>F</code> to be a viable function ...
      </p>

    </cxx-section> <!-- over.match.viable -->

    <cxx-section id="over.match.best">
      <h1>Best viable function</h1>

      Modify the last item in the list in paragraph 1 and extend it with
      a final comparison based on the associated constraints of those
      functions. This applies to both normal functions and specializations
      of function templates. Note that the preceding (unmodified) items
      in the original document are elided in this document.

      <p class="quoted">
      Define ICS<i>i</i>(<code>F</code>) as follows:
      <ul>
      <li> ... </li>
      <li> <code>F1</code> and <code>F2</code> are function template 
      specializations, and the function template for <code>F1</code> is more 
      specialized than the template for <code>F2</code> according to the 
      partial ordering rules described in 
      <cxx-ref to="temp.func.order"></cxx-ref><del>.</del><ins>, or, 
      if not that,</ins> </li>
      
      <li><ins>
      <code>F1</code> is more constrained than <code>F2</code> according to
      the partial ordering of constraints described in 
      <cxx-ref to="temp.constr"></cxx-ref>.</ins></li>
      </ul>
      <!-- </p> -->
    </cxx-section> <!-- over.match.best -->
  </cxx-section> <!-- over.match -->

  <cxx-section id="over.over">
    <h1>Address of overloaded function</h1>

    The introduction of constraints modifies the rules for determining
    which function is selected when taking the address of an overloaded
    function. Insert a new paragraph before paragraph 4.

    <p class="quoted" number="4">
    If a single constrained function is selected, and the constraints are
    not satisfied (<cxx-ref to="temp.constr"></cxx-ref>), the program
    is ill-formed. 
    </p>

    Replace the existing paragraph 4 with this paragraph.

    <!-- FIXME: This algorithm is going to be a common theme. It should
         be called out somewhere in overload resolution. -->
    <p class="quote" number="5">
    If more than one function, any function or function template specialization
    in that set are eliminated if their associated constraint (if any) are not 
    satisfied (<cxx-ref to="temp.constr"></cxx-ref>). Among the remaining
    functions, the following rules are used to choose the  the best function. 

    A selected function <code>F1</code> is a better choice another selected 
    function <code>F2</code> if:
    <ul>
    <li><code>F1</code> is not a function template specialization and
    <code>F2</code>is a function template specialization, or if not that,</li>
    
    <li><code>F1</code> and <code>F2</code> are function template 
    specializations, and the function template for <code>F1</code> is more 
    specialized than the template for <code>F2</code> according to the partial 
    ordering rules described in <cxx-ref to="temp.func.order"></cxx-ref>,
    or if not that, </li>

    <li><code>F1</code> is more constrained than <code>F2</code> according
    to the partial ordering rules described in 
    <cxx-ref to="temp.constr"></cxx-ref>.
    </ul>
    If there is exactly one function that is better than all others, then
    that is the selected function. Otherwise, the program is ill-formed.

    Include the following examples in paragraph 5 (paragraph 6 in this
    document):

    <p class="quote" number="6">
    <cxx-example>
    <cxx-codeblock>
void f() { }                // <i>#1</i>
void f() requires true { }; // <i>#2</i>
void g() requires false;

void (*pf)() = &amp;f;         // <i>selects #2</i>
void (*pg)() = &amp;g;         // <i>error: g() cannot be selected</i>
    </cxx-codeblock>
    </cxx-example>
    </p>
    </cxx-section> <!-- over.over -->

</cxx-clause>
