<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="base.css"/>
  <script src="promise-0.1.1.min.js"></script>
  <script src="bower_components/platform/platform.js"></script>
  <link rel="import" href="bower_components/polymer/polymer.html"/>
  <link rel="import" href="elements/section.html"/>
  <link rel="import" href="elements/clause.html"/>
  <link rel="import" href="elements/table.html"/>
  <link rel="import" href="elements/definition-section.html"/>
  <link rel="import" href="elements/toc.html"/>
  <link rel="import" href="elements/ref.html"/>
  <link rel="import" href="elements/foreign-index.html"/>
  <link rel="import" href="elements/function.html"/>
  <link rel="import" href="elements/titlepage.html"/>
  <link rel="import" href="elements/email.html"/>
  <link rel="import" href="elements/ednote.html"/>
  <link rel="import" href="elements/note.html"/>
  <link rel="import" href="elements/example.html"/>
  <link rel="import" href="elements/grammar.html"/>
  <link rel="import" href="elements/codeblock.html"/>
  <link rel="import" href="elements/publish.html"/>
  <script language="javascript">
  </script>
</head>
<body>
<cxx-titlepage stage="draft">
  <cxx-docnum>N3929</cxx-docnum>
  <time pubdate="">2014-02-14</time>
  <cxx-revises><a href="http://isocpp.org/files/papers/N3848.html">N3889</a></cxx-revises>
  <cxx-editor>
    Andrew Sutton<br/>
    University of Akron<br/>
    <cxx-email>asutton@uakron.edu</cxx-email>
  </cxx-editor>
  <h1>Information technology – Programming languages, their environments and 
  system software interfaces – C++ Extensions for Concepts</h1>
</cxx-titlepage>

<cxx-toc></cxx-toc>

<cxx-clause id="general">
  <h1>General</h1>

  <cxx-section id="general.intro">
    <h1>Introduction</h2>
    
    <p>C++ has long provided language support for generic programming in 
    the form of templates. 
    However, these templates are unconstrained, allowing any type or value 
    to be substituted for a template argument, often resulting in compiler 
    errors. 
    
    What is lacking is a specification of an interface for a template, 
    separate from its implementation, so that a use of a template can be 
    selected among alternative templates and checked in isolation.</p>

    <p>A concept is a predicate that defines the syntactic and semantic 
    requirements on template arguments. 
    A template argument that satisfies these requirements is said to be a 
    <emph>model</emph> of that concept, or that the argument 
    <emph>models</emph> the concept.
    
    Syntactic requirements specify the set of valid expressions that can 
    be used with conforming types and the types associated with those 
    expressions. 
    
    Semantic requirements describe the required behavior of those syntactic 
    requirements and also provide complexity guarantees. 
    
    Concepts are the basis of generic programming in C++ and support the 
    ability to reason about generic algorithms and data structures 
    independently of their instantiation by concrete template arguments.</p>

    <p>Concepts are not new to C++ or even to C (where Integral and 
    Arithmetic are long-established concepts used to specify the language 
    rules for types); the idea of stating and enforcing type requirements 
    on template arguments has a long history. For example, several methods are 
    discussed in <emph>The Design and Evolution of C++</emph> (1994). 
    Concepts were a part of documentation of the STL and are used to 
    express requirements in the C++ standard, ISO/IEC 14882. 
    For example, Table 106 gives the definition of the STL 
    <code>Iterator</code> concept as a list of valid expressions and their 
    result types, operational semantics, and pre- and  post-conditions.</p>

    <p>This specification describes a solution to the problem of 
    constraining template arguments in the form "Concepts Lite." The 
    goals of "Concepts Lite" are to
    <ul>
      <li>allow programmers to directly state the requirements of a set of 
      template arguments as part of a template's interface,</li>

      <li>support function overloading and class template specialization 
        based on constraints,</li>

      <li>seamlessly integrates a number of orthogonal features to provide
      uniform syntax and semantics for generic lambdas, <code>auto</code>
      declarations, and result type deduction,</li>

      <li>fundamentally improves diagnostics by checking template arguments 
      in terms of stated intent at the point of use,</li>

      <li>do all of this without any runtime overhead or longer compilation 
      times, when comparing similar programs using 
      <code>enable_if</code>.</li>
    </ul>
    "Concepts Lite" does not provide facilities for checking template 
    definitions separately from their instantiation, nor does it provide 
    facilities for specifying or checking semantic requirements.</p>


    <p>This Technical Specification specifies requirements for 
    implementations of an extension to the C++ programming language 
    concerning the application of constraints to template arguments, 
    the use of constraints in function overloading and class template 
    specialization, and the definition of those constraints.</p>

    <p>International Standard, ISO/IEC 14882, provides important context
    and specification for this Technical Specification. This document as 
    written as a set of changes against that specification. Notes in 
    this Technical Specification indicate how and where new text should 
    be added to or removed from the International Standard. 
    <cxx-note>The proposal is written against the C++14 specification,
    whatever its final document number may be.</cxx-note></p>

<!-- TOOD: Move text from intro into scope. -->
<!--   <cxx-section id="general.scope">
    <h1>Scope</h1>
  </cxx-section>
 -->
  
  <cxx-section id="general.references">
    <h1>Normative references</h1>

    <!-- TODO: Find the current WD number -->
    <cxx-ednote>The TS will formally refer to the ISO/IEC document
    defining the C++14 programming language. Until that document is
    published, the paper targets the current working draft
    NXXX</cxx-ednote>

    <p>The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>
    <ul>
      <li>ISO/IEC XXXX:2014, <cite>Programming Languages — C++</cite>
      <cxx-foreign-index id="cxx" src="cxx14_index.json" name="C++14"></cxx-foreign-index></li>
    </ul>

    <p>ISO/IEC XXXX:2011 is herein after called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++14
    &#xa7;3.2".</p>
  </cxx-section>

  <cxx-section id="general.defns">
    <h1>Terms and definitions</h1>

    <p>For the purposes of this document, the terms and definitions
    given in the C++ Standard and the folowing apply.</p>

    <dl is="cxx-definition-section">
      <dt id="atomic.defns.atomic-constraint">atomic constraint</dt>
      <dd> A subexpression of a constraint that is not a 
      <cxx-grammarterm>logical-and-expression</cxx-grammarterm>,
      <cxx-grammarterm>logical-or-expression</cxx-grammarterm>,
      or a subexpression of an atomic constraint. </dd>

<!-- FIXME: Formatting for multiple definitions is broken. 
      And uncommenting this breaks the formatting for the rest
      of the entire document.

      <dt id="atomic.defns.associated-constraint">associated constraint</dt>
      <dd>A conjunction of all constraints on a constrained template 
        declaration that includes constraints on template parameters, 
        constraints on function parameters, and constraints specified 
        explicitly in a <cxx-grammarterm>requires-clause</cxx-grammarterm>.</dd>
 
      <dt id="atomic.defns.concept">concept</dt>
      <dd>A template declared with the <code>concept</code> declaration 
      specifier.</dd>

      <dt id="atomic.defns.concept-check">concept check</dt>
      <dd>A call to a function concept or a 
      <cxx-grammarterm>template-id</cxx-grammarterm> that names a variable 
      concept.</dd>

      <dt id="atomic.defns.constraint">constraint</dt>
      <dd>A constant expression with type <code>bool</code> that evaluates 
      properties of template arguments, determining whether or not they 
      can be substituted into a template.</dd>

      <dt id="atomic.defns.constrained-declaration">constrained-declaration</dt>
      <dd>A declaration with associated constraints.</dd>

      <dt id="atomic.defns.generic-function">generic function</dt>
      <dd>A constant expression that evaluates requirements of a template 
      argument.</dd>

      <dt id="atomic.defns.introdduced-parameters">introduced parameters</dt>
      <dd>A function declaration having <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name<cxx-grammarterm> in the type 
      specifier any of its parameters.</dd>
 -->
    </dl>
  </cxx-section>

  <cxx-section id="general.conformance">
    <h1>Future plans (Informative)</h1>
    <p>Conformance requirements for this specification are the same as those 
    defined in <cxx-ref in="cxx" to="intro.compliance"></cxx-ref>.
    <cxx-note>Conformance is defined in terms of the behavior of
    programs.</cxxnote></p>
  </cxx-section>

  <cxx-section id="general.acknowledgements">
    <h1>Acknowledgements</h1>
  
    <p>The design of this specification is based, in part, on a concept 
    specification of the algorithms part of the C++ standard library, known 
    as ``The Palo Alto" TR (WG21 N3351), which was developed by a large 
    group of experts as a test of the expressive power of the idea of 
    concepts. Despite syntactic differences between the notation of the 
    Palo Alto TR and this TS, the TR can be seen as a large-scale test of 
    the expressiveness of this TS.</p>

    <p>This work was funded by NSF grant CCF-XXXXXX.</p>
  </cxx-section>
</cxx-clause>

<cxx-clause id="lex">
  <h1>Lexical conventions</h2>

  <cxx-section id="lex.key"</cxx-section>
    <h1>Keywords</h1>

    <p>In <cxx-ref in="cxx" to="lex.key"></cxx-ref>, Table 4, add 
    the keywords <code>concept</code> and <code>requires</code>.</p>

  </cxx-section>
</cxx-clause>

<cxx-clause id="expr">
  <h1>Expressions</h1>

  <cxx-section id="expr.prim">
    <h1>Primary expressions</h1>

    <p>In <cxx-ref in="cxx" to="expr.prim.general"></cxx-ref>, add
    <cxx-grammarterm>requires-expression</cxx-grammarterm> to the
    rule, <cxx-grammarterm>primary-expression<cxx-grammarterm>.</p>
    
    <!-- TODO:  Don't list existing elements -->
    <bnf-grammar>
      <bnf-rule>primary-expression</bnf-rule>
        <bnf-alt>literal</bnf-alt>
        <bnf-alt><bnf-terminal>this</bnf-terminal></bnf-alt>
        <bnf-alt>...</bnf-alt>
        <ins><bnf-alt>requires-expression</bnf-alt></ins>
    </bnf-grammar>

    <cxx-section id="expr.lambda">
    <h1>Lambda expressions</h1>

    <p>The closure type for a non-generic
    <cxx-grammarterm>lambda-expression</cxx-grammarterm> has a public
    <code>inline</code> function call operator 
    <cxx-ref in="cxx" to="over.over"></cxx-ref>) whose parameters 
    and return type 
    are described by the <cxx-grammarterm>lambda-expression</cxx-grammarterm>'s 
    <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> and 
    <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
    respectively. 
    
    For a generic lambda, the closure type has a public inline function call 
    operator member template <cxx-ref in="cxx" to="temp.mem"></cxx-ref> 
    whose <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
    consists of one invented type 
    <cxx-grammarterm>template-parameter</cxx-grammarterm> for each 
    occurrence of <code>auto</code> <ins>or each unique occurrence of a 
    <cxx-grammarterm>constrained-type-name</cxx-grammarterm></ins>
    in the lambda's 
    <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
    in order of appearance. 

    The invented type template-parameter is a parameter 
    pack if the corresponding 
    <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
    declares a function parameter pack 
    <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>. 
    <ins>The associated constraints of the generic lambda are the 
    conjunction of constraints introduced by the use of 
    <cxx-grammarterm>constrained-type-name</cxx-grammarterm>s in the
    <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>.</ins>
    
    The return type and function parameters of the function call operator 
    template are derived from the 
    <cxx-grammarterm>lambda-expression</cxx-grammarterm>'s 
    <cxx-grammarterm>trailing-return-type</cxx-grammarterm> and 
    <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
    by replacing each occurrence of <code>auto</code> in the 
    <cxx-grammarterm>decl-specifiers</cxx-grammarterm> of the
    <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm> with the 
    name of the corresponding invented 
    <cxx-grammarterm>template-parameter</cxx-grammarterm>. </p>

    <p>All placeholder types introduced using the same 
    <cxx-grammarterm>concept-name</cxx-grammarterm> have the same invented
    template parameter.</p>
    </cxx-section>


  <cxx-section id="expr.req">
    <h1>Requires expressions</h1>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> provides a 
    concise way to express syntactic requirements on template arguments.
    <bnf-grammar>
      <bnf-rule>requires-expression</bnf-rule>
        <bnf-alt><bnf-terminal>requires</bnf-terminal> 
          requirement-parameter-list requirement-body</bnf-alt>

    <bnf-rule>requirement-parameter-list</bnf-rule>
      <bnf-alt>
        <bnf-terminal>(</bnf-terminal> 
        parameter-declaration-clause<bnf-opt></bnf-opt>
        <bnf-terminal>)</bnf-terminal>
      </bnf-alt>

    <bnf-rule>requirement-body</bnf-rule>
      <bnf-alt>
        <bnf-terminal>{</bnf-terminal> 
        requirement-list 
        <bnf-terminal>}</bnf-terminal> 
      </bnf-alt>

    <bnf-rule>requirement-list</bnf-rule>
      <bnf-alt>requirement</bnf-alt>
      <bnf-alt>requirement-list requirement</bnf-alt>

    <bnf-rule>requirement</bnf-rule>
      <bnf-alt>simple-requirement</bnf-alt>
      <bnf-alt>compound-requirement</bnf-alt>
      <bnf-alt>type-requirement</bnf-alt>
      <bnf-alt>nested-requirement</bnf-alt>

    <bnf-rule>simple-requirement</bnf-rule>
      <bnf-alt>expression <bnf-terminal>;</bnf-terminal></bnf-alt>

    <bnf-rule>compound-requirement</bnf-rule>
      <bnf-alt>
        <bnf-terminal>constexpr</bnf-terminal><bnf-opt></bnf-opt>
        <bnf-terminal>{</bnf-terminal> expression <bnf-terminal>}</bnf-terminal>
        <bnf-terminal>noexcept</bnf-terminal><bnf-opt></bnf-opt>
        trailing-return-type<bnf-opt></bnf-opt>
        <bnf-terminal>;</bnf-terminal>
      </bnf-alt>

    <bnf-rule>type-requirement</bnf-rule>
      <bnf-alt>
        <bnf-terminal>typename</bnf-terminal>type-id<bnf-terminal>;</bnf-terminal>
      </bnf-alt>

    <bnf-rule>nested-requirement</bnf-rule>
      <bnf-alt>requires-clause <bnf-terminal>;</bnf-terminal></bnf-alt>
    </bnf-grammar>
    </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> has type
    <code>bool</code>. </p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> shall not appear
    outside a template declaration. </p>

    <p>
    <cxx-example>
    The most common use of 
    <cxx-grammarterm>requires-expression</cxx-grammarterm>s is to define
    syntactic requirements in concepts <cxx-ref to="decl.constr"></cxx-ref> 
    such as the one below:
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool R() {
    return requires (T i) {
      typename A&lt;T&gt;;
      {*i} -> const A&lt;T&gt;&amp;;
    };
  }
    </cxx-codeblock>
    The concept is defined in terms of the syntactic and type requirements 
    within the <cxx-grammarterm>requires-expression</cxx-grammarterm>.
    
    A <cxx-grammarterm>requires-expression</cxx-grammarterm> can also be
    used in non-concept templates as a way of writing ad hoc constraints
    on template arguments such as the one below:
    <cxx-codeblock>
template&lt;typename T&gt;
  requires requires (T x) { x + x; }
    T add(T a, T b) { return a + b; }
  }
    </cxx-codeblock>
    Any use outside of a concept or 
    <cxx-grammarterm>requires-clause</cxx-grammarterm> 
    <cxx-ref to="temp.constr"></cxx-ref> will almost certainly make the
    program ill-formed. For example:
    <cxx-codeblock>
template&lt;typename T&gt;
  constexpr bool f(T a, T b) { 
    return requires() { a + b };
  }

template&lt;typename T&gt;
  T g(T x, T y) {
    if (has_plus(x, y))
      return x + y;
  }

struct X { } p, q;
g(p, q); // <em style="font-family:times">Error: no matching operator+</em>
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The <cxx-grammarterm>requires-expression</cxx-grammarterm> may introduce
    local arguments via a <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>. 
    These parameters have no linkage, storage, or lifetime.
    They are used only to write constraints within the
    <cxx-grammarterm>requirement-body</cxx-grammarterm> and are not visible
    outside the closing <code>}</code> of the 
    <cxx-grammarterm>requirement-body</cxx-grammarterm>. 
    The <cxx-grammarterm>requirement-body</cxx-grammarterm>is a list of 
    requirements written as statements. These statements may refer to local 
    arguments, template parameters, and any other declarations visible from the 
    enclosing context.</p>

    <p>The <cxx-grammarterm>requirement-parameter-list</cxx-grammarterm> shall
    not include an ellipsis.</p>

    <p>A <cxx-grammarterm>requires-expression</cxx-grammarterm> evaluates to
    <code>true</code> if and only if every 
    <cxx-grammarterm>requirement</cxx-grammarterm> in the 
    <cxx-grammarterm>requirement-list</cxx-grammarterm> evaluates
    to <code>true</code>. The semantics of each kind of requirement are 
    described in the following sections.</p>

    <cxx-section id="expr.req.simple">
      <h1>Simple requirements</h1>

      <p>A <cxx-grammarterm>simple-requirement</cxx-grammarterm> introduces a
      requirement that the substitution of template arguments into the 
      expression will not result in a substitution failure.

      A <cxx-grammarterm>simple-requirement</cxx-grammarterm> has the value 
      <code>true</code> if and only if substitution succeeds. The expression is 
      an unevaluated operand <cxx-ref in="cxx" to="basic.def.odr"></cxx-ref>.
      
      <cxx-example>
      For example, the following is requirement evaluates to 
      <code>true</code> for all arithmetic types 
      <cxx-ref in"cxx" to="basic.fundamental"></cxx-ref>, 
      and <code>false</code> for pointer types 
      <cxx-ref in="cxx" to="basic.compound"></cxx-ref>.
      <cxx-codeblock>
requires (T a, T b) {
  a + b;  // <em style="font-family:times">A simple requirement</em>.
}
</cxx-codeblock>
      </cxx-example>
      </p>

      <p>If the required valid expression would always result in a
      substitution failure, the program is ill-formed.
      <cxx-example>
      <cxx-codeblock>
requires () {
  new T[-1];  // error: the valid expression well never be well-formed.
}
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.req.simple -->


    <cxx-section id="expr.req.compound">
      <h1>Compound requirements</h1>
    
      <p>A <cxx-grammarterm>compound-requirement</cxx-grammarterm> introduces a
      set of constraints pertaining to a single 
      <cxx-grammarterm>expression</cxx-grammarterm>. 
      A <cxx-grammarterm>compound-requirement</cxx-grammarterm> is 
      <code>true</code> if and only if the substitution of template arguments 
      into the expression does not result in a substitution failure and all 
      other associated requirements are <code>true</code>.

      The expression is an unevaluated operand except in the case when the 
      <code>constexpr</code> specifier is present.
      These other requirements are described in the following sections.</p>

      <!-- TODO: This does not document the fact that a trailing type
           specifier adds an implied type requirement. -->
      <p>The presence of a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
      denotes a result type requirement. The result type requirement is 
      <code>true</code> if and only if the substitution of template arguments  
      into the specified type, and <code>decltype((e))</code> is implicitly 
      convertible to <code>T</code>, where <code>e</code> is the substituted 
      expression and <code>T</code> is the substituted type
      <cxx-ref in="cxx" to="conv"></cxx-ref>.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool D() {
    return requires(T p) {
      {*p} -> typename T::r;
    };
  }
      </cxx-codeblock>
      The concept is <code>true</code> when the expression <code>*p</code> and
      the type name <code>T::r</code> do not result in substitution failures 
      when template arguments are substituted, and <code>decltype((*p))</code>
      is implicitly convertible to <code>T::r</code> after substitution.
      </cxx-example>
      </p>

      <p>As with <cxx-grammarterm>simple-requirement</cxx-grammarterm>s, if
      the required valid expression will always result in a substitution
      failure, the program is ill-formed 
      <cxx-ref to="expr.req.simple"></cxx-ref>.</p>

      <p>If the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> is a
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
      then that concept is applied to <code>decltype((e))</code> where 
      <code>e</code> is the substituted expression. The requirement is 
      <code>true</code> if and only if the result of that application is 
      <code>true</code>.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename I&gt;
  concept bool Iterator() { ... }

template&lt;typename T&gt;
  concept bool Range() {
    return requires(T x) {
      {begin(x)} -> Iterator; // Iterator 
    };
  }
      </cxx-codeblock>
      The concept is to <code>true</code> if and only if the expression 
      <code>begin(x)</code> is a valid expression, and 
      <code>Iterator<decltype((begin(x)))>()</code> is <code>true</code>.
      </cxx-example>
      </p>

      <p>If the <cxx-grammarterm>constexpr</cxx-grammarterm> specifier is 
      present in the <cxx-grammarterm>compound-requirement</cxx-grammarterm>, 
      the requirement is true if and only if the substituted expression is a
      constant expression <cxx-ref in="cxx" to="expr.const"></cxx-ref>.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename Trait&gt;
  concept bool Boolean_metaprogram() {
    return requires (Trait t) {
      constexpr {Trait::value} -> bool;
      constexpr {t()} -> bool;
    };
  }
      </cxx-codeblock>
      When substituted into, the concept is <code>true</code> only when the 
      nested <code>value</code>; member and function call operator must be 
      constant expressions. Otherwise, the concept is <code>false</code>.
      </cxx-example>
      </p>

      <p>If the <code>noexcept</code> specifier is present, in the
      <cxx-grammarterm>compound-requirement</cxx-grammarterm> the requirement 
      is <code>true</code> when <code>noexcept(e))</code> is <code>true</code>, 
      where <code>e</code> is the substituted expression.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Nothrow_movable() {
    return requires (T x) {
      {T(std::move(x))} noexcept;
      {x = std::move(x)} noexcept -> T&;
    };
  }
      </cxx-codeblock>
      When template arguments are substituted into the requirement, the move 
      constructor and move assignment operator selected by overload resolution 
      must not propagate exceptions. If either of the instantiated expressions 
      does propagate exceptions, the concept is not satisfied.
      </cxx-example>
      </p>
    </cxx-section>
 
    <cxx-section id="expr.req.type">
      <h1>Type requirements</h1>
      <p>A <cxx-grammarterm>type-requirement</cxx-grammarterm> introduces a
      requirement that an associated <cxx-grammarterm>type-id</cxx-grammarterm> 
      can be formed when template arguments are substituted into the type. The 
      requirement is <code>true</code> if and only if substitution does not 
      result in a substitution failure.
      <cxx-note>
      The <code>typename</code> may be part of a 
      <cxx-grammarterm>typename-specifier</cxx-grammarterm>.
      </cxx-note>
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Input_range() {
    return requires(T range) {
      typename T::value_type;    // Required typename-specifier
      typename Iterator_type&lt;T&gt;; // Required alias template
    };
  }
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If the required type will always results in a substitution failure,
      then the program is ill-formed.
      <cxx-example>
      <cxx-codeblock>
requires () {
  typename int::X;  // error: int does not have class type
  typename T[-1];   // error: array types cannot have negative extent
}
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- expr.req.type -->

    <cxx-section id="expr.req.nested">
      <h1>Nested requirements</h1>
      <p>A <cxx-grammarterm>nested-requirement</cxx-grammarterm> introduces
      additional constraints to be evaluated as part of the
      <cxx-grammarterm>requires-expression</cxx-grammarterm>. The 
      requirement is <code>true</code> if and only if the required expression 
      evaluates to <code>true</code>.
      <cxx-example> 
      Nested requirements are generally used to provide additional constraints on 
      associated types
      within a <cxx-grammarterm>requires-expression</cxx-grammarterm>.
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Input_range() {
    return requires(T range) {
      typename Iterator_type&lt;T&gt;;
      requires Input_iterator&lt;Iterator_type&lt;T&gt;&gt;();
    };
  }
      </cxx-codeblock>
      </cxx-example>
      </p>
    </cxx-section> <!-- expr.re.nested -->
  </cxx-section> <!-- expr.req -->
</cxx-clause> <!-- expr -->



<cxx-clause id="dcl.dcl">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    <p>Extend the <cxx-grammarterm>decl-sepcifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>


    <cxx-section id="dcl.type.simple">
      <h1>Simple type specifiers</h1>
      <p>Extend the <cxx-grammarterm>type-name</cxx-grammarterm> production 
      to include the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
      production and its sub-rules.
      <bnf-grammar>
        <bnf-rule>type-name</bnf-rule>
          <bnf-alt>constrained-type-name</bnf-alt>

        <bnf-rule>constrained-type-name</bnf-rule>
          <bnf-alt>concept-name</bnf-alt>
          <bnf-alt>partial-concept-id</bnf-alt>

        <bnf-rule>concept-name</bnf-rule>
          <bnf-alt>identifier</bnf-alt>

        <bnf-rule>partial-concept-id</bnf-rule>
          <bnf-alt>
            concept-name 
            <bnf-terminal>&lt;</bnf-terminal> 
            template-argument-list
            <bnf-terminal>&gt;</bnf-terminal>
          </bnf-alt>
      </bnf-grammar>
      </p>
    </cxx-section>


    <cxx-section id="dcl.spec.auto">
      <h1><code>auto</code> specifier</h1>

      <p>If the <code>auto</code> 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> appears as one 
      of the <cxx-grammarterm>decl-specifiers</cxx-grammarterm> in the 
      <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a 
      function declarator, then the function is a generic function 
      <cxx-ref to="dcl.fct"></cxx-ref>
      </p>
    </cxx-section>

    <cxx-section id="dcl.spec.constr">
      <h1>Constrained type specifiers</h1>

      <p>When an identifier is a 
      <cxx-grammarterm>concept-name</cxx-grammarterm>, it refers to a 
      function concept or variable concept 
      <cxx-ref to="dcl.concept"></cxx-ref>.
      </p>

      <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
      <cxx-grammarterm>concept-id</cxx-grammarterm> followed by a sequence
      of template arguments.
      A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> does not refer
      to template specialization; an additional template argument must be
      supplied (before the first template argument) before the name
      refers to a template specialization.
      <cxx-example>
      For example:
      <cxx-codeblock>
template&lt;typename T, typename U&gt;
  concept bool C = ...;

C&lt;int&gt;       // A partial-concept-id
C&lt;char, int&gt; // A template-id
      </cxx-codeblock>
      The first name is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm>
      and can be used as part of constrained type name as part the type 
      specifier of a parameter declaration or a template parameter. The 
      second name is a <cxx-grammarterm>template-id</cxx-grammarterm> and
      determines whether the concept is satisfied for the given arguments.
      </cxx-example>
      </p>

      <p>A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> shall not
      have an empty list of template arguments.
      <cxx-example>
      <cxx-codeblock>
C<>; // Error: partial-concept-id with empty arguments
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>A <cxx-grammarterm>constrained-type-name</cxx-grammarterm> introduces
      constraints for a <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      or placeholder type depending on the context in which it appears. A
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm> can be used 
      in the <cxx-grammarterm>type-specifier</cxx-grammarterm> of template 
      parameters, a <cxx-grammarterm>result-type-requirement</cxx-grammarterm> 
      in a <cxx-grammarterm>compound-requirement</cxx-grammarterm>, or wherever 
      the <code>auto</code> specifier is used, except
      <ul>
        <li>as part of the type of a variable declaration,</li>
        
        <li>as part of a function's result type or 
        <cxx-grammarterm>trailing-result-type</cxx-grammarterm>, </li>
        
        <li>in the place of <code>auto</code> within 
        <code>decltype(auto)</code>, or</li>
        
        <li>as part of a 
        <cxx-grammarterm>conversion-function-id</cxx-grammarterm>.</li>
      </ul>
      </p>

      <p>A <cxx-grammarterm>constrained-type-name</cxx-grammarterm> that 
      refers to a non-type concept shall not be used as part of a
      <cxx-grammarterm>type-specifier</cxx-grammarterm> that introduces
      a placeholder type.
      <cxx-note>
      Non-type concepts can be used as type specifiers of non-type template 
      parameters and template template parameters.
      </cxx-note>
      <cxx-example>
      <cxx-codeblock>
template&lt;int N&gt;
  concept bool Prime() { ... }

void f(Prime n)   // Error

template&lt;Prime P&gt; // Ok
  void g();
      </cxx-codeblock>
      </cxx-example>
      </p>

      <cxx-section id="dcl.constr.form">
        <h1>Constraint formation</h1>
        
        <p>When a <cxx-grammarterm>template-parameter</cxx-grammarterm> 
        or parameter-declaration is declared using a 
        <cxx-grammarterm>constrained-type-name</cxx-grammarterm> in its 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, a new constraint 
        expression is synthesized and associated with the template declaration. 
        The rules for forming that constraint depend on whether the type 
        specifier is a <cxx-grammarterm>concept-name</cxx-grammarterm> or 
        <cxx-grammarterm>partial-concept-id</cxx-grammarterm>. 
        Both cases require the synthesis of a 
        <cxx-grammarterm>template-id</cxx-grammarterm> referring that refers
        to a specialization of the named concept. The template argument list 
        is formed using the following rules. </p>

        <p>Letting <code>X</code> be the declared
        <cxx-grammarterm>template-parameter</cxx-grammarterm> or the invented type of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in a generic 
        function or generic lambda: </p>
        <ul>
          <li> If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is a <cxx-grammarterm>concept-name</cxx-grammarterm>, the synthesized 
          template argument list contains only <code>X</code>.</li>

          <li> If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose 
          template argument list contains the arguments <code>Y1</code>, 
          <code>Y2</code>, ..., <code>Yn</code>, then the synthesized template 
          argument list contains the sequence <code>X</code>, <code>Y1</code>, 
          <code>Y2</code>, ..., <code>Yn</code>.</li>
        </ul>

        <p>If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
        refers to a function concept, then the synthesized constraint is a 
        call expression with no function arguments. </p>

        <p>
        <cxx-example>
        The following unary and binary concepts are defined as variables and
        functions.
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool V1 = ...;

template&lt;typename T, typename U&gt;
  concept bool V2 = ...;

template&lt;typename T&gt;
  concept bool F1() { return ...; }

template&lt;typename T, typename T2&gt;
  concept bool F2() { return ...; }
        </cxx-codeblock>
        Suppose <code>X</code> is a template parameter being declared, either 
        explicitly or as an invented template parameter of a 
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        in a generic function or generic lambda. The synthesized constraints 
        corresponding to each declaration are:
        <cxx-codeblock>
V1 X    // becomes V1&lt;T&gt;
V2&lt;Y&gt; X // becomes V2&lt;X, Y&gt;
F1 X    // becomes F1&lt;X&gt;()
F2&lt;Y&gt; X // becomes F2&lt;X, Y&gt;()
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- decl.constr.form -->

      <cxx-section id="dcl.constr.form">
        <h1>Constraint formation</h1>
        <p>The meaning of a constrained type specifier depends on the 
        context in which it is used. The different meanings of constrained 
        type specifiers are enumerated in this clause. </p>
        <ul>
          <li> If a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as the <cxx-grammarterm>type-specifier</cxx-grammarterm> 
          of a <cxx-grammarterm>template-parameter</cxx-grammarterm>, the
          constraint is formed by applying the declared parameter to the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.</li>

          <li> When a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as part of the 
          <cxx-grammarterm>type-specifier</cxx-grammarterm> of a 
          <cxx-grammarterm>parameter-declaration</cxx-grammarterm>, the
          parameter's type is formed by replacing the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm> with
          <code>auto</code>, creating a generic function or generic lambda. 
          The introduced constraint is formed by applying the declared 
          parameter to the invented template parameter to the 
          <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.</li>

          <li> When a <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          is used as part of a <cxx-grammarterm>type-specifier</cxx-grammarterm> 
          in a <cxx-grammarterm>result-type-requirement</cxx-grammarterm>, the
          constraint is introduced as a 
          <cxx-grammarterm>nested-requirement</cxx-grammarterm> that 
          applies the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> 
          to the result type of the required expression.</li>
        </ul>
      </cxx-section> <!-- dcl.constr.meaning -->

    </cxx-section> <!-- dcl.spec.constr -->

    <cxx-section id="dcl.concept">
      <h1><code>concept</code> specifier</h1>

      <p>The <code>concept</code> specifier shall be applied to only the 
      definition of a function template or variable template.
      A function template definition having the <code>concept</code>
      specifier is called a function concept. A variable template
      definition having the <code>concept</code> specifier is called a 
      variable concept. </p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      <cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>.
      </p>

      <p>A function concept has the following restrictions: </p>
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The result type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The declaration shall be a definition. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose expression shall be a
        <cxx-grammarterm>constraint-expr</cxx-grammarterm>. </li>
      </ul>
      <cxx-example>
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool C1() { return true; } // OK

      template&lt;typename T&gt;
        concept int c2() { return 0; }  // error: must return bool

      template&lt;typename T&gt;
        concept bool C3(T) { return true; } // error: must have no parameters

      concept bool p = 0; // error: not a template
      </cxx-codeblock>
      </cxx-example>

      <p>A variable template has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expr</cxx-grammarterm>. </li>
      </ul>
      <cxx-example>
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool Integral = is_integral&lt;T&gt;::value; // OK

      template&lt;typename T&gt;
        concept bool C = 3 + 4; // Error: initializer is not a constraint

      template&lt;Integral T&gt;
        concept bool D = is_unsigned&lt;T&gt;::value; // Error: constrained concept definition
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If a program declares a non-concept overload of a concept 
      definition with the same template parameters and no function 
      parameters, the program is ill-formed.
      <cxx-example>
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool Totally_ordered() { ... }

      template&lt;Graph G&gt;
        constexpr bool Totally_ordered() // error: subverts concept definition
        { return true; }
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>A program that declares an explicit or partial specialization of a concept
      definition is ill-formed.
      <cxx-example>
      <cxx-codeblock>
      template&lt;typename T&gt;
        concept bool C = is_iterator&lt;T&gt;::value;

      template&lt;typename T&gt;
        concept bool C&lt;T*&gt; = true; // Error: partial specialization of a concept
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->

<cxx-clause id="dcl.decl">
  <h1>Declarators</h1>

  <p>Modify <cxx-ref in="cxx" to="dcl.decl"></cxx-ref>p1 as follows:</p>

  <p>A declarator declares a single variable, function, or type, within a 
  declaration. The <cxx-grammarterm>init-declarator-list</cxx-grammarterm>
  appearing in a declaration is a comma-separated sequence of declarators, 
  each of which can 
  <del>have an initializer</del>
  <ins>have constraints or an initializer</ins>.
  <bnf-grammar>
    <bnf-rule>init-declarator</bnf-rule>
      <bnf-alt>
        declarator
        requires-clause<bnf-opt></bnf-opt>
        initializer<bnf-opt></bnf-opt>
      </bnf-alt>
  </bnf-grammar>
  </p>

  <p>Insert the following paragraph after 
  <cxx-ref in="cxx" to="dcl.decl"></cxx-ref>p1</p>

  <p>A <cxx-grammarterm>declarator</cxx-grammarterm> followed by a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm> declares a 
  <defn>constrained declaration</defn>. 

  The <cxx-grammarterm>requires-clause</cxx-grammarterm> associates
  a constraint with the declaration <cxx-ref to="temp.constr"></cxx-ref>. 

  A declarator that declares a constrained variable or type is 
  ill-formed.</p>

  <cxx-section id="dcl.meaning">
    <h1>Meaning of declarators</h1>

    <cxx-section id="dcl.fct">
      <h1>Functions</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>p14.</p>

      <p>A <defn>generic function</defn> is a function template whose
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> has a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> whose 
      <cxx-grammarterm>type-specifier</cxx-grammarterm> is either 
      <code>auto</code> or a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.
      <cxx-example>
      <cxx-codeblock>
auto f(auto x); // Ok
void sort(Sortable& c); // Ok (assuming Sortable names a concept)
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>The declaration of a generic function has a 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm> that 
      consists of one invented type 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> for each
      occurrence of <code>auto</code> or each unique occurence of a 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
      in the function's
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>, 
      in order of appearance. 
      
      The invented type of 
      <cxx-grammarterm>template-parameter</cxx-grammarterm> is a parameter 
      pack if the corresponding 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> declares 
      a function parameter pack <cxx-ref in="cxx" to="dcl.fct"></cxx-ref>.
      
      <!-- TODO: I believe this duplicates a requirement elsewhere -->
      The associated constraints of the generic function are 
      the conjunction of constraints introduced by the use of 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm>s in the 
      <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>.</p>


      <p>All placeholder types introduced using the same 
      <cxx-grammarterm>constrained-type-name</cxx-grammarterm> have the 
      same invented template parameter.</p>

      <!-- TODO: Improve these examples -->
      <p>
      <cxx-example>
      The generic function declared below
      <cxx-codeblock>
auto f(auto x, const Regular&amp; y);
      </cxx-codeblock>
      Is equivalent to the following declaration
      <cxx-codeblock>
template&lt;typename T1, typename T2>
  requires Regular&lt;T2>()
    auto f(T1 x, const T2&amp; y);
      </cxx-codeblock>
      The generic function declared below
      <cxx-codeblock>
auto gcd(Integral a, Integral b);
      </cxx-codeblock>
      Is equivalent to the following declaration:
      <cxx-codeblock>
template&lt;Integral T&gt;
  auto gcd(T a, T b);
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>If an entity is declared by an abbreviated template declaration, 
      then all its declarations must have the same form.</p>
    
    </cxx-section> <!-- dcl.fct -->
  </cxx-section> <!-- dcl.meaning -->
</cxx-clause> <!-- dcl.decl -->

<!-- FIXME: Consider moving the requires clause into the constraints
     section, so we can refer to it from from dcl.decl and
     from here. That unifies the application of constraints
     for templats and generics. -->
<cxx-clause id="temp">
  <h1>Templates</h1>

  <p>Modify the <cxx-grammarterm>template-declaration</cxx-grammarterm>
  grammar in <cxx-ref in="cxx=" to="temp"></cxx-ref>.</p>

  <p>
  <bnf-grammar>
    <bnf-rule>template-declaration</bnf-rule>
      <bnf-alt>
        <bnf-terminal>template</bnf-terminal>
        <bnf-terminal>&lt;</bnf-terminal>
        template-parameter-list
        <bnf-terminal>&gt;</bnf-terminal>
        <ins>requires-clause<bnf-opt></bnf-opt></ins>
        declaration
      </bnf-alt>
      <bnf-alt>
      <ins>concept-introduction declaration</ins>
      </bnf-alt>

    <ins>
    <bnf-rule>requires-clause</bnf-rule>
      <bnf-alt>constraint-expression</bnf-alt>
    </ins>
  </bnf-grammar>

  <p>Add the following paragraphs after 
  <cxx-ref in="cxx" to="temp"></cxx-ref>p6.</p>

  <p>A <defn>constrained template declaration</defn> is a
  <cxx-grammarterm>template-declaration</cxx-grammarterm> with 
  associated constraints. The <defn>associated constraint</defn>s of a 
  constrained template declaration are the conjunction of the associated 
  constraints of all </p>
  <ul>
    <li><cxx-grammarterm>constrained-parameter</cxx-grammarterm>s
    in template's <cxx-grammarterm>template-parameter-list</cxx-grammarterm> 
    <cxx-ref to="temp.param"></cxx-ref>.</li>
    <li> and all <cxx-grammarterm>constraint-expression</cxx-grammarterm>s 
    introduced by <cxx-grammarterm>requires-clause</cxx-grammarterm>
    in the <cxx-grammarterm>template-declaration</cxx-grammarterm>.</li>
  </ul>
  
  <cxx-note>
  A function or member function may have a 
  <cxx-grammarterm>requires-clause</cxx-grammarterm> in its
  declarator. These constraints are also part of the associated 
  constraints of the template declaration.
  </cxx-note>

  <!-- FIXME: This could probably be written more explicitly. -->
  <p>The associated constraints of a <cxx-grammarterm>concept-introduction</cxx-grammarterm>
  are those required by the referenced concept definition. 
  <cxx-example>
  <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Integral() { return is_integral&lt;T&gt;::value; }

template&lt;Integral T&gt;
  requires Unsigned&lt;T&gt;()
    T binary_gcd(T a, T b);
</cxx-codeblock>
  The associated constraints of <code>binary_gcd</code> are denoted by the
  conjunction <code>Integral&lt;T&gt;() &amp;&amp; Unsigned&lt;T&gt;()</code>.
  </cxx-example>
  </p>

  <p>A constrained template declaration's associated constraints must 
  be satisfied <cxx-ref to="temp.constr"></cxx-ref> to allow instantiation 
  of the constrained template. 

  The associated constraints are satisfied by substituting template 
  arguments into the constraints and evaluating substituted expression. 

  Constraints are satisfied when the result of that evaluation is 
  <code>true</code>.

  Class template, alias template, and variable template constraints 
  are checked during name lookup <cxx-ref id="temp.names"></cxx-ref>; 
  function template constraints and class template partial specialization 
  constraints are checked during template argument deduction
  <cxx-ref to="temp.deduct"></cxx-ref>.</p>

  <p>Any usage of a constrained template in a template declaration 
  is ill-formed unless the associated constraints of the constrained 
  template are subsumed by the associated constraints of template 
  parameter. No diagnostic is required.
  </p>

  <cxx-section id="temp.param">
    <h1>Template parameters</h1>

    <p>Modify the <cxx-grammarterm>template-parameter</cxx-grammarterm>
    grammar in <cxx-ref in="cxx" to="temp.param"></cxx-ref> to include
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>, and add
    the following productions.

    <bnf-grammar>
      <bnf-rule>template-parameter</bnf-rule>
        <ins><bnf-alt>constrained-parameter</bnf-alt></ins>

      <ins>
      <bnf-rule>constrained-parameter</bnf-rule>
        <bnf-alt>
        constrained-type-name
        <bnf-terminal>...</bnf-terminal><bnf-opt></bnf-opt>
        identifier
        </bnf-alt>

        <bnf-alt>
        constrained-type-name
        <bnf-terminal>...</bnf-terminal><bnf-opt></bnf-opt>
        identifier
        <bnf-terminal>=</bnf-terminal>
        constrained-default-argument
        </bnf-alt>
      </ins>
    </bnf-grammar>

    <p>Add the following paragraphs after
    <cxx-ref in="cxx" to="temp.param"></cxx-ref>p15.

    <p>A <cxx-grammarterm>constrained-parameter</cxx-grammarterm> defines 
    its identifier to be a template parameter. The declared template 
    parameter whose kind matches that of the first template parameter, 
    called the <defn>prototype parameter</defn>, of the concept referred 
    to by the <cxx-grammarterm>constrained-type-name</cxx-grammarterm>.
    <cxx-note>
    The rules for declaring the parameter are:
    <ul>
      <li>If the prototype parameter is a 
      <cxx-grammarterm>type-parameter</cxx-grammarterm> that is a
      <code>class</code> or <code>typename</code>, then then introduced 
      template parameter is a <code>class</code> or <code>typename</code> 
      parameter.</li>

      <li>If the prototype parameter is a 
      <cxx-grammarterm>template-declaration</cxx-grammarterm>, then
      the introduced parameter is a 
      <cxx-grammarterm>template-declaration</cxx-grammarterm> having the 
      same number of kinds of template parameters.</li>

      <li>If the prototype parameter is a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm>, then
      the introduced parameter is a 
      <cxx-grammarterm>parameter-declaration</cxx-grammarterm> with
      the same <cxx-grammarterm>type-specifier</cxx-grammarterm>.</li>
    </ul>
    </cxx-note>
    <cxx-example>
    Given the following concept definitions:
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Type = true;
template&lt;int N&gt;
  concept bool Int = true;
template&lt;template&lt;typename&gt; class X&gt;
  concept bool Template = true;
    </cxx-codeblock>
    The the following classes are declared with the stated
    template paramters:
    <cxx-codeblock>
template&lt;Type T&gt; // T is a type template parameter
  struct X1;
template&lt;Int N&gt; // N is an integer template parameter
  struct X2;
template&lt;Template T&gt; // T is a template template parameter
  struct X3;
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    If prototype parameter is a parameter pack, then the constrained 
    parameter shall also be declared as a parameter pack.
    <cxx-example>
    <cxx-codeblock>
    template&lt;typename... Ts&gt;
      concept bool Same_types() { ... }

    template&lt;Same_types Args&gt; // error: Must be Same_types...
      void f(Args... args);
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The associated constraints of the constrained template 
    parameter are synthesized according to the rules defined in
    <cxx-ref to="dec.constr.form"></cxx-ref>.</p>

    <p>The kind of the
    <cxx-grammarterm>constrained-default-argument</cxx-grammarterm> 
    shall match that of the declared 
    <cxx-grammarterm>constrained-parameter</cxx-grammarterm>.</p>
  </cxx-section> <!-- temp.param -->

  <cxx-section id="temp.names">
    <h1>Template names</h1>

    <p>Modify <cxx-ref in="cxx" to="temp.names"></cxx-ref>p5.

    <p>A <cxx-grammarterm>simple-template-id</cxx-grammarterm> that 
    names a class template specialization is a 
    <cxx-grammarterm>class-name</cxx-grammarterm>. 

    <ins>The template-arguments shall satisfy the associated constraints 
    of the primary template, if any.</ins>
    <cxx-example>
    <cxx-codeblock>
template&lt;Object T, int N&gt; // T must be an object type
  class array;

array&lt;int&amp;, 3&gt;* p; // error: int&amp; is not an object type
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>
    This guarantees that a partial specialization cannot be less 
    specialized than a primary template. This requirement is enforced
    during name lookup, not when the partial specialization is declared.
    </cxx-note>
    </p>
  </cxx-section> <!-- temp.names -->

  <cxx-section id="temp.arg">
    <h1>Template arguments</h1>

    <cxx-section id="temp.arg.template">
      <h1>Template template arguments</h1>

      <p>Modify <cxx-ref in="cxx" to="temp.arg.template"></cxx-ref>.

      <p>A <cxx-grammarterm>template-argument</cxx-grammarterm> matches 
      a template <cxx-grammarterm>template-parameter</cxx-grammarterm> 
      (call it <code>P</code>) when each of the template parameters in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      the <cxx-grammarterm>template-argument</cxx-grammarterm>'s 
      corresponding class template or alias template (call it 
      <code>A</code>) matches the corresponding template parameter in 
      the <cxx-grammarterm>template-parameter-list</cxx-grammarterm> of 
      <code>P</code><ins>, and the associated constraints of <code>P</code> 
      shall subsume the associated constraints of <code>A</code>
      <cxx-ref to="temp.constr"?></cxx-ref></ins>.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Object = is_object&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Copyable = is_copyable&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Regular = Copyable&lt;T&gt; &amp;&amp; ...;

template&lt;template&lt;Copyable&gt; class C&gt;
  class stack { ... };

template&lt;Regular T&gt; class list1;
template&lt;Object T&gt; class list2;

stack&lt;list1&gt; s1; // error: Regular is more strict than Copyable
stack&lt;list2&gt; s2; // Ok: Object is not more strict than Copyable
      </cxx-codeblock>
      </cxx-example>
      </p>

    </cxx-section> <!-- temp.arg.template -->
  </cxx-section> <!-- tmep.arg -->

  <cxx-section id="temp.decls">
    <h1>Template declarations</h1>

    <cxx-section id="temp.class">
      <h1>Class templates</h1>

      <cxx-section id="temp.mem.func">
        <h1>Member functions of class templates</h1>

        <p>Add the following paragraphs after
        <cxx-ref in="cxx" to="temp.mem.func"></cxx-ref>.

        <p>A member function of a class template can be constrained by 
        writing a <cxx-grammarterm>requires-clause</cxx-grammarterm> 
        after the member declarator.
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt;
  class S {
    void f() requires Integral&lt;T&gt;();
  };
        </cxx-codeblock>
        </cxx-example>
        The <cxx-grammarterm>requires-clause</cxx-grammarterm> introduces 
        the following <cxx-grammarterm>expression</cxx-grammarterm>
        as an associated constraint of the member function. A member 
        function of a class template with an associated constraint is a 
        <defn>constrained member function</defn>.
        </p>

        <p>
        Constraints on member functions are instantiated as needed 
        during overload resolution 
        <cxx-ref in="cxx" to="temp.inst"></cxx-ref>.
        <cxx-note>
        Constraints on member functions do not affect the declared 
        interface of a class. That is, a constrained copy constructor 
        is still a copy constructor, even if it will not be viable for 
        all possible specializations of the class.
        </cxx-note>
        </p>
      
      </cxx-section> <!-- temp.mem.func -->
    </cxx-section> <!-- temp.class -->

    <cxx-section id="temp.friend">
      <h1>Friends</h1>

      <p>Add the following paragraphs after
      <cxx-ref in="cxx" to="temp.friend"></cxx-ref>p9.

      <p> 
      A <defn>constrained friend</defn> is a friend of a class 
      template with associated constraints.

      A constrained friend can be a constrained class template, 
      constrained function template, or an ordinary (non-template) 
      function.
      
      <!-- TODO: What is shorthand? -->
      Constraints on template friends are written using shorthand, 
      introductions, or a requires clause following the 
      <cxx-grammarterm>template-parameter-list</cxx-grammarterm>.

      Constraints on non-template friend functions are written 
      after the result type.
      <cxx-example>
      All of the following are valid constrained friend declarations:
      <cxx-codeblock>
template&lt;typename T&gt;
  struct X {
    template&lt;Integral U&gt;
      friend void f(X x, U u) { }

    template&lt;Object W&gt;
      friend struct Z { };

    friend bool operator==(X a, X b) requires Equality_comparable&lt;T&gt;()
    {
      return true;
    }
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A non-template friend function shall not be constrained unless 
      the function's parameter or result type depends on a template 
      parameter.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f(int n) requires C&lt;T&gt;(); // Error: cannot be constrained
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      A constrained non-template friend function shall not declare 
      a specialization.
      <cxx-example>
      <cxx-codeblock>
template&lt;typename T&gt;
  struct S {
    friend void f&lt;&gt;(T x) requires C&lt;T&gt;(); // Error: declares a specialization

    friend void g(T x) requires C&lt;T&gt;() { } // OK: does not declare a specialization
  };
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      As with constrained member functions, constraints on non-template friend
      functions are not instantiated during class template instantiation.
      </p>

    </cxx-section> <!-- temp.firend -->

    <cxx-section id="temp.class.spec">
      <h1>Class template partial specialization</h1>

      <cxx-section id="temp.class.spec.match">
        <h1>Matching of class template partial specializations</h1>

        <p>Modify 
        <cxx-ref to="cxx" in="temp.class.spec.match"></cxx-ref>p2.</p>

        <p> A partial specialization matches a given actual template 
        argument list if the template arguments of the partial 
        specialization can be deduced from the actual template argument 
        list <cxx-ref in="cxx" to="temp.deduct"></cxx-ref>
        <ins>, and the deduced template arguments satisfy the constraints 
        of the partial specialization, if any 
        <cxx-ref to="temp.constr"></cxx-ref></ins>.</p>

      </cxx-section> <!-- temp.class.spec.match -->

      <cxx-section id="temp.class.order">
        <h1>Partial ordering of class template specializations</h1>

        <p>Modify 
        <cxx-ref in="cxx" to="temp.class.order"></cxx-ref>p1.</p>

        <p>
        For two class template partial specializations, the first is 
        at least as specialized as the second if, given the following 
        rewrite to two function templates, the first function template 
        is at least as specialized as the second according to the ordering 
        rules for function templates 
        <cxx-ref in="cxx" to="temp.func.order"></cxx-ref>:
        </p>
        <ul>
          <li> the first function template has the same template 
          parameters <ins>and constraints</ins> as the first partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the first partial specialization, and</li>

          <li> the second function template has the same template 
          parameters <ins>and constraints</ins> as the second partial 
          specialization and has a single function parameter whose
          type is a class template specialization with the template 
          arguments of the second partial specialization.</li>
        </ul>
        <cxx-example>
        <cxx-codeblock>
template&lt;typename T&gt;
  concept bool Integer = is_integral&lt;T&gt;::value;
template&lt;typename T&gt;
  concept bool Unsigned_integer = Integer&lt;T&gt; &amp;&amp; is_unsigned&lt;T&gt;::value;

template&lt;typename T&gt; class S { };
template&lt;Integer T&gt; class S&lt;T&gt; { };          // #1
template&lt;Unsigned_integer T&gt; class S&lt;T&gt; { }; // #2

template&lt;Integer T&gt; void f(S&lt;T&gt;);          // A
template&lt;Unsigned_integer T&gt; void f(S&lt;T&gt;); // B
        </cxx-codeblock>
        The partial specialization #2 will be more specialized than 
        #1 for template arguments that satisfy both constraints because 
        <code>B</code> will be more specialized than <code>A</code>.
        </cxx-example>

      </cxx-section> <!-- temp.class.order -->
    </cxx-section> <!-- temp.class.spec -->

    <cxx-section id="temp.fct">
      <h1>Function templates</h1>

      <cxx-section id="temp.deduct">
        <h1>Template argument deduction</h1>

        <p>Modify
        <cxx-ref in="cxx" to="temp.deduct"></cxx-ref>p2.

        <p>When an explicit template argument list is specified, the 
        template arguments must be compatible with the template parameter 
        list and must result in a valid function type as described below; 
        otherwise type deduction fails. Specifically, the following steps 
        are performed when evaluating an explicitly specified template 
        argument list with respect to a given function template:
        </p>

        <ul>
          <li>The specified template arguments must match the template 
          parameters in kind (i.e., type, non-type, template). There must 
          not be more arguments than there are parameters unless at least 
          one parameter is a template parameter pack, and there shall be 
          an argument for each non-pack parameter. Otherwise, type
          deduction fails.</li>

          <li>
          Non-type arguments must match the types of the corresponding 
          non-type template parameters, or must be convertible to the 
          types of the corresponding non-type parameters as specified in 
          <cxx-ref in="cxx" to="temp.arg.nontype"></cxx-ref> otherwise 
          type deduction fails.</li>

          <li><ins>If the function template is constrained, the specified 
          template arguments are substituted into the associated 
          constraints and evaluated. If the result of the evaluation is 
          <code>false</code>, type deduction fails.</ins></li>

          <li>The specified template argument values are substituted for 
          the corresponding template parameters as specified below.
        </ul>

      </cxx-section> <!-- temp.deduct -->

      <cxx-section id="temp.over.link">
        <h1>Function template overloading</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link"></cxx-ref>.</p>

        <p>
        A function template can be overloaded either by (non-template) 
        functions of its name or by (other) function templates of the 
        same name. When a call to that name is written (explicitly, or 
        implicitly using the operator notation), template argument deduction 
        <cxx-ref to="temp.deduct"></cxx-ref><ins>,</ins> <del>and</del> 
        checking of any explicit template arguments 
        <cxx-ref in="cxx" to"temp.arg"></cxx-ref> <ins>, and checking of 
        associated constraints <cxx-ref to="temp.constr"></cxx-ref></ins>
        are performed for each function template to find the template 
        argument values (if any) that can be used with that function 
        template to instantiate a function template specialization that 
        can be invoked with the call arguments. 

        For each function template, if the argument deduction and 
        checking succeeds, the template-arguments (deduced and/or 
        explicit) are used to synthesize the declaration of a single 
        function template specialization which is added to the 
        candidate functions set to be used in overload resolution. If, 
        for a given function template, argument deduction fails, no 
        such function is added to the set of candidate functions for 
        that template.

        The complete set of candidate functions includes all the 
        synthesized declarations and all of the non-template overloaded 
        functions of the same name. The synthesized declarations are 
        treated like any other functions in the remainder of overload 
        resolution, except as explicitly noted in 
        <cxx-ref in="cxx" to"over.match"></cxx-ref>.
        </p>

        <p>Modify <cxx-ref in="cxx" to="temp.over.link">p6.</cxx-ref>

        <p>
        Two function templates are <defn>equivalent</defn> if they are 
        declared in the same scope, have the same name, have identical 
        template parameter lists, <del>and</del> have return types<ins>,</ins> 
        <del>and</del> parameter lists, <ins>and constraints 
        <cxx-ref to="temp.constr"></cxx-ref></ins> that are equivalent 
        using the rules described above to compare expressions involving 
        template parameters.
        </p>

      </cxx-section> <!-- temp.over.link -->

      <cxx-section id="temp.func.order">
        <h1>Partial ordering of function templates</h1>

        <p>Modify <cxx-ref in="cxx" to="temp.func.order"></cxx-ref>p2.</p>

        <p>
        Partial ordering selects which of two function templates is 
        more specialized than the other by transforming each template 
        in turn (see next paragraph) and performing template argument 
        deduction using the function type. The deduction process 
        determines whether one of the templates is more specialized 
        than the other.

        If so, the more specialized template is the one chosen by the 
        partial ordering process. <ins>If the two templates have 
        identical template parameter lists and equivalent return types 
        and parameter lists, then partial ordering selects the template 
        whose associated constraints subsume but are not equivalent to 
        the associated constraints of the other 
        <cxx-ref to="temp.constr"></cxx-ref>. 

        A constrained template is always selected over an unconstrained 
        template.</ins>
        </p>

      </cxx-section> <!-- temp.func.order -->
    </cxx-section> <!-- temp.fct -->
  </cxx-section> <!-- temp.decls -->

  <cxx-section id="temp.constr">
    <h1>Template constraints</h1>

    <p>Add this as a new section under 
    <cxx-ref in="cxx" to="temp">"</cxx-ref>.</p>

    <p>
    Certain contexts require expressions that satisfy additional 
    requirements as detailed in this sub-clause. Expressions that 
    satisfy these requirements are called 
    <defn>constraint expression</defn>s or simply 
    <defn>constraint</defn>s.
    <bnf-grammar>
      <bnf-rule>constraint-expression</bnf-rule>
        <bnf-alt>logical-or-expression</bnf-alt>
    </bnf-grammar>
    </p>

    <p>
    A <cxx-grammarterm>logical-or-expression</cxx-grammarterm> is 
    a <cxx-grammarterm>constraint-expression</cxx-grammarterm> if 
    it is a <cxx-grammarterm>constant-expression</cxx-grammarterm> 
    of type <code>bool</code> whose operands to logical operators in 
    its sub-expressions, when substituted have type <code>bool</code>.
    <cxx-note>
    A <cxx-grammarterm>constraint-expression</cxx-grammarterm> 
    defines a subset of constant expressions over which certain 
    logical implications can be proven during translation.

    <!-- TODO: This will move when I rewrite the bool rule. -->
    The required contextual conversion to <code>bool</code> in a
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> prevents 
    user-defined overloads of logical operators from being selected 
    during overload resolution.
    </cxx-note>
    </p>

    <p>
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt;
  requires is_integral&lt;T&gt;::value &amp;&amp; is_signed&lt;T&gt;::value
void f(T x);
    </cxx-codeblock>

    <cxx-codeblock>
constexpr int Fn() { return 1; }

template&lt;typename T&gt;
  requires Fn() // Error: Fn() is not a valid constraint
void g(T x);
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>
    A constraint is <defn>satisfied</defn> if it evaluates to 
    <code>true</code>. Otherwise, the constraint is 
    <defn>unsatisfied</defn>.
    </p>


    <p>
    A subexpression of a 
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> that 
    calls a function concept or refers to a variable concept 
    <cxx-ref to="dcl.concept"></cxx-ref> is a <defn>concept check</defn>. 

    When processing a constraint containing a concept check, that 
    concept check is replaced by the concept's definition, forming 
    a new expression.

    For checks against function concepts, the replacement is done
    by substituting the explicit template arguments into the return 
    expression. For checks against variable concepts, the definition 
    is formed by substituting the template arguments into the 
    variable's initializer.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T&gt;
  concept bool C() { return sizeof(T) &gt;= 4; }

template&lt;typename T&gt;
  concept bool D = C&lt;T&gt;();

template&lt;typename X&gt;
  requires C&lt;X&gt;() // Processed as sizeof(X) &gt;= 4
void f();

template&lt;typename Q&gt;
  requires D&lt;Q&gt;   // Processed as sizeof(Q) >= 4
void g();
    </cxx-codeblock>
    </cxx-example>
    </p>

    <!-- TODO: This does not explain how requires clauses are actually
         defined. A requires clause is a conjunction of atomic constraints
         comprised of each valid expression, constexpr, noexcept, type,
         and nested requirements. -->
    <p>
    Certain subexpressions of a 
    <cxx-grammarterm>constraint-expression</cxx-grammarterm> are 
    considered <defn>atomic constraint</defn>s. A constraint is atomic 
    if it is not a <cxx-grammarterm>logical-and-expression</cxx-grammarterm> 
    or a <cxx-grammarterm>logical-or-expression</cxx-grammarterm>.
    <cxx-example>
    The expression 
    <code>x == y &amp;&amp; is_integral&lt;T&gt;::value</code> 
    has two atoms:
    <code>x == y</code> and <code>is_integral&lt;T&gt;::value</code>.
    </cxx-example>


    <!-- Give examples of refinement, disjointness, and overlap -->
    <p>
    Given two constraints <code>P</code> and <code>Q</code> depending 
    on template parameters <code>T1</code>, ..., <code>Tn</code>, 
    <code>P</code> is said to <defn>subsume</defn> <code>Q</code> if
    for any template arguments substituted for 
    <code>T1</code>, ..., <code>Tn</code>, the constraint <code>Q</code> 
    is true, then <code>P</code> is also true.
    <cxx-example>
    Let <code>P</code> be the constraint 
    <code>is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) == 4</code>, 
    and let <code>Q</code> be the constraint <code>sizeof(T) == 4</code>.
    Then <code>P</code> subsumes <code>Q</code>, but <code>Q</code> 
    does not subsume <code>P</code>.
    </cxx-example>
    </p>

    <p>
    Two <cxx-grammarterm>constraint-expressions</cxx-grammarterm> 
    <code>P</code> and <code>Q</code> are equivalent if and only if 
    <code>P</code> subsumes <code>Q</code> and 
    <code>Q</code> subsumes <code>P</code>.
    </p>

  </cxx-section> <!-- temp.constr -->


  <cxx-section id="concept.intro">
    <h1>Concept introductions</h1>

    <p>Add this as a new section under 
    <cxx-ref in="cxx" to="temp">"</cxx-ref>.</p>

    <p> A <cxx-grammarterm>concept-introduction</cxx-grammarterm> allows 
    the declaration of template and its associated constraints in a 
    concise way.
    <bnf-grammar>
      <bnf-rule>concept-introduction</bnf-rule>
        <bnf-alt>
          concept-name
          <bnf-terminal>{</bnf-terminal>
          introduction-list
          <bnf-terminal>}</bnf-terminal>
          declaration
        </bnf-alt>
      <bnf-rule>introduction-list</bnf-rule>
        <bnf-alt>identifier</bnf-alt>
        <bnf-alt>
          introduction-list <bnf-terminal>,</bnf-terminal> identifier
        </bnf-alt>
    </bnf-grammar>
    </p>

    <!-- TODO: This does not explain that an appropriate concept can
         if they are overloaded. -->
    <p>The <cxx-grammarterm>concept-introduction</cxx-grammarterm> names 
    a concept and a list of identifiers to be used as template parameters, 
    called the <defn>introduced parameters</defn> in the declaration. The 
    number of <cxx-grammarterm>identifier</cxx-grammarterm>s in the 
    <cxx-grammarterm>introduction-list</cxx-grammarterm> shall match the 
    number of template parameters in the named concept.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename I1, typename I2, typename O&gt;
  concept bool Mergeable() { ... };

Mergeable{First, Second, Out} // OK
  Out merge(First, First, Second, Second, Out); 

Mergeable{X, Y} // Error: not enough parameters
  void f(X, Y);
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>The introduced parameters are the template parameters of the declaration,
    and they match the template parameters in the declaration of the named
    concept. The associated constraints
    of the declaration are formed by applying the introduced parameters as
    arguments to the named concept \ref{dcl.constr.form}.
    <cxx-example>
    The following declaration
    <cxx-codeblock>
Mergeable{X, Y, Z}
  Z merge(X, X, Y, Y, Z);
    </cxx-codeblock>
    is equivalent to the declaration below.
    <cxx-codeblock>
template&lt;typename X, typename Y, typename Z&gt;
  requires Mergeable&lt;X, Y, Z&gt;()
    Z merge(X, X, Y, Y, Z);
    </cxx-codeblock>
    </cxx-example>
    </p>

    <p>If a constrained declaration is introduced by a concept 
    introduction, then all its declarations must have the same 
    form.</p>

    <p>The sequence of introduced parameters in a 
    <cxx-grammarterm>concept-introduction</cxx-grammarterm>
    shall have the same number of template parameters as the referenced 
    concept.
    <cxx-example>
    <cxx-codeblock>
template&lt;typename T1, typename T2, typename T3 = T2&gt;
  concept bool Ineffable() { ... };

Ineffable{X, Y} void f();    // Error: does not introduce all parameters
Ineffable{X, Y, Z} void g(); // Ok
    </cxx-codeblock>
    </cxx-example>
    <cxx-note>
    Allowing default arguments to be deduced in a 
    <cxx-grammarterm>concept-introduction</cxx-grammarterm> would cause 
    the introduction of an unnamed and unusable template parameter in the 
    template declaration.
    </cxx-note>
  </cxx-section> <!-- concept.intro -->

</cxx-clause> <!-- temp -->

<!-- <cxx-publish-button source="https://github.com/cplusplus/fundamentals-ts"></cxx-publish-button>
 -->
</body>
</html>
