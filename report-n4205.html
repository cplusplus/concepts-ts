<head>
<style>
html { 
  font-size: 100%; 
  overflow-y: scroll; 
  -webkit-text-size-adjust: 100%; 
  -ms-text-size-adjust: 100%; 
}

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times;
  font-size:10px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

p{ margin:1em 0; }

img{ max-width:100%; }

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}

h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
  color:#666666;
  margin:0;
  padding-left: 3em;
  border-left: 0.5em #EEE solid;
}

hr { 
  display: block; 
  height: 2px; 
  border: 0; 
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #eee; 
  margin: 1em 0; padding: 0; 
}

pre, code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { 
  white-space: pre; 
  white-space: pre-wrap; 
  word-wrap: break-word; 
  padding: 5px 12px;
}

pre code { 
  border: 0px !important; padding: 0;
}

code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
  body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style>
</head>

<body>

<h1 id="n4205-editors-report">N4205 Editor's Report</h1>
<p>2014-10-17 Andrew Sutton University of Akron</p>
<h2 id="acknowledgments">Acknowledgments</h2>
<p>Special thanks to CWG for their input on these revisions, especially those members of the committee whose participated in the two telecon reviews in August and September.</p>
<p>Special thanks to those whose submitted editorial fixes and issues, including Michael Park, Jonathan Wakely, Fernando Pelliccioni, Casey Carter, Dinka Ranns, and Braden Obrzut.</p>
<h2 id="summary">Summary</h2>
<p>There is one new paper: N4205 replaces N4040 as the latest &quot;Concepts&quot; paper, and is significantly revised based on comments from the Rapperswil meeting, and the August and September teleconferences.</p>
<h2 id="changes">Changes</h2>
<p>The N4205 was renumbered to match layout of the current working draft the C++ Programming languages.</p>
<ul>
<li><p>[intro.refs] Fix reference to ISO standard</p></li>
<li><p>[intro.defns] Removed this subsection, preferring to define terms as needed in text.</p></li>
<li><p>[expr.prim.lambda] Introduce a new paragraph to define generic lambda in this section instead of in [dcl.spec.auto]</p></li>
<li><p>[expr.prim.lambda] Update paragraph 5 to define the member call operator of a generic lambda in terms of an abbreviated function, as specified in [dcl.fct].</p></li>
<li><p>[expr.prim.lambda] Paragraph 4 in N4040 was moved into [dcl.fct] and expanded with examples.</p></li>
<li><p>[epxr.prim.req] Updated the identifier for this section to match that of other primary expressions (expr.prim.req instead of expr.req).</p></li>
<li><p>[expr.prim.req] Refactored the <em>requirement-list</em> grammar so that each <em>requirement</em> is followed by <code>;</code> instead of having each kind of <em>requirement</em> have its own <code>;</code>. It was requested that the handling of requirements match statements, and allow <code>;;</code> as a requirement. This is not allowed by the current grammar since it could allow a <em>requires-expression</em> to declare an empty set of constraints, making it logically equivalent to an unconstrained template but not equivalent (different <em>constraint-expressions</em>).</p></li>
<li><p>[expr.prim.req] Moved grammar for specific requirements into subsections.</p></li>
<li><p>[expr.prim.req] Describe the scoping of local parameters.</p></li>
<li><p>[expr.prim.req] Prohibit ellipses (<code>requires (...)</code>) and default arguments for local parameters.</p></li>
<li><p>[expr.prim.req.*] Each section defines its requirements in terms of an introduced constraint described in [temp.constr.atom], as well as other editorial fixes (examples, spelling, grammar).</p></li>
<li><p>[expr.prim.req.type] Change the grammar to accept a <em>type-specifier</em> as a type requirement.</p></li>
<li><p>[dcl.spec.auto] As per discussion in Rapperswil, expanded this section to accommodate the use of <code>auto</code> in the type of a parameter. These modifications also allow multiple occurrences of <code>auto</code> in a single declaration. See <a href="/variadic%20placeholders/">Errata</a>.</p></li>
<li><p>[dcl.spec.constr] Update the introduction paragraphs to link the use of a <em>constrained-type-specifier</em> to the <code>auto</code> specifier. They can appear in some of the same contexts.</p></li>
<li><p>[dcl.spec.constr] Editorial revisions to the text describing the resolution of a <em>concept-name</em> and the synthesis of the associated constraint expression. In particular, the associated constraint now describes cases where either the <em>constrained-type-specifier</em> is followed by <code>...</code>, or the designated concept is variadic. See <a href="/concept%20resolution">Errata</a> for more information.</p></li>
<li><p>[dcl.spec.concept] Concepts shall only be defined at namespace scope.</p></li>
<li><p>[dcl.spec.concept] Refactor some of the limitations for function and variable concepts so they apply to both.</p></li>
<li><p>[dcl.spec.concept] Disallow any <em>decl-specifier</em>s other than <code>concept</code> and <code>bool</code>.</p></li>
<li><p>[dcl.spec.concept] Explicitly prohibit the use of <code>auto</code> to deduce the return type of a function concept definition because it requires the instantiation of the function definition to deduce the type.</p></li>
<li><p>[dcl.spec.concept] Drop the example in for the prohibition against explicit instantiation, explicit specialization, and partial specialization. It didn't provide any additional information.</p></li>
<li><p>[dcl.decl] Underline new grammar in <em>init-declarator</em> syntax.</p></li>
<li><p>[dcl.decl] As per discussion in Rapperswil, regular functions can be constrained. That prohibition is dropped in N4205.</p></li>
<li><p>[dcl.fct] Refactor the grammar for parameter declarations into <em>basic-parameter-declaration</em>, which does not include default arguments, and <em>parameter-declaration</em>, which is a <em>basic-parameter-declaration</em> plus an optional default argument. This change supports the definition of constrained template parameters in [temp.param].</p></li>
<li><p>[dcl.fct] In paragraph 5, add associated constraints to the list of things that all declarations for a function must agree in. On a second reading, the word &quot;exact&quot; is probably too strong for constraints; they should just be equivalent as per [temp.constr.expr].</p></li>
<li><p>[dcl.fct] Define abbreviated functions by moving most of the text describing generic lambdas to paragraph 16 and extend that text for <em>constrained-type-specifiers</em>.</p></li>
<li><p>[dcl.fct] Paragraph 17 describes how equivalent placeholders have the same invented template parameter. Equivalence is now defined in terms of the associated constraints. Added examples.</p></li>
<li><p>[dcl.fct.def] Remove the restriction against constrained function definitions being constrainable if they are function templates.</p></li>
<li><p>[dcl.fct.def] Remove the restriction that a destructor definition cannot be constrained.</p></li>
<li><p>[dcl.fct.def] Paragraph 9 ensures that function parameters are visible in the requires clause.</p></li>
<li><p>[class] In the grammar for member-declarators, the requires clause now appears before the pure-specifier-seq.</p></li>
<li><p>[class.mem] In paragraph 9, update examples for normal functions.</p></li>
<li><p>[class.mem] Paragraph 10 ensures that function parameters are visible in a requires clause.</p></li>
<li><p>[class.virtual] Added a new paragraph that prohibits associated constraints on virtual functions and overrides thereof.</p></li>
<li><p>[over] Add references to constraints to paragraphs 1 and 3, describing what it means to overload with constraints.</p></li>
<li><p>[over.match] Define declaration matching when the declarations have constraints.</p></li>
<li><p>[over.match.viable] Update paragraph 1 to include constraints in the determination of viable functions, and require the associated constraints to be satisfied in order for a function to be a viable candidate.</p></li>
<li><p>[over.match.best] Add a new ordering comparison; when two normal functions or member functions have equivalent parameter type lists, order by their constraints.</p></li>
<li><p>[over.over] Add test describing what happens when the address of an overloaded function is taken, and one or more of those candidates has associated constraints.</p></li>
<li><p>[temp] Move all text related to template introductions into a new sub-clause, 14.2.</p></li>
<li><p>[temp] Add text explicitly relating declarations have equivalent constraints, and many new examples describing these equivalences.</p></li>
<li><p>[temp.param] Refactor the grammar for non-type template parameter declarations to admit the constrained template parameters, and update the text in paragraph 2 to reflect that change.</p></li>
<li><p>[temp.param] Add paragraphs 3 and 4, which describe the declaration of constrained template parameters and restrictions.</p></li>
<li><p>[temp.param] Collapse several paragraphs in N4040 which describe the resolution of a concept iname into a reference to [dcl.spec.constr]. Clarify the properties of template parameters declared as a result of that resolution.</p></li>
<li><p>[temp.intro] This section was moved out of the beginning of [temp], and it describes how template parameters are introduced using a <em>concept-name</em> and a list of identifiers.</p></li>
<li><p>[temp.names] Make the title of this section match the standard.</p></li>
<li><p>[temp.names] Add a paragraph to explicitly require the instantiation of default template arguments when used in a context that requires them (other than for function templates).</p></li>
<li><p>[temp.names] Add a paragraph requiring associated constraints to be satisfied in order to refer to a type or variable.</p></li>
<li><p>[temp.arg.template] Describe the comparison of constraints in terms of &quot;most constrained&quot; instead of subsumption. Fix the broken example.</p></li>
<li><p>[temp.class] Require out-of-class member definitions to have the same constraints as the class declaration.</p></li>
<li><p>[temp.mem.func] Remove redundant text; wording for instantiation was moved to [temp.inst]. Merge the example from N4040 (paragraph 4 of the same section) into [temp.class].</p></li>
<li><p>[temp.mem] Require that member templates defined outside of their class to have the same constraints as their declaring class.</p></li>
<li><p>[temp.friend] Rewritten. Friend functions can be declared only when the constraints are non-dependent or they refer to a template specialization whose template can be found based on the specialization arguments. Constrained friend function definitions are permitted.</p></li>
<li><p>[temp.class.spec] Allow class template partial specializations to be constrained, and with a template argument list that matches the implicit argument list of the primary template.</p></li>
<li><p>[temp.class.match] Add an example that extends the one in the original document. Note that like the original document, the partial specializations being found are declared in [temp.class.spec].</p></li>
<li><p>[temp.class.order] Make examples core meaningful. Errors in the example in N4205 have been fixed in a future version of the paper.</p></li>
<li><p>[temp.over.link] Modify paragraph 6 to account for constraints in the equivalence of function templates and also the functional equivalence of those templates. Reformat those sentences into an itemized list for improved readability.</p></li>
<li><p>[temp.func.corder] Simplify the description of this ordering by rewriting the condition under which constraints are compared in terms of deduction instead template parameter lists and return types.</p></li>
<li><p>[temp.alias] An intermediate version of the paper reviewed during the teleconferences included requirements to check constraints for alias templates. This is now handled by [temp.names].</p></li>
<li><p>[temp.inst] Describe the implicit instantiation of member constraints inside a class template specialization. In particular, note that substitution failures in an associated constraint result in an ill-formed program.</p></li>
<li><p>[temp.inst] Require the satisfaction of constraints for an explicit instantiation naming a constrained template or a set of overloaded functions whose candidates may be constrained.</p></li>
<li><p>[temp.expl.spec] Require the satisfaction of constraints for an explicit specialization naming a constrained template or a set of overloaded functions whose candidates may be constrained.</p></li>
<li><p>[temp.deduct] Modified paragraph 5 to explicitly define a candidates associated constraints to be false if substitution into those constraints fails.</p></li>
<li><p>[temp.deduct.decl] Insert paragraph 2, which requires the filtering of declarations by unsatisfied constraints, and update paragraph 3 to follow from that modification.</p></li>
<li><p>[temp.constr] Completely rewritten based on a suggestion from Jens Mauer that perhaps describing constraints in terms of the expression machinery is not the right approach. This sub-clause now contains two major parts: the definition of constraints and the operations on constraints, and the definition of <em>constraint-expression</em>s and their normalization into constraints.</p></li>
<li><p>[temp.constr] Constraints are described as an abstract syntax (although no concrete grammar is given explicitly) and in a way that attempts to mirror [expr]. Each kind of constraint is defined in [temp.constr.op] or [temp.constr.atom]. There are two properties derived from constraints: satisfaction and subsumption. These are described for each kind of constraint.</p></li>
<li><p>[temp.constr] Satisfaction for any constraint is defined to fail if substitution of non-dependent arguments into it fails.</p></li>
<li><p>[temp.constr] The definition of subsumption in terms of a mapping from atomic constraints to truth values is replaced by a more algorithmic definition, which each constraint defining a piece of the subsumption relation.</p></li>
<li><p>[temp.constr.op] Define conjunction and disjunction separately from logical and and logical or.</p></li>
<li><p>[temp.constr.atom] Define atomic constraints separately from the different kinds of <em>requirements</em> in [expr.prim.req].</p></li>
<li><p>[temp.constr.atom] Split the &quot;result type constraint&quot; into two distinct atomic constraints: an implicit conversion constraint and an argument deduction constraint.</p></li>
<li><p>[temp.constr.atom] Describe expression and <code>constexpr</code> constraints separately, removing the ambiguity as to whether or not the expression <code>E</code> in a <em>compound-requirement</em> is an unevaluated operand. <code>E</code> is certainly evaluated to determine the satisfaction of a <code>constexpr</code> constraint.</p></li>
<li><p>[temp.constr.atom.expr] Renamed from &quot;valid expression&quot; constraint.</p></li>
<li><p>[temp.constr.atom.type] Renamed from &quot;valid type&quot; constraint.</p></li>
<li><p>[temp.constr.atom.conv] Define a requirement on the conversion of an expression to a type in terms of the implicit conversions. This allows the use of <code>void</code> in a <em>trailing-return-type</em> on a <em>compound-requirement</em>.</p></li>
<li><p>[temp.constr.atom.deduct] Define a deduction constraint in terms of successful template argument deduction against an invented function template whose sole parameter type is derived from the <em>trailing-return-type</em> of a <em>compound-requirement</em>.</p></li>
<li><p>[temp.constr.atom.constexpr] Document the fact that <code>constexpr</code> constraints apply on to specific arguments and not sets of arguments.</p></li>
<li><p>[temp.constr.atom.constexpr] Require the expression <code>E</code> to be a prvalue constant expression in order to be satisfied.</p></li>
<li><p>[temp.constr.atom.noexcept] Define satisfaction in terms of the <code>noexcept</code> expression.</p></li>
<li><p>[temp.constr.order] Define the partial ordering by constraints in terms of the subsumption relation. Provide references to the contexts in which this comparison is required.</p></li>
<li><p>[temp.constr.expr] Instead of defining properties of <em>constraint-expression</em>s, define constraints in terms of normalizing a constraint expression. Different kinds of expressions are mapped to different kinds of constraints by this algorithm.</p></li>
<li><p>[temp.constr.expr] Explicitly define when two constraints are equivalent. Note that this duplicates a good deal of text from [temp.over.link], but also provides additional rules for making <code>(E)</code> functionally equivalent to <code>E</code> but not equivalent.</p></li>
</ul>
</body>

