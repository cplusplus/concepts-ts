<cxx-clause id="dcl.dcl" number="7">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    Extend the <cxx-grammarterm>decl-specifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p class="quoted">
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
      <h1>Type specifiers</h1>

      <cxx-section id="dcl.type.simple" number="2">
        <h1>Simple type specifiers</h1>
        
        Add <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        to the grammar for <cxx-grammarterm>simple-type-specifier</cxx-grammarterm>s.

        <p class="quoted">
        <bnf-grammar>
          <bnf-rule>simple-type-specifier</bnf-rule>
            <ins><bnf-alt>constrained-type-specifier</bnf-alt></ins>
        </bnf-grammar>
        </p>
      </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
        <h1><code>auto</code> specifier</h1>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1 as
        follows:

        <p number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.
        </p>


        Add the following paragraphs after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1.

        <p class="quoted"> 
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        may be used to describe patterns of types to be matched deduction.

        Within such types, a placeholder type shall not appear in a non-deduced 
        context (<cxx-ref in="cxx" to="temp.deduct.type"></cxx-ref>).

<!--         When a <cxx-grammarterm>simple-type-specifier</cxx-grammarterm> is
        a <cxx-grammarterm>simple-template-id</cxx-grammarterm>, its
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> may contain
        multiple occurrences of the the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>.
 -->

        <cxx-example class="inline">
        <cxx-codeblock>
struct N {
  template&lt;typename T&gt; struct Wrap;
  template&lt;typename T&gt; static Wrap<T> make_wrap(T);
};
template&lt;typename T, typename U&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);

template&lt;int N&gt; struct Size { void f(int) { }  };
Size<0> s;

void (auto::*)(auto) p = &amp;Size&lt;0&gt;::f;   // <i>OK</i>
N::Wrap&lt;auto&gt; a = N::make_wrap(0.0);    // <i>OK</i>
Pair&lt;auto, auto&gt; p = make_pair(0, 'a'); // <i>OK</i>
auto::Wrap&lt;int&gt; x = N::make_wrap(0);    // <i>error:</i> auto <i>used in a non-deduced context</i>
Size&lt;sizeof(auto)&gt; y = s;               // <i>error:</i> auto <i>used in a non-deduced context</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/2 to read:

        <p number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, 
        <cxx-grammarterm>type-specifier-seq</cxx-grammarterm>,
        <cxx-grammarterm>conversion-function-id</cxx-grammarterm>, or
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        in any context where such a declarator is valid. 

        <ins>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        can also appear in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        function declarator.
        </ins>

        If the function declarator includes a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        (<cxx-ref to="dcl.fct"></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3 as follows:

        <p number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        a <cxx-grammarterm>parameter-declaration</cxx-grammarterm></del>
        <ins>in a parameter type</ins> 
        of a
        <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda is
        a <dfn>generic lambda</dfn>.

        <cxx-example class="inline">
        <cxx-codeblock>
auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i>
        </cxx-codeblock>
        </cxx-example>

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears in a parameter type of a function declarator, that is an 
        <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"></cxx-ref>)

        <cxx-example class="inline">
        <cxx-codeblock>
void f(const auto&amp;, int); // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3.

        <p class="quoted">
        If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        appears in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> 
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm> in
        a <cxx-grammarterm>requires-expression</cxx-grammarterm>, that
        return type introduces a deduction constraint
        (<cxx-ref to="expr.req.compound"></cxx-ref>).
        
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -> const auto&amp;; // <i>OK</i>
  };
}
        </cxx-codeblock>
        </cxx-example>

        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block"></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace"></cxx-ref>), and 
        in a <cxx-grammarterm>for-init-statement</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for"></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s of the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm>init-declarator</cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
( <i>expression-list</i> )
        </cxx-codeblock>
        the <cxx-grammarterm>expression-list</cxx-grammarterm> shall be a 
        single <cxx-grammarterm>assignment-expression</cxx-grammarterm>.
        </p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/7.

        <p class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm>braced-init-list</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list"></cxx-ref>), the program is 
        ill-formed. 

        <del>
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing the 
        occurrences of <code>auto</code> with either a new invented type 
        template parameter <code>U</code> or, if the initializer is a 
        <cxx-grammarterm>braced-init-list</cxx-grammarterm>, with 
        <code>std::initializer_list&lt;U&gt;</code>.
        </del>

        <ins>
        Otherwise, obtain <code>P</code> from <code>T</code> as follows:
        <ul>
        <li> in general, replace each occurrence of <code>auto</code> in
        the variable type with a new invented type template parameter, or </li>

        <li> when the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        of the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that occurrence of <code>auto</code> 
        with <code>std::initializer_list&lt;U&gt;</code>
        where <code>U</code> is an invented template type parameter.</li>
        </ul>
        </ins>

<!--        
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        if the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.
 -->

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call"></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
        <cxx-codeblock>
<ins>template&lt;typename T&gt; struct Vec { };
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;);</ins>

auto x1 = { 1, 2 };                 // <ins><i>OK:</i></ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = 12;                      // <i>OK:</i> decltype(x3) <i>is</i> int&amp;
const auto* p = &x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltype(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3};           // <i>error: cannot deduce element type</i></ins>
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        <cxx-codeblock>
const auto<ins>&amp;</ins><del> &amp;</del>i = expr;
        </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
template &lt;class U&gt; void f(const U&amp; u);
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
template&lt;typename F, typename S&gt; struct Pair;

Pair&lt;const auto&, auto*&gt; p = expr;
        </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(expr)</code> of the following invented function template:
        <cxx-codeblock>
template&lt;typename U1, typename U2&gt; void g(Pair&lt;const U1&amp;, const U2*&gt; x);
        </cxx-codeblock>
        </cxx-example>
        </p>
      </cxx-section> <!-- dcl.spec.auto -->


      <cxx-section id="dcl.spec.constr">
        <h1>Constrained type specifiers</h1>

        Add this section to <cxx-ref in="cxx" to="dcl.type"></cxx-ref>.



        <p> Like the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"></cxx-ref>),
        a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder that will be replaced later by deduction
        from the <cxx-grammarterm>expression</cxx-grammarterm> in a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> or a
        function argument. 

        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s have
        the form

        <bnf-grammar>
          <bnf-rule>constrained-type-specifier</bnf-rule>
            <bnf-alt>
              <bnf-opt>nested-name-specifier</bnf-opt> constrained-type-name
            </bnf-alt>

          <bnf-rule>constrained-type-name</bnf-rule>
            <bnf-alt>concept-name</bnf-alt>
            <bnf-alt>partial-concept-id</bnf-alt>

          <bnf-rule>concept-name</bnf-rule>
            <bnf-alt>identifier</bnf-alt>

          <bnf-rule>partial-concept-id</bnf-rule>
            <bnf-alt>
              concept-name 
              <bnf-terminal>&lt;</bnf-terminal> 
              <bnf-opt>template-argument-list</bnf-opt>
              <bnf-terminal>&gt;</bnf-terminal>
            </bnf-alt>
        </bnf-grammar>

        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        may also designate placeholders for deduced non-type and template 
        template arguments.

        This deduction succeeds only when the value deduced for the
        placeholder satisfies the constraints associated by the
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        </p>

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can appear in many of the same places as the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, is subject
        to the same rules, and has equivalent meaning in those contexts. 
        In particular, a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
        can appear in the following contexts with the given meaning:
        <ul>
        <li> a parameter type of a function declaration, signifying an 
             abbreviated function (<cxx-ref to="dcl.fct"></cxx-ref>);</li>
        <li> a parameter of a lambda, signifying a generic lambda 
             (<cxx-ref to="expr.prim.lambda"></cxx-ref>);</li>
        <li> the parameter type of a template parameter, signifying a
             constrained parameter (<cxx-ref to="temp.param"></cxx-ref>);</li>
        <li> the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of
             a <cxx-grammarterm>compound-requirement</cxx-grammarterm>,
             signifying a deduction constraint (<cxx-ref to="expr.req.compound"></cxx-ref>). </li>
        </ul>
        A program that includes <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in any other contexts is ill-formed.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

template&lt;typename T&gt; class Vec;

struct N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;

auto gl = [](C&amp; a, C* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);             // <i>OK: an abbreviated function</i>

void f1(N::Wrap&lt;C&gt;);    // <i>OK</i>
void f2(Pair&lt;C, D&lt;0&gt;&gt;); // <i>OK</i>
void f3(C::Wrap&lt;D&lt;1&gt;&gt;); // <i>error:</i> C <i>used in a non-deduced context</i>
        </cxx-codeblock>
Like the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>, 
a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> shall not be 
used in a non-deduced context (<cxx-ref in="cxx" to="temp.deduct.type"></cxx-ref>).
        </cxx-example>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -> const C&; // <i>OK: a deduction constraint</i>
  };
}
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

const C* x = 0;  // <i>error:</i> C <i>used in a variable type</i>
D&lt;0&gt; fn(int x);  // <i>error:</i> D&lt;0&gt; <i>used as a return type</i>
        </cxx-codeblock>
A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> cannot be
used in the type of a variable declaration or the return type of a function.
        </cxx-example>

        <!-- </p> -->

        <!--
        <p> A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from the <cxx-grammarterm>expression</cxx-grammarterm> in a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> or 
        function argument. 

        This deduction succeeds only when the deduced type satisfies the
        constraints introduced by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
        also signifies that a lambda is a generic lambda or
        that a function is an abbreviated function. 
        </p>

        <p> When a <cxx-grammarterm>simple-type-specifier</cxx-grammarterm> is a
        <cxx-grammarterm>simple-template-id</cxx-grammarterm>, its
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> may contain
        multiple <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s.
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> shall
        not appear in a non-deduced context.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

namespace N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;

void f1(N::Wrap&lt;C&gt;);    // <i>OK</i>
void f2(Pair&lt;C, D&lt;0&gt;&gt;); // <i>OK</i>
void f3(C::Wrap&lt;D&lt;1&gt;&gt;); // <i>error:</i> C <i>used in a non-deduced context</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p> 
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can appear with a function declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> or in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in that
        declarator, in any context where such a declarator is valid.
        </p>


        <p> If <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
        of a <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda
        is a generic lambda (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        Similarly, if a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        function declaration, the function is an abbreviated function
        (<cxx-ref to="dcl.fct"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; class Vec;

auto gl = [](C&amp; a, C* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);             // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can also appear in the 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> in a
        <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -> const C&; // OK
  };
}
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A program that uses a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in a context not explicitly allowed by this section is ill-formed.
        </p>

        -->


        <p>
        A <cxx-grammarterm>concept-name</cxx-grammarterm> refers to a
        set of concept definitions (<cxx-ref to="dcl.spec.concept"></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        If that set is empty, the program is ill-formed.

        <cxx-note>
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member of this set when a 
        <cxx-grammarterm>concept-name</cxx-grammarterm>
        refers to a variable concept.
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#3</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #3</i>
        </cxx-codeblock>
        </cxx-example>
        </p>


        <p>
        A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
        <cxx-grammarterm>concept-name</cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm>template-argument</cxx-grammarterm>s.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        The concept designated by a 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        is resolved by determining the viability of each concept in the
        candidate concept set.

        For each concept, <code>C<sub><i>i</i></sub></code>, in the candidate concept 
        set referred to by the concept name, <code>C</code>, form a 
        <cxx-grammarterm>template-id</cxx-grammarterm>, <code>TT</code>
        as follows.

        Let <code>X</code> be a template argument that matches
        the type and form (<cxx-ref to="temp.arg"></cxx-ref>) of the prototype 
        parameter (<cxx-ref to="dcl.spec.concept"></cxx-ref>)
        of the <i>i</i><sup>th</sup> candidate concept, <code>C<sub><i>i</i></sub></code>. 

        If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>concept-name</cxx-grammarterm>, <code>TT</code> is
        formed as <code>C&lt;X&gt;</code>.

        If the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>,
        <code>TT</code> is formed as
        <code>C&lt;X, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>.

        The concept <code>C<sub><i>i</i></sub></code> is a 
        <dfn>viable concept candidate</dfn> when all
        <cxx-grammarterm>template-arguments</cxx-grammarterm> of <code>TT</code> 
        match the template parameters of the concept, 
        <code>C<sub><i>i</i></sub></code> (<cxx-ref to="temp.arg"></cxx-ref>).

        If, after determining the viability of each concept, there is a
        single viable concept candidate, that is the concept designated by the
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i>
        </cxx-codeblock>
        </cxx-example>
        </p>


        <p>The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the constraint is associated with
        the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        For an abbreviated function declaration, the constraint is associated
        with that function (<cxx-ref to="dcl.fct"></cxx-ref>).

        The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of
        a <cxx-grammarterm>compound-requirement</cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"></cxx-ref>).
        </p>

        <p>
        The constraint associated by a 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        is derived from the <cxx-grammarterm>template-id</cxx-grammarterm> 
        (called <code>TT</code> above) used to determine the viability of
        the designated concept (call it <code>D</code>).

        The associated constraint is
        the <cxx-grammarterm>id-expression</cxx-grammarterm>
        <code>TT</code> when the <code>D</code> is a variable concept, and
        the function call <code>TT()</code> when the <code>D</code> is a 
        function concept.
        
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }
template&lt;int N&gt; concept bool Num = true;

template&lt;int&gt; struct X { };

void f(C&amp;);     // <i>associates</i> C&lt;T1&gt; <i>with</i> f
void g(D&lt;int&gt;); // <i>associates</i> D&lt;T2, int&gt;() <i>with</i> g
void h(X&lt;Num&gt;); // associates Num&lt;M&gt; <i>with</i> h
        </cxx-codeblock>
        In the associated constraints, <code>T1</code> and <code>T2</code> 
        are invented type template parameters corresponding to the
        prototype parameter of their respective designated concepts.
        Likewise, <code>M</code> is a non-type template parameter
        corresponding to the prototype parameter of <code>Num</code>.
        </cxx-example>
        </p>


        <p>
        When multiple <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        appear in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        or a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        the associated constraints are a conjunction of the constraints 
        associated by each <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        These constraints are evaluated in the order in which they appear.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D = true;
tempkate&lt;typename A, typename B&gt; class Pair;

void f(Pair&lt;C, D&lt;int&gt;&gt;&amp; p);
        </cxx-codeblock>
        The constraint associated by the type of the parameter <code>p</code>
        are:
        <cxx-codeblock>
C&lt;T1&gt; &amp;&amp; D&lt;T2, int&gt;
        </cxx-codeblock>
        where <code>T1</code> and <code>T2</code> are the invented template
        type parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        <code>C</code> and <code>D&lt;int&gt;</code>.
        </p>
      </cxx-section> <!-- dcl.spec.constr -->

    </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
      <h1><code>concept</code> specifier</h1>

      <p> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template, declared
      in namespace scope (<cxx-ref in="cxx" to="basic.scope.namespace"></cxx-ref>).
      
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. 
      
      A variable template definition having the <code>concept</code> 
      specifier is called a <dfn>variable concept</dfn>.

      A <dfn>concept definition</dfn> refers to either a function concept 
      and its definition or a variable concept and its initializer.

      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool F1() { return true; } // <i>OK: declares a function concept</i>
template&lt;typename T&gt; 
  concept bool F2();                 // <i>error: function concept is not a definition</i>
template&lt;typename T&gt; 
  concept bool V1 = true;            // <i>OK: declares a variable concept</i>
template&lt;typename T&gt; 
  concept bool V2;                   // <i>error: variable concept with no initializer</i>
struct S {
  template&lt;typename T&gt; 
    static concept bool C = true;    // <i>error: concept declared in class scope</i>
};
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      <!-- FIXME: Am I using this? -->
      A <dfn>type concept</dfn> is a concept whose prototype parameter is a type
      <cxx-grammarterm>template-parameter</cxx-grammarterm>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).
      </p>

      <p>A function concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The return type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm>expression</cxx-grammarterm> shall be a
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept int C2() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept bool C3(T) { return true; } // <i>error: must have no parameters</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A variable concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool V2 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
template&lt;Integral T&gt; 
  concept bool V3 = true;  // <i>error: constrained template declared as a concept</i>
concept bool V4 = 0;       // <i>error: not a template</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A program that declares an explicit instantiation, an explicit 
      specialization, or a partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = false;

template concept bool C&lt;char&gt;; // <i>error: explicit instantiation of a concept</i>
template&lt;&gt; 
  concept bool C&lt;int&gt; = true;  // <i>error: explicit specialization of a concept</i>
template&lt;typename T&gt; 
  concept bool C&lt;T*&gt; = true;   // <i>error: partial specialization of a concept</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->
