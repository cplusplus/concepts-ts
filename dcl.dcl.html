<cxx-clause id="dcl.dcl" number="7">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    Extend the <cxx-grammarterm>decl-specifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p class="quoted">
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
      <h1>Type specifiers</h1>

      <cxx-section id="dcl.type.simple" number="2">
        <h1>Simple type specifiers</h1>
        
        Add <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        to the grammar for <cxx-grammarterm>simple-type-specifier</cxx-grammarterm>s
        in <cxx-ref in="cxx" to="dcl.type.simple"></cxx-ref>.

        <p class="quoted">
        <bnf-grammar>
          <bnf-rule>simple-type-specifier</bnf-rule>
            <ins><bnf-alt>constrained-type-specifier</bnf-alt></ins>

          <ins>
          <bnf-rule>constrained-type-specifier</bnf-rule>
            <bnf-alt>
              <bnf-opt>nested-name-specifier</bnf-opt> constrained-type-name
            </bnf-alt>

          <bnf-rule>constrained-type-name</bnf-rule>
            <bnf-alt>concept-name</bnf-alt>
            <bnf-alt>partial-concept-id</bnf-alt>

          <bnf-rule>concept-name</bnf-rule>
            <bnf-alt>identifier</bnf-alt>

          <bnf-rule>partial-concept-id</bnf-rule>
            <bnf-alt>
              concept-name 
              <bnf-terminal>&lt;</bnf-terminal> 
              template-argument-list
              <bnf-terminal>&gt;</bnf-terminal>
            </bnf-alt>
          </ins>
        </bnf-grammar>
        </p>
      </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
        <h1><code>auto</code> specifier</h1>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1 as
        follows:

        <p number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.
        </p>


        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1.

        <p>
        When a <cxx-grammarterm>simple-type-specifier</cxx-grammarterm> is
        a <cxx-grammarterm>simple-template-id</cxx-grammarterm>, its
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> may contain
        multiple occurrences of the the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>.

        A placeholder type shall not appear in a non-deduced context
        (<cxx-ref in="cxx" to="temp.deduct.type"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
namespace N {
  template&lt;typename T&gt; struct Wrap;
  template&lt;typename T&gt; Wrap<T> make_wrap(T);
}
template&lt;typename T, typename U&gt; struct Pair;
template&lt;typename T, typename U&gt; Pair&lt;T, U&gt; make_pair(T, U);
template&lt;int N&gt; struct Size { };
Size<0> s;

N::Wrap&lt;auto&gt; a = N::make_wrap(0.0);    // OK
Pair&lt;auto, auto&gt; p = make_pair(0, 'a'); // OK
auto::Wrap&lt;int&gt; x = N::make_wrap(0);    // <i>error:</i> auto <i>used in a non-deduced context</i>
Size&lt;sizeof(auto)&gt; y = s;               // <i>error:</i> auto <i>used in a non-deduced context</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <!--
        <p class="quoted">
        <ins>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        can be used to construct different forms of types, provided that
        the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall not appear in a non-deduced context 
        (<cxx-ref in="cxx" to="temp.deduct.type"></cxx-ref>),
        and that the type containing the <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall have one of the following forms:
        <cxx-codeblock>
auto
<i>cv-list</i> auto
auto*
auto&amp;
auto&amp;&amp;
auto[<i>integer-constant</i>]
<i>template-name</i>&lt;auto&gt; (where <i>template-name</i> refers to a class template)
<i>type</i>(auto)
auto()
auto <i>type</i>::*
<i>type</i> auto::*
auto (<i>type</i>::*)()
<i>type</i> (auto::*)()
<i>type</i> (<i>type</i>::*)(auto)
        </cxx-codeblock>

        where <code>(auto)</code> represents a 
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm>
        where at least one parameter type contains an <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, and 
        <code>()</code> represents a
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm> where no 
        parameter type contains an <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>. 

        Similarly, <code>&lt;T&gt;</code> represents template argument
        lists where at least one argument contains an
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>.

        <cxx-note>
        Placeholder types designated by the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm> are replaced by
        invented template parameters to facilitate the deduction of a
        value for that type. These forms, and the use of <code>auto</code> within 
        them, are the only forms for which template type deduction can succeed.
        </cxx-note>
        </ins>
        </p>
        -->

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/2 to read:

        <p number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, 
        <cxx-grammarterm>type-specifier-seq</cxx-grammarterm>,
        <cxx-grammarterm>conversion-function-id</cxx-grammarterm>, or
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        in any context where such a declarator is valid. 

        <ins>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        can also appear in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of
        function declarator.
        </ins>

        If the function declarator includes a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        (<cxx-ref to="dcl.fct"></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3 as follows:

        <p number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        a <cxx-grammarterm>parameter-declaration</cxx-grammarterm></del>
        <ins>in the parameter types</ins> 
        of a
        <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda is
        a <dfn>generic lambda</dfn>.

        <cxx-example class="inline">
        <cxx-codeblock>
auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i>
        </cxx-codeblock>
        </cxx-example>

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears in the parameter types of a function declarator, that is an 
        <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"></cxx-ref>)

        <cxx-example class="inline">
        <cxx-codeblock>
void f(const auto&amp;, int); // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3.

        <p class="quoted">
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        can appear in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> 
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm> in
        a <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req.compound"></cxx-ref>).
        
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -> const auto&amp;; // <i>OK</i>
  };
}
        </cxx-codeblock>
        </cxx-example>

        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block"></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace"></cxx-ref>), and 
        in a <cxx-grammarterm>for-init-statement</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for"></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm>init-declarator</cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
( <i>expression-list</i> )
        </cxx-codeblock>
        the <cxx-grammarterm>expression-list</cxx-grammarterm> shall be a 
        single <cxx-grammarterm>assignment-expression</cxx-grammarterm>.
        </p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/7.

        <p class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm>braced-init-list</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list"></cxx-ref>), the program is 
        ill-formed. 

        <!-- General rule for constructing P -->
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        <!-- The much maligned init deduction -->
        if the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call"></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; struct Vec;
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;);

auto x1 = { 1, 2 };                 // <ins><i>OK:</i></ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = 12;                      // <i>OK:</i> decltype(x3) <i>is</i> const int&amp;
const auto* p = &x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltype(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3};           // <i>error: cannot deduce element type</i></ins>
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        <cxx-codeblock>
const auto<ins>&amp;</ins><del> &amp;</del>i = expr;
        </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
template &lt;class U&gt; void f(const U&amp; u);
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
template&lt;typename F, typename S&gt; struct Pair;

Pair&lt;const auto&, auto*&gt; p = expr;
        </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(expr)</code> of the following invented function template:
        <cxx-codeblock>
template&lt;typename U1, typename U2&gt; void g(Pair&lt;const U1&amp;, const U2*&gt; x);
        </cxx-codeblock>
        </cxx-example>
        </p>

      </cxx-section> <!-- dcl.spec.auto -->


      <cxx-section id="dcl.spec.constr">
        <h1>Constrained type specifiers</h1>

        Add this section to <cxx-ref in="cxx" to="dcl.type"></cxx-ref>.

        <p> A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from the <cxx-grammarterm>expression</cxx-grammarterm> in a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> or 
        function argument. 

        This deduction succeeds only when the deduced type satisfies the
        constraints introduced by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
        also signifies that a lambda is a generic lambda or
        that a function is an abbreviated function. 
        </p>

        <p> When a <cxx-grammarterm>simple-type-specifier</cxx-grammarterm> is a
        <cxx-grammarterm>simple-template-id</cxx-grammarterm>, its
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> may contain
        multiple <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s.
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> shall
        not appear in a non-deduced context.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, int N&gt; concept bool D = true;

namespace N {
  template&lt;typename T&gt; struct Wrap;
}
template&lt;typename T, typename U&gt; struct Pair;

void f1(N::Wrap&lt;C&gt;);    // <i>OK</i>
void f2(Pair&lt;C, D&lt;0&gt;&gt;); // <i>OK</i>
void f3(C::Wrap&lt;D&lt;1&gt;&gt;); // <i>error:</i> C <i>used in a non-deduced context</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p> 
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can appear with a function declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> or in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> in that
        declarator, in any context where such a declarator is valid.
        </p>


        <!-- TODO: Consider adding this to the list of non-deduced contexts. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->

        <p> If <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
        of a <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda
        is a generic lambda (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        Similarly, if a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        function declaration, the function is an abbreviated function
        (<cxx-ref to="dcl.fct"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; class Vec;

auto gl = [](C&amp; a, C* b) { a = *b; }; // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);             // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can also appear in the 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> in a
        <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -> const C&; // OK
  };
}
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A program that uses a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in a context not explicitly allowed by this section is ill-formed.
        </p>


        <p>
        When an <cxx-grammarterm>identifier</cxx-grammarterm> is a 
        <cxx-grammarterm>concept-name</cxx-grammarterm> it refers to a set
        of concept definitions (<cxx-ref to="dcl.spec.concept"></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.

        Only type concepts are included in the candidate concept set of
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        
        <cxx-note>
        The candidate concept set of a 
        <cxx-grammarterm>concept-name</cxx-grammarterm> in a
        <cxx-grammarterm>constrained-parameter</cxx-grammarterm> includes
        non-type concepts (<cxx-ref to="temp.param"></cxx-ref>).
        </cxx-note>

        If the candidate concept set is empty, the program is ill-formed.

        <cxx-note>
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member of this set when a 
        <cxx-grammarterm>concept-name</cxx-grammarterm>
        refers to a variable concept.
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;int N&gt; concept bool C() { return true; }                  // <i>#3</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#4</i>
template&lt;template&lt;typename&gt; class X&gt; concept bool P = true;        // <i>#5</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #4</i>
void h(P); // <i>error: no matching concept definitions for</i> P
        </cxx-codeblock>
        In the declaration of <code>f(C)</code>, the candidate concept set
        corresponding to the <cxx-grammarterm>concept-name</cxx-grammarterm>,
        <code>C</code>, does not include #3 because its first
        <cxx-grammarterm>template-parameter</cxx-grammarterm> of that
        concept definition is a non-type template parameter.
        Likewise, in the declaration of <code>h(P)</code>, #5 is not
        included because its prototype parameter is not a template
        <cxx-grammarterm>type-parameter</cxx-grammarterm>.
        </cxx-note>
        </p>

        <p>
        A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
        <cxx-grammarterm>concept-name</cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm>template-argument</cxx-grammarterm>s.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        The concept definition designated by a
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is
        determined by forming a <cxx-grammarterm>template-id</cxx-grammarterm>
        from the <cxx-grammarterm>concept-name</cxx-grammarterm> and
        a sequence of <cxx-grammarterm>template-arguments</cxx-grammarterm>.

        Let <code>C</code> be the <cxx-grammarterm>concept-name</cxx-grammarterm>
        in the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
        and let <code>T</code> be an invented template <cxx-grammarterm>type-parameter</cxx-grammarterm>
        corresponding to the placeholder type that the
        <cxx-grammarterm>type-specifier</cxx-grammarterm> designates.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>concept-name</cxx-grammarterm>, the
        <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T&gt;</code>.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>,
        the <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>.

        If the <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
        single concept declaration in the candidate concept set, that 
        concept is the one designated by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-note>
        A <cxx-grammarterm>template-id</cxx-grammarterm> may not refer to
        a template specialization if the template arguments do not match
        the template's declared parameters (<cxx-ref to="temp.arg"></cxx-ref>).
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i>
        </cxx-codeblock>
        </cxx-example>
        </p>


        <p>The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the associated constraint appertains 
        to the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        For an abbreviated function declaration, the associated constraint 
        appertains to that function (<cxx-ref to="dcl.fct"></cxx-ref>).

        The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of
        a <cxx-grammarterm>compound-requirement</cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"></cxx-ref>).
        </p>

        <p>
        The constraint associated by a 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        is formed from the <cxx-grammarterm>template-id</cxx-grammarterm>
        used to determine the designated concept. The associated
        constraint is
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>
        when the designated concept is a variable concept
        and 
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;()</code>
        when the designated concept is a function concept.
        
        <cxx-note>
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>
        is empty if the <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
        is a <cxx-grammarterm>concept-name</cxx-grammarterm>.
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }

void f(C&amp;);     // associates C&lt;T1&gt; with f
void g(D&lt;int&gt;); // associates D&lt;T2, int&gt; with g
        </cxx-codeblock>
        In the associated constraints, <code>T1</code> and <code>T2</code> 
        are invented template type parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in their respective declarations.
        </cxx-example>
        </p>


        <p>
        When multiple <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        appear in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        or a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        the associated or introduced constraints are a conjunction of the
        constraints associated by each 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        These constraints are evaluated in the order in which they appear.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D = true;
tempkate&lt;typename A, typename B&gt; class Pair;

void f(Pair&lt;C, D&lt;int&gt;&gt;&amp; p);
        </cxx-codeblock>
        The constraint associated by the type of the parameter <code>p</code>
        are:
        <cxx-codeblock>
C&lt;T1&gt; &amp;&amp; D&lt;T2, int&gt;
        </cxx-codeblock>
        where <code>T1</code> and <code>T2</code> are the invented template
        type parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        <code>C</code> and <code>D&lt;int&gt;</code>.
        </p>
      </cxx-section> <!-- dcl.spec.constr -->

    </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
      <h1><code>concept</code> specifier</h1>

      <p> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its definition or 
      a variable concept and its initializer.</p>

      <p> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      A <dfn>type concept</dfn> is a concept whose prototype parameter is a type
      <cxx-grammarterm>template-parameter</cxx-grammarterm>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).
      </p>

      <p>A function concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The return type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm>expression</cxx-grammarterm> shall be a
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool C1() { return true; }  // <i>OK</i>
template&lt;typename T&gt; 
  concept int C2() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept bool C3(T) { return true; } // <i>error: must have no parameters</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A variable concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool V1 = true;  // OK
template&lt;typename T&gt; 
  concept bool V2 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
template&lt;Integral T&gt; 
  concept bool V3 = true;  // <i>error: constrained template</i>
concept bool V4 = 0;       // <i>error: not a template</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A program that declares an explicit instantiation, an explicit 
      specialization, or a partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = false;

template concept bool C&lt;char&gt;; // <i>error: explicit instantiation of a concept</i>
template&lt;&gt; 
  concept bool C&lt;int&gt; = true;  // <i>error: explicit specialization of a concept</i>
template&lt;typename T&gt; 
  concept bool C&lt;T*&gt; = true;   // <i>error: partial specialization of a concept</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->
