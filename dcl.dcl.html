<cxx-clause id="dcl.dcl" number="7">
  <h1>Declarations</h1>

  <cxx-section id="dcl.spec">
    <h1>Specifiers</h1>

    Extend the <cxx-grammarterm>decl-specifier</cxx-grammarterm> production
    to include the <code>concept</code> specifier.

    <p class="quoted">
    <bnf-grammar>
      <bnf-rule>decl-specifier</bnf-rule>
        <ins><bnf-alt><bnf-terminal>concept</bnf-terminal></bnf-alt></ins>
    </bnf-grammar>
    </p>

    <cxx-section id="dcl.type" number="6">
      <h1>Type specifiers</h1>

      <cxx-section id="dcl.type.simple" number="2">
        <h1>Simple type specifiers</h1>
        
        Add <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        to the grammar for <cxx-grammarterm>simple-type-specifier</cxx-grammarterm>s
        in <cxx-ref in="cxx" to="dcl.type.simple"></cxx-ref>.

        <p class="quoted">
        <bnf-grammar>
          <bnf-rule>simple-type-specifier</bnf-rule>
            <ins><bnf-alt>constrained-type-specifier</bnf-alt></ins>

          <ins>
          <bnf-rule>constrained-type-specifier</bnf-rule>
            <bnf-alt>
              <bnf-opt>nested-name-specifier</bnf-opt> constrained-type-name
            </bnf-alt>

          <bnf-rule>constrained-type-name</bnf-rule>
            <bnf-alt>concept-name</bnf-alt>
            <bnf-alt>partial-concept-id</bnf-alt>

          <bnf-rule>concept-name</bnf-rule>
            <bnf-alt>identifier</bnf-alt>

          <bnf-rule>partial-concept-id</bnf-rule>
            <bnf-alt>
              concept-name 
              <bnf-terminal>&lt;</bnf-terminal> 
              template-argument-list
              <bnf-terminal>&gt;</bnf-terminal>
            </bnf-alt>
          </ins>
        </bnf-grammar>
        </p>
      </cxx-section> <!-- dcl.type.simple -->


      <cxx-section id="dcl.spec.auto" number="4">
        <h1><code>auto</code> specifier</h1>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1 as
        follows:

        <p number="1" class="quoted">
        The <code>auto</code> and <code>decltype(auto)</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>s designate a 
        placeholder type that will be replaced later, either by deduction from 
        an initializer or by explicit specification with a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>. The 
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        is also used to signify that a lambda is a generic lambda<ins> or
        that a function declaration is an abbreviated function</ins>.
        </p>


        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/1.

        <p class="quoted">
        <ins>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        can be used to construct different forms of types, provided that
        the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall not appear in a non-deduced context 
        (<cxx-ref in="cxx" to="temp.deduct.type"></cxx-ref>),
        and that the type containing the <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        shall have one of the following forms:
        <cxx-codeblock>
auto
<i>cv-list</i> auto
auto*
auto&amp;
auto&amp;&amp;
auto[<i>integer-constant</i>]
<i>template-name</i>&lt;auto&gt; (where <i>template-name</i> refers to a class template)
<i>type</i>(auto)
auto()
auto <i>type</i>::*
<i>type</i> auto::*
auto (<i>type</i>::*)()
<i>type</i> (auto::*)()
<i>type</i> (<i>type</i>::*)(auto)
        </cxx-codeblock>

        where <code>(auto)</code> represents a 
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm>
        where at least one parameter type contains an <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>, and 
        <code>()</code> represents a
        <cxx-grammarterm>parameter-type-list</cxx-grammarterm> where no 
        parameter type contains an <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>. 

        Similarly, <code>&lt;T&gt;</code> represents template argument
        lists where at least one argument contains an
        <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>.

        <cxx-note>
        Placeholder types designated by the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm> are replaced by
        invented template parameters to facilitate the deduction of a
        value for that type. These forms, and the use of <code>auto</code> within 
        them, are the only forms for which template type deduction can succeed.
        </cxx-note>
        </ins>
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/2 to read:

        <p number="2" class="quoted">
        <del>The</del><ins>A</ins> placeholder type can appear with a function 
        declarator in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, 
        <cxx-grammarterm>type-specifier-seq</cxx-grammarterm>,
        <cxx-grammarterm>conversion-function-id</cxx-grammarterm>, or 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>, in any 
        context where such a declarator is valid. 

        If the function declarator includes a 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm>
        (<cxx-ref to="dcl.fct"></cxx-ref>),
        that specifies the declared return type of the function.

        If the declared return type of the function contains a placeholder 
        type, the return type of the function is deduced from return 
        statements in the body of the function, if any.
        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3 as follows:

        <p number="3" class="quoted">
        If the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears
        <del>as one of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of</del>
        <ins>in the type of</ins>
        a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a 
        <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda is
        a <dfn>generic lambda</dfn>.

        <cxx-example class="inline">
        <cxx-codeblock>
auto glambda = [](int i, auto a) { return i; }; // <i>OK: a generic lambda</i>
        </cxx-codeblock>
        </cxx-example>

        <ins>
        Similarly, if the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        appears in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        of a function declaration, the function is an <dfn>abbreviated function</dfn> 
        (<cxx-ref to="dcl.fct"></cxx-ref>)

        <cxx-example class="inline">
        <cxx-codeblock>
void f(const auto&amp;, int); // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </ins>
        </p>

        Add the following paragraph after 
        <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/3.

        <p class="quoted">
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm> 
        can appear in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> 
        of a <cxx-grammarterm>compound-requirement</cxx-grammarterm> in
        a <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req.compound"></cxx-ref>).
        
        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() {
  return requires (T i) { 
    {*i} -> const auto&amp;; // <i>OK</i>
  };
}
        </cxx-codeblock>
        </cxx-example>

        </p>

        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/4. The examples
        in the original text are unchanged and therefore omitted.

        <p number="4" class="quoted">
        The type of a variable declared using <code>auto</code> or 
        <code>decltype(auto)</code> is deduced from its initializer. This use 
        is allowed when declaring variables 
        in a block 
        (<cxx-ref in="cxx" to="stmt.block"></cxx-ref>), 
        in namespace scope
        (<cxx-ref in="cxx" to="basic.scope.namespace"></cxx-ref>), and 
        in a <cxx-grammarterm>for-init-statement</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="stmt.for"></cxx-ref>).

        <del>
        <code>auto</code> or <code>decltype(auto)</code> shall appear as one 
        of the <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>
        </del>

        <ins>
        Either <code>auto</code> shall appear in the 
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>, or
        <code>decltype(auto)</code> shall appear as one of the
        <cxx-grammarterm>decl-specifier</cxx-grammarterm>s in the
        <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm>.
        </ins>

        <del>and the</del><ins>The</ins> <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> 
        shall be followed by one or more <cxx-grammarterm>init-declarator</cxx-grammarterm>s,
        each of which shall have a non-empty initializer.

        In an initializer of the form
        <cxx-codeblock>
( <i>expression-list</i> )
        </cxx-codeblock>
        the <cxx-grammarterm>expression-list</cxx-grammarterm> shall be a 
        single <cxx-grammarterm>assignment-expression</cxx-grammarterm>.
        </p>


        Modify <cxx-ref in="cxx" to="dcl.spec.auto"></cxx-ref>/7.

        <p class="quoted">
        When a variable declared using a placeholder type is initialized, or 
        a <code>return</code> statement occurs in a function declared with a 
        return type that contains a placeholder type, the deduced return type 
        or variable type is determined from the type of its initializer. 

        In the case of a return with no operand, the initializer is
        considered to be <code>void()</code>. 

        Let <code>T</code> be the declared type of the variable or return 
        type of the function. 

        <del>If the placeholder is the <code>auto</code> 
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</del>
        <ins>If <code>T</code> contains any occurrences of the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>,</ins>
        the deduced type is determined using the rules for template argument
        deduction. 

        If the deduction is for a return statement and the initializer is a 
        <cxx-grammarterm>braced-init-list</cxx-grammarterm> 
        (<cxx-ref in="cxx" to="dcl.init.list"></cxx-ref>), the program is 
        ill-formed. 

        <!-- General rule for constructing P -->
        Otherwise, obtain <code>P</code> from <code>T</code> by replacing 
        <del>the occurrences</del>
        <ins>each occurrence</ins>
        of <code>auto</code> with <del>either</del> a new invented type
        template parameter <del><code>U</code></del> or, 

        <!-- The much maligned init deduction -->
        if the initializer is a <cxx-grammarterm>braced-init-list</cxx-grammarterm>
        <ins>and <code>auto</code> is a <cxx-grammarterm>decl-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>decl-specifier-seq</cxx-grammarterm> of
        the variable declaration, replace that single occurrence of
        <code>auto</code></ins><del>,</del> with <code>std::initializer_list&lt;U&gt;</code>
        <ins>where <code>U</code> is an invented template type parameter</ins>.

        Deduce a value for 
        <del><code>U</code></del>
        <ins>each invented template type parameter in <code>P</code></ins>
        using the rules of template argument 
        deduction from a function call 
        (<cxx-ref in="cxx" to="temp.deduct.call"></cxx-ref>),
        where <code>P</code> is a function template parameter type and the 
        initializer is the corresponding argument. 

        If the deduction fails, the declaration is ill-formed. 

        Otherwise, the type deduced for the variable or return type is obtained 
        by substituting the deduced 
        <del><code>U</code></del>
        <ins>values for each invented template parameter</ins> 
        into <code>P</code>.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; struct Vec;
template&lt;typename T&gt; Vec&lt;T&gt; make_vec(std::initalizer_list&lt;T&gt;);

auto x1 = { 1, 2 };                 // <ins><i>OK:</i> </ins> decltype(x1) <i>is</i> std::initializer_list&lt;int&gt;
auto x2 = { 1, 2.0 };               // <i>error: cannot deduce element type</i> <ins>
auto&amp; x3 = 12;                      // <i>OK:</i> decltype(x3) <i>is</i> const int&amp;
const auto* p = &x3;                // <i>OK:</i> decltype(p) <i>is</i> const int*
Vec&lt;auto&gt; v1 = make_vec({1, 2, 3}); // <i>OK:</i> decltpye(v1) <i>is</i> Vec&lt;int&gt;
Vec&lt;auto&gt; v2 = {1, 2, 3});          // <i>error: cannot deduce element type</i></ins>
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        <cxx-codeblock>
const auto<ins>&amp;</ins><del> &amp;</del>i = expr;
        </cxx-codeblock>
        The type of <code>i</code> is the deduced type of the parameter 
        <code>u</code> in the call <code>f(expr)</code> of the following 
        invented function template:
        <cxx-codeblock>
template &lt;class U&gt; void f(const U&amp; u);
        </cxx-codeblock>
        </cxx-example>

        <cxx-example class="inline">
        Similarly, the type of <code>p</code> in the following program
        <cxx-codeblock>
template&lt;typename F, typename S&gt; struct Pair;

Pair&lt;const auto&, auto*&gt; p = expr;
        </cxx-codeblock>
is the deduced type of the parameter <code>x</code> in the call of 
<code>g(expr)</code> of the following invented function template:
        <cxx-codeblock>
template&lt;typename U1, typename U2&gt; void g(Pair&lt;const U1&amp;, const U2*&gt; x);
        </cxx-codeblock>
        </cxx-example>
        </p>

      </cxx-section> <!-- dcl.spec.auto -->



        <!-- TODO: Rewrite this section so that it reflects and refers
             to dcl.spec.auto. In particular, we want to say where these
             are allowed, how their placeholder types are deduced, and
             what constraint is introduced. -->
      <cxx-section id="dcl.spec.constr">
        <h1>Constrained type specifiers</h1>

        Add this section to <cxx-ref in="cxx" to="dcl.type"></cxx-ref>.
        The usual formatting marks are omitted since all text is new.

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        designates a placeholder type that will be replaced later by
        deduction from the <cxx-gramarterm>expression</cxx-gramarterm> in a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> or 
        function argument. 

        This deduction succeeds only when the deduced type satisfies the
        constraints introduced by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> 
        also signifies that a lambda is a generic lambda or
        that a function is an abbreviated function. 
        </p>

        <!-- TODO: Maybe a little fuzzy. -->
        <p>
        Like the <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        (<cxx-ref to="dcl.spec.auto"></cxx-ref>), 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        can be used to construct other types. The forms of types that
        can be constructed, and the use of 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        within them are the same as those specified for the <code>auto</code>
        <cxx-grammarterm>type-specifier</cxx-grammarterm>.
        </p>

        <!-- TODO: Consider adding this to the list of non-deduced contexts. -->
        <!--
        <p>
        The <code>auto</code> <cxx-grammarterm>type-specifier</cxx-grammarterm>
        shall not appear in the <cxx-grammarterm>template-argument-list</cxx-grammarterm>
        of a <cxx-grammarterm>patial-concept-id</cxx-grammarterm>. It is
        a non-deduced context.
        </p>
        -->

        <p> If <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm> 
        of a <cxx-grammarterm>lambda-expression</cxx-grammarterm>, the lambda
        is a generic lambda (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        Similarly, if a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        appears in the type of a
        <cxx-grammarterm>parameter-declaration</cxx-grammarterm> of a
        function declaration, the function is an abbreviated function
        (<cxx-ref to="dcl.fct"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T&gt; class Vec;

auto gl [](C&amp; a, C* b) { a = *b; } // <i>OK: a generic lambda</i>
void af(const Vec&lt;C&gt;&amp; x);          // <i>OK: an abbreviated function</i>
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        can also appear in the 
        <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of a 
        <cxx-grammarterm>compound-requirement</cxx-grammarterm> in a
        <cxx-grammarterm>requires-expression</cxx-grammarterm>
        (<cxx-ref to="expr.req"></cxx-ref>).

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;

template&lt;typename T&gt; concept bool Iter() {
  return requires(T i) {
    {*i} -> const C&; // OK
  };
}
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        A program that uses a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in a context not explicitly allowed by this section is ill-formed.
        </p>


        <p>
        When an <cxx-grammarterm>identifier</cxx-grammarterm> is a 
        <cxx-grammarterm>concept-name</cxx-grammarterm> it refers to a set
        of concept definitions (<cxx-ref to="dcl.spec.concept"></cxx-ref>)
        called the <dfn>candidate concept set</dfn>.


        Only type concepts are included in the candidate concept set of
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        
        <cxx-note>
        The candidate concept set of a 
        <cxx-grammarterm>concept-name</cxx-grammarterm> in a
        <cxx-grammarterm>constrained-parameter</cxx-grammarterm> includes
        non-type concepts (<cxx-ref to="temp.param"></cxx-ref>).
        </cxx-note>

        If the candidate concept set is empty, the program is ill-formed.

        <cxx-note>
        The candidate concept set has multiple members
        only when referring to a set of overloaded function concepts.
        There is at most one member when a <cxx-grammarterm>concept-name</cxx-grammarterm>
        refers to a variable concept has at most one member.
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;int N&gt; concept bool C() { return true; }                  // <i>#3</i>
template&lt;typename T&gt; concept bool D = true;                        // <i>#4</i>
template&lt;template&lt;typename&gt; class X&gt; concept bool P = true;        // <i>#5</i>

void f(C); // <i>OK: the concept-name</i> C <i>may refer to both #1 and #2</i>
void g(D); // <i>OK: the concept-name</i> D <i>refers only to #4</i>
void h(P); // <i>error: no matching concept definitions for</i> P
        </cxx-codeblock>
        In the declaration of <code>f(C)</code>, the candidate concept set
        corresponding to the <cxx-grammarterm>concept-name</cxx-grammarterm>,
        <code>C</code>, does not include #3 because its first
        <cxx-grammarterm>template-parameter</cxx-grammarterm> of that
        concept definition is a non-type template parameter.
        Likewise, in the declaration of <code>h(P)</code>, #5 is not
        included because its prototype parameter is not a template
        <cxx-grammarterm>type-parameter</cxx-grammarterm>.
        </cxx-note>
        </p>

        <p>
        A <cxx-grammarterm>partial-concept-id</cxx-grammarterm> is a
        <cxx-grammarterm>concept-name</cxx-grammarterm> followed by a
        sequence of <cxx-grammarterm>template-argument</cxx-grammarterm>s.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T, typename U&gt; concept bool C() { return true; }
template&lt;typename T, int N = 0&gt; concept bool Seq = true;

void f(C&lt;int&gt;);
void f(Seq&lt;3&gt;);
void f(Seq&lt;&gt;);
        </cxx-codeblock>
        </cxx-example>
        </p>

        <p>
        The concept definition designated by a
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm> is
        determined by forming a <cxx-grammarterm>template-id</cxx-grammarterm>
        from the <cxx-grammarterm>concept-name</cxx-grammarterm> and
        a sequence of <cxx-grammarterm>template-arguments</cxx-grammarterm>.

        Let <code>C</code> be the <cxx-grammarterm>concept-name</cxx-grammarterm>
        in the <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>,
        and let <code>T</code> be an invented template <cxx-grammarterm>type-parameter</cxx-grammarterm>
        corresponding to the placeholder type that the
        <cxx-grammarterm>type-specifier</cxx-grammarterm> designates.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>concept-name</cxx-grammarterm>, the
        <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T&gt;</code>.

        When the <cxx-grammarterm>constrained-type-name</cxx-grammarterm> is
        a <cxx-grammarterm>partial-concept-id</cxx-grammarterm> whose
        <cxx-grammarterm>template-argument-list</cxx-grammarterm> is
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub></code>,
        the <cxx-grammarterm>template-id</cxx-grammarterm> is formed as
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>.

        If the <cxx-grammarterm>template-id</cxx-grammarterm> refers to a
        single concept declaration in the candidate concept set, that 
        concept is the one designated by the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.

        Otherwise, the program is ill-formed.

        <cxx-note>
        A <cxx-grammarterm>template-id</cxx-grammarterm> may not refer to
        a template specialization if the template arguments do not match
        the template's declared parameters (<cxx-ref to="temp.arg"></cxx-ref>).
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C() { return true; }             // <i>#1</i>
template&lt;typename T, typename U&gt; concept bool C() { return true; } // <i>#2</i>
template&lt;typename T&gt; concept bool P() { return true; }
template&lt;int T&gt; concept bool P() { return true; }

void f1(const C*); // <i>OK:</i> C <i>designates #1</i>
void f2(C&lt;char&gt;);  // <i>OK:</i> C&lt;char&gt; <i>designates #2</i>
void f3(C&lt;3&gt;);     // <i>error: no matching concept for</i> C&lt;3&gt; <i>(mismatched template arguments)</i>
void g1(P);        // <i>error: resolution of</i> P <i>is ambiguous (</i>P <i>refers to two concepts)</i>
        </cxx-codeblock>
        </cxx-example>
        </p>


        <p>The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        associates a constraint (<cxx-ref to="temp"></cxx-ref>) with the 
        entity for which that parameter is declared. 

        In the case of a generic lambda, the associated constraint appertains 
        to the member function call operator of the closure type 
        (<cxx-ref to="expr.prim.lambda"></cxx-ref>).

        For an abbreviated function declaration, the associated constraint 
        appertains to that function (<cxx-ref to="dcl.fct"></cxx-ref>).

        The use of a <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in the <cxx-grammarterm>trailing-return-type</cxx-grammarterm> of
        a <cxx-grammarterm>compound-requirement</cxx-grammarterm> includes
        an associated constraint in the conjunction of constraints introduced
        by that requirement (<cxx-ref to="expr.req.compound"></cxx-ref>).
        </p>

        <p>
        The constraint associated by a 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        is formed from the <cxx-grammarterm>template-id</cxx-grammarterm>
        used to determine the designated concept. The associated
        constraint is
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>
        when the designated concept is a variable concept
        and 
        <code>C&lt;T, A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;()</code>
        when the designated concept is a function concept.
        
        <cxx-note>
        <code>A<sub>1</sub>, A<sub>2</sub>, ... A<sub><i>n</i></sub>&gt;</code>
        is an empty empty if the <cxx-grammarterm>constrained-type-name</cxx-grammarterm>
        is a <cxx-grammarterm>concept-name</cxx-grammarterm>.
        </cxx-note>

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typename T&gt; concept bool C = true;
template&lt;typename T, typename U&gt; concept bool D() { return true; }

void f(C&amp;);     // associates C&lt;T&gt; with f
void g(D&lt;int&gt;); // associates D&lt;U, int&gt; with g
        </cxx-codeblock>
        In the associated constraints, <code>T</code> and <code>U</code> 
        are invented template type parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>
        in their respective declarations.
        </cxx-example>
        </p>


        <p>
        When multiple <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        appear in the type of a <cxx-grammarterm>parameter-declaration</cxx-grammarterm>
        or a <cxx-grammarterm>trailing-return-type</cxx-grammarterm>,
        the associated or introduced constraints are a conjunction of the
        constraints associated by each 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>.
        These constraints are evaluated in the order in which they appear.

        <cxx-example class="inline">
        <cxx-codeblock>
template&lt;typemame T&gt; concept bool C = true;
template&lt;typemame T, typename U&gt; concept bool D = true;

void f(Pair&lt;C, D&lt;int&gt;&gt;&amp; p);
        </cxx-codeblock>
        The constraint associated by the type of the parameter <code>p</code>
        are:
        <cxx-codeblock>
C&lt;T1&gt; &amp;&amp; D&lt;T2, int&gt;
        </cxx-codeblock>
        where <code>T1</code> and <code>T2</code> are the invented template
        type parameters corresponding to the 
        <cxx-grammarterm>constrained-type-specifier</cxx-grammarterm>s
        <code>C</code> and <code>D&lt;int&gt;</code>.
        </p>
      </cxx-section> <!-- dcl.spec.constr -->

    </cxx-section> <!-- dcl.type -->



    <cxx-section id="dcl.spec.concept">
      <h1><code>concept</code> specifier</h1>

      <p> The <code>concept</code> specifier shall be applied only to the 
      definition of a function template or variable template. 
      A function template definition having the <code>concept</code>
      specifier is called a <dfn>function concept</dfn>. A variable 
      template definition having the <code>concept</code> specifier is called a 
      <dfn>variable concept</dfn>. A <dfn>concept definition</dfn> refers
      to either a function concept and its definition or 
      a variable concept and its initializer.</p>

      <p> The first declared template parameter of a concept definition is its
      <dfn>prototype parameter</dfn>. 

      A <dfn>type concept</dfn> is a concept whose prototype parameter is a type
      <cxx-grammarterm>template-parameter</cxx-grammarterm>. 

      A <dfn>variadic concept</dfn> is a concept whose prototype parameter
      is a template parameter pack.
      </p>

      <p>Every concept definition is also a <code>constexpr</code> declaration
      (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).
      </p>

      <p>A function concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained.</li>
        <li> The return type must be <code>bool</code>. </li>
        <li> The declaration shall have a 
        <cxx-grammarterm>parameter-declaration-clause</cxx-grammarterm>
        equivalent to <code>()</code>. </li>
        <li> The function shall not be recursive. </li>
        <li> The function body shall consist of a single <code>return</code> 
        statement whose <cxx-grammarterm>expression</cxx-grammarterm> shall be a
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool C1() { return true; }  // <i>OK</i>
template&lt;typename T&gt; 
  concept int C2() { return 0; }      // <i>error: return type is not</i> bool
template&lt;typename T&gt; 
  concept bool C3(T) { return true; } // <i>error: must have no parameters</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A variable concept has the following restrictions:
      <ul>
        <li> The template must be unconstrained. </li>
        <li> The declared type must be <code>bool</code>. </li>
        <li> The declaration must have an initializer. </li>
        <li> The initializer shall be a 
        <cxx-grammarterm>constraint-expression</cxx-grammarterm>. </li>
      </ul>
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; 
  concept bool V1 = true;  // OK
template&lt;typename T&gt; 
  concept bool V2 = 3 + 4; // <i>error: initializer is not a constraint-expression</i>
template&lt;Integral T&gt; 
  concept bool V3 = true;  // <i>error: constrained template</i>
concept bool V4 = 0;       // <i>error: not a template</i>
      </cxx-codeblock>
      </cxx-example>
      <!-- </p> -->

      <p>A program that declares an explicit instantiation, an explicit 
      specialization, or a partial specialization of a concept
      definition is ill-formed.
      <cxx-example class="inline">
      <cxx-codeblock>
template&lt;typename T&gt; concept bool C = false;

template concept bool C&lt;char&gt;; // <i>error: explicit instantiation of a concept</i>
template&lt;&gt; 
  concept bool C&lt;int&gt; = true;  // <i>error: explicit specialization of a concept</i>
template&lt;typename T&gt; 
  concept bool C&lt;T*&gt; = true;   // <i>error: partial specialization of a concept</i>
      </cxx-codeblock>
      </cxx-example>
      </p>

      <p>
      <cxx-note>
      The prohibitions against overloading and specialization prevent
      users from subverting the constraint system by providing a meaning 
      for a concept that differs from the one computed by evaluating its 
      constraints.
      </cxx-note>
      </p>

    </cxx-section> <!-- dcl.concept -->

  </cxx-section> <!-- dcl.spec -->
</cxx-clause> <!-- dcl.dcl -->
